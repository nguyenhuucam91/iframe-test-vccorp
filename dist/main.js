/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/gridstack/dist/dd-base-impl.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-base-impl.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDBaseImplement: () => (/* binding */ DDBaseImplement)\n/* harmony export */ });\n/**\n * dd-base-impl.ts 8.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */\nclass DDBaseImplement {\n  constructor() {\n    /** @internal */\n    this._eventRegister = {};\n  }\n  /** returns the enable state, but you have to call enable()/disable() to change (as other things need to happen) */\n  get disabled() {\n    return this._disabled;\n  }\n  on(event, callback) {\n    this._eventRegister[event] = callback;\n  }\n  off(event) {\n    delete this._eventRegister[event];\n  }\n  enable() {\n    this._disabled = false;\n  }\n  disable() {\n    this._disabled = true;\n  }\n  destroy() {\n    delete this._eventRegister;\n  }\n  triggerEvent(eventName, event) {\n    if (!this.disabled && this._eventRegister && this._eventRegister[eventName]) return this._eventRegister[eventName](event);\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/dd-base-impl.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-draggable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-draggable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDDraggable: () => (/* binding */ DDDraggable)\n/* harmony export */ });\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/dd-base-impl.js\");\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/**\n * dd-draggable.ts 8.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */\n\n\n\n\n// make sure we are not clicking on known object that handles mouseDown\nconst skipMouseDown = 'input,textarea,button,select,option,[contenteditable=\"true\"],.ui-resizable-handle';\n// let count = 0; // TEST\nclass DDDraggable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_2__.DDBaseImplement {\n  constructor(el, option = {}) {\n    super();\n    this.el = el;\n    this.option = option;\n    // get the element that is actually supposed to be dragged by\n    let handleName = option.handle.substring(1);\n    this.dragEl = el.classList.contains(handleName) ? el : el.querySelector(option.handle) || el;\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseDown = this._mouseDown.bind(this);\n    this._mouseMove = this._mouseMove.bind(this);\n    this._mouseUp = this._mouseUp.bind(this);\n    this.enable();\n  }\n  on(event, callback) {\n    super.on(event, callback);\n  }\n  off(event) {\n    super.off(event);\n  }\n  enable() {\n    if (this.disabled === false) return;\n    super.enable();\n    this.dragEl.addEventListener('mousedown', this._mouseDown);\n    if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n      this.dragEl.addEventListener('touchstart', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchstart);\n      this.dragEl.addEventListener('pointerdown', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerdown);\n      // this.dragEl.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n    }\n\n    this.el.classList.remove('ui-draggable-disabled');\n  }\n  disable(forDestroy = false) {\n    if (this.disabled === true) return;\n    super.disable();\n    this.dragEl.removeEventListener('mousedown', this._mouseDown);\n    if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n      this.dragEl.removeEventListener('touchstart', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchstart);\n      this.dragEl.removeEventListener('pointerdown', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerdown);\n    }\n    if (!forDestroy) this.el.classList.add('ui-draggable-disabled');\n  }\n  destroy() {\n    if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n    delete this.dragTimeout;\n    if (this.dragging) this._mouseUp(this.mouseDownEvent);\n    this.disable(true);\n    delete this.el;\n    delete this.helper;\n    delete this.option;\n    super.destroy();\n  }\n  updateOption(opts) {\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    return this;\n  }\n  /** @internal call when mouse goes down before a dragstart happens */\n  _mouseDown(e) {\n    // don't let more than one widget handle mouseStart\n    if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled) return;\n    if (e.button !== 0) return true; // only left click\n    // make sure we are not clicking on known object that handles mouseDown, or ones supplied by the user\n    if (e.target.closest(skipMouseDown)) return true;\n    if (this.option.cancel) {\n      if (e.target.closest(this.option.cancel)) return true;\n    }\n    // REMOVE: why would we get the event if it wasn't for us or child ?\n    // make sure we are clicking on a drag handle or child of it...\n    // Note: we don't need to check that's handle is an immediate child, as mouseHandled will prevent parents from also handling it (lowest wins)\n    // let className = this.option.handle.substring(1);\n    // let el = e.target as HTMLElement;\n    // while (el && !el.classList.contains(className)) { el = el.parentElement; }\n    // if (!el) return;\n    this.mouseDownEvent = e;\n    delete this.dragging;\n    delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;\n    delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n    // document handler so we can continue receiving moves as the item is 'fixed' position, and capture=true so WE get a first crack\n    document.addEventListener('mousemove', this._mouseMove, true); // true=capture, not bubble\n    document.addEventListener('mouseup', this._mouseUp, true);\n    if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n      this.dragEl.addEventListener('touchmove', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchmove);\n      this.dragEl.addEventListener('touchend', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchend);\n    }\n    e.preventDefault();\n    // preventDefault() prevents blur event which occurs just after mousedown event.\n    // if an editable content has focus, then blur must be call\n    if (document.activeElement) document.activeElement.blur();\n    _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled = true;\n    return true;\n  }\n  /** @internal method to call actual drag event */\n  _callDrag(e) {\n    if (!this.dragging) return;\n    const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, {\n      target: this.el,\n      type: 'drag'\n    });\n    if (this.option.drag) {\n      this.option.drag(ev, this.ui());\n    }\n    this.triggerEvent('drag', ev);\n  }\n  /** @internal called when the main page (after successful mousedown) receives a move event to drag the item around the screen */\n  _mouseMove(e) {\n    // console.log(`${count++} move ${e.x},${e.y}`)\n    let s = this.mouseDownEvent;\n    if (this.dragging) {\n      this._dragFollow(e);\n      // delay actual grid handling drag until we pause for a while if set\n      if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag) {\n        const pause = Number.isInteger(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag) ? _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag : 100;\n        if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n        this.dragTimeout = window.setTimeout(() => this._callDrag(e), pause);\n      } else {\n        this._callDrag(e);\n      }\n    } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 3) {\n      /**\n       * don't start unless we've moved at least 3 pixels\n       */\n      this.dragging = true;\n      _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement = this;\n      // if we're dragging an actual grid item, set the current drop as the grid (to detect enter/leave)\n      let grid = this.el.gridstackNode?.grid;\n      if (grid) {\n        _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement = grid.el.ddElement.ddDroppable;\n      } else {\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n      }\n      this.helper = this._createHelper(e);\n      this._setupHelperContainmentStyle();\n      this.dragOffset = this._getDragOffset(e, this.el, this.helperContainment);\n      const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, {\n        target: this.el,\n        type: 'dragstart'\n      });\n      this._setupHelperStyle(e);\n      if (this.option.start) {\n        this.option.start(ev, this.ui());\n      }\n      this.triggerEvent('dragstart', ev);\n    }\n    e.preventDefault(); // needed otherwise we get text sweep text selection as we drag around\n    return true;\n  }\n  /** @internal call when the mouse gets released to drop the item at current location */\n  _mouseUp(e) {\n    document.removeEventListener('mousemove', this._mouseMove, true);\n    document.removeEventListener('mouseup', this._mouseUp, true);\n    if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n      this.dragEl.removeEventListener('touchmove', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchmove, true);\n      this.dragEl.removeEventListener('touchend', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchend, true);\n    }\n    if (this.dragging) {\n      delete this.dragging;\n      // reset the drop target if dragging over ourself (already parented, just moving during stop callback below)\n      if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement?.el === this.el.parentElement) {\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n      }\n      this.helperContainment.style.position = this.parentOriginStylePosition || null;\n      if (this.helper === this.el) {\n        this._removeHelperStyle();\n      } else {\n        this.helper.remove();\n      }\n      const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, {\n        target: this.el,\n        type: 'dragstop'\n      });\n      if (this.option.stop) {\n        this.option.stop(ev); // NOTE: destroy() will be called when removing item, so expect NULL ptr after!\n      }\n\n      this.triggerEvent('dragstop', ev);\n      // call the droppable method to receive the item\n      if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement) {\n        _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement.drop(e);\n      }\n    }\n    delete this.helper;\n    delete this.mouseDownEvent;\n    delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;\n    delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n    delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled;\n    e.preventDefault();\n  }\n  /** @internal create a clone copy (or user defined method) of the original drag item if set */\n  _createHelper(event) {\n    let helper = this.el;\n    if (typeof this.option.helper === 'function') {\n      helper = this.option.helper(event);\n    } else if (this.option.helper === 'clone') {\n      helper = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneNode(this.el);\n    }\n    if (!document.body.contains(helper)) {\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.appendTo(helper, this.option.appendTo === 'parent' ? this.el.parentElement : this.option.appendTo);\n    }\n    if (helper === this.el) {\n      this.dragElementOriginStyle = DDDraggable.originStyleProp.map(prop => this.el.style[prop]);\n    }\n    return helper;\n  }\n  /** @internal set the fix position of the dragged item */\n  _setupHelperStyle(e) {\n    this.helper.classList.add('ui-draggable-dragging');\n    // TODO: set all at once with style.cssText += ... ? https://stackoverflow.com/questions/3968593\n    const style = this.helper.style;\n    style.pointerEvents = 'none'; // needed for over items to get enter/leave\n    // style.cursor = 'move'; //  TODO: can't set with pointerEvents=none ! (done in CSS as well)\n    style.width = this.dragOffset.width + 'px';\n    style.height = this.dragOffset.height + 'px';\n    style.willChange = 'left, top';\n    style.position = 'fixed'; // let us drag between grids by not clipping as parent .grid-stack is position: 'relative'\n    this._dragFollow(e); // now position it\n    style.transition = 'none'; // show up instantly\n    setTimeout(() => {\n      if (this.helper) {\n        style.transition = null; // recover animation\n      }\n    }, 0);\n    return this;\n  }\n  /** @internal restore back the original style before dragging */\n  _removeHelperStyle() {\n    this.helper.classList.remove('ui-draggable-dragging');\n    let node = this.helper?.gridstackNode;\n    // don't bother restoring styles if we're gonna remove anyway...\n    if (!node?._isAboutToRemove && this.dragElementOriginStyle) {\n      let helper = this.helper;\n      // don't animate, otherwise we animate offseted when switching back to 'absolute' from 'fixed'.\n      // TODO: this also removes resizing animation which doesn't have this issue, but others.\n      // Ideally both would animate ('move' would immediately restore 'absolute' and adjust coordinate to match,\n      // then trigger a delay (repaint) to restore to final dest with animate) but then we need to make sure 'resizestop'\n      // is called AFTER 'transitionend' event is received (see https://github.com/gridstack/gridstack.js/issues/2033)\n      let transition = this.dragElementOriginStyle['transition'] || null;\n      helper.style.transition = this.dragElementOriginStyle['transition'] = 'none'; // can't be NULL #1973\n      DDDraggable.originStyleProp.forEach(prop => helper.style[prop] = this.dragElementOriginStyle[prop] || null);\n      setTimeout(() => helper.style.transition = transition, 50); // recover animation from saved vars after a pause (0 isn't enough #1973)\n    }\n\n    delete this.dragElementOriginStyle;\n    return this;\n  }\n  /** @internal updates the top/left position to follow the mouse */\n  _dragFollow(e) {\n    let containmentRect = {\n      left: 0,\n      top: 0\n    };\n    // if (this.helper.style.position === 'absolute') { // we use 'fixed'\n    //   const { left, top } = this.helperContainment.getBoundingClientRect();\n    //   containmentRect = { left, top };\n    // }\n    const style = this.helper.style;\n    const offset = this.dragOffset;\n    style.left = e.clientX + offset.offsetLeft - containmentRect.left + 'px';\n    style.top = e.clientY + offset.offsetTop - containmentRect.top + 'px';\n  }\n  /** @internal */\n  _setupHelperContainmentStyle() {\n    this.helperContainment = this.helper.parentElement;\n    if (this.helper.style.position !== 'fixed') {\n      this.parentOriginStylePosition = this.helperContainment.style.position;\n      if (window.getComputedStyle(this.helperContainment).position.match(/static/)) {\n        this.helperContainment.style.position = 'relative';\n      }\n    }\n    return this;\n  }\n  /** @internal */\n  _getDragOffset(event, el, parent) {\n    // in case ancestor has transform/perspective css properties that change the viewpoint\n    let xformOffsetX = 0;\n    let xformOffsetY = 0;\n    if (parent) {\n      const testEl = document.createElement('div');\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addElStyles(testEl, {\n        opacity: '0',\n        position: 'fixed',\n        top: 0 + 'px',\n        left: 0 + 'px',\n        width: '1px',\n        height: '1px',\n        zIndex: '-999999'\n      });\n      parent.appendChild(testEl);\n      const testElPosition = testEl.getBoundingClientRect();\n      parent.removeChild(testEl);\n      xformOffsetX = testElPosition.left;\n      xformOffsetY = testElPosition.top;\n      // TODO: scale ?\n    }\n\n    const targetOffset = el.getBoundingClientRect();\n    return {\n      left: targetOffset.left,\n      top: targetOffset.top,\n      offsetLeft: -event.clientX + targetOffset.left - xformOffsetX,\n      offsetTop: -event.clientY + targetOffset.top - xformOffsetY,\n      width: targetOffset.width,\n      height: targetOffset.height\n    };\n  }\n  /** @internal TODO: set to public as called by DDDroppable! */\n  ui() {\n    const containmentEl = this.el.parentElement;\n    const containmentRect = containmentEl.getBoundingClientRect();\n    const offset = this.helper.getBoundingClientRect();\n    return {\n      position: {\n        top: offset.top - containmentRect.top,\n        left: offset.left - containmentRect.left\n      }\n      /* not used by GridStack for now...\n      helper: [this.helper], //The object arr representing the helper that's being dragged.\n      offset: { top: offset.top, left: offset.left } // Current offset position of the helper as { top, left } object.\n      */\n    };\n  }\n}\n/** @internal properties we change during dragging, and restore back */\nDDDraggable.originStyleProp = ['transition', 'pointerEvents', 'position', 'left', 'top', 'minWidth', 'willChange'];\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/dd-draggable.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-droppable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-droppable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDDroppable: () => (/* binding */ DDDroppable)\n/* harmony export */ });\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/dd-base-impl.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/**\n * dd-droppable.ts 8.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */\n\n\n\n\n// let count = 0; // TEST\nclass DDDroppable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__.DDBaseImplement {\n  constructor(el, opts = {}) {\n    super();\n    this.el = el;\n    this.option = opts;\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseEnter = this._mouseEnter.bind(this);\n    this._mouseLeave = this._mouseLeave.bind(this);\n    this.enable();\n    this._setupAccept();\n  }\n  on(event, callback) {\n    super.on(event, callback);\n  }\n  off(event) {\n    super.off(event);\n  }\n  enable() {\n    if (this.disabled === false) return;\n    super.enable();\n    this.el.classList.add('ui-droppable');\n    this.el.classList.remove('ui-droppable-disabled');\n    this.el.addEventListener('mouseenter', this._mouseEnter);\n    this.el.addEventListener('mouseleave', this._mouseLeave);\n    if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n      this.el.addEventListener('pointerenter', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerenter);\n      this.el.addEventListener('pointerleave', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerleave);\n    }\n  }\n  disable(forDestroy = false) {\n    if (this.disabled === true) return;\n    super.disable();\n    this.el.classList.remove('ui-droppable');\n    if (!forDestroy) this.el.classList.add('ui-droppable-disabled');\n    this.el.removeEventListener('mouseenter', this._mouseEnter);\n    this.el.removeEventListener('mouseleave', this._mouseLeave);\n    if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {\n      this.el.removeEventListener('pointerenter', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerenter);\n      this.el.removeEventListener('pointerleave', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerleave);\n    }\n  }\n  destroy() {\n    this.disable(true);\n    this.el.classList.remove('ui-droppable');\n    this.el.classList.remove('ui-droppable-disabled');\n    super.destroy();\n  }\n  updateOption(opts) {\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    this._setupAccept();\n    return this;\n  }\n  /** @internal called when the cursor enters our area - prepare for a possible drop and track leaving */\n  _mouseEnter(e) {\n    // console.log(`${count++} Enter ${this.el.id || (this.el as GridHTMLElement).gridstack.opts.id}`); // TEST\n    if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement) return;\n    if (!this._canDrop(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement.el)) return;\n    e.preventDefault();\n    e.stopPropagation();\n    // make sure when we enter this, that the last one gets a leave FIRST to correctly cleanup as we don't always do\n    if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement && _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement !== this) {\n      _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement._mouseLeave(e);\n    }\n    _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement = this;\n    const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, {\n      target: this.el,\n      type: 'dropover'\n    });\n    if (this.option.over) {\n      this.option.over(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));\n    }\n    this.triggerEvent('dropover', ev);\n    this.el.classList.add('ui-droppable-over');\n    // console.log('tracking'); // TEST\n  }\n  /** @internal called when the item is leaving our area, stop tracking if we had moving item */\n  _mouseLeave(e) {\n    // console.log(`${count++} Leave ${this.el.id || (this.el as GridHTMLElement).gridstack.opts.id}`); // TEST\n    if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement || _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement !== this) return;\n    e.preventDefault();\n    e.stopPropagation();\n    const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, {\n      target: this.el,\n      type: 'dropout'\n    });\n    if (this.option.out) {\n      this.option.out(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));\n    }\n    this.triggerEvent('dropout', ev);\n    if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement === this) {\n      delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;\n      // console.log('not tracking'); // TEST\n      // if we're still over a parent droppable, send it an enter as we don't get one from leaving nested children\n      let parentDrop;\n      let parent = this.el.parentElement;\n      while (!parentDrop && parent) {\n        parentDrop = parent.ddElement?.ddDroppable;\n        parent = parent.parentElement;\n      }\n      if (parentDrop) {\n        parentDrop._mouseEnter(e);\n      }\n    }\n  }\n  /** item is being dropped on us - called by the drag mouseup handler - this calls the client drop event */\n  drop(e) {\n    e.preventDefault();\n    const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, {\n      target: this.el,\n      type: 'drop'\n    });\n    if (this.option.drop) {\n      this.option.drop(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));\n    }\n    this.triggerEvent('drop', ev);\n  }\n  /** @internal true if element matches the string/method accept option */\n  _canDrop(el) {\n    return el && (!this.accept || this.accept(el));\n  }\n  /** @internal */\n  _setupAccept() {\n    if (!this.option.accept) return this;\n    if (typeof this.option.accept === 'string') {\n      this.accept = el => el.classList.contains(this.option.accept) || el.matches(this.option.accept);\n    } else {\n      this.accept = this.option.accept;\n    }\n    return this;\n  }\n  /** @internal */\n  _ui(drag) {\n    return {\n      draggable: drag.el,\n      ...drag.ui()\n    };\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/dd-droppable.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-element.js":
/*!***************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-element.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDElement: () => (/* binding */ DDElement)\n/* harmony export */ });\n/* harmony import */ var _dd_resizable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-resizable */ \"./node_modules/gridstack/dist/dd-resizable.js\");\n/* harmony import */ var _dd_draggable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-draggable */ \"./node_modules/gridstack/dist/dd-draggable.js\");\n/* harmony import */ var _dd_droppable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-droppable */ \"./node_modules/gridstack/dist/dd-droppable.js\");\n/**\n * dd-elements.ts 8.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */\n\n\n\nclass DDElement {\n  static init(el) {\n    if (!el.ddElement) {\n      el.ddElement = new DDElement(el);\n    }\n    return el.ddElement;\n  }\n  constructor(el) {\n    this.el = el;\n  }\n  on(eventName, callback) {\n    if (this.ddDraggable && ['drag', 'dragstart', 'dragstop'].indexOf(eventName) > -1) {\n      this.ddDraggable.on(eventName, callback);\n    } else if (this.ddDroppable && ['drop', 'dropover', 'dropout'].indexOf(eventName) > -1) {\n      this.ddDroppable.on(eventName, callback);\n    } else if (this.ddResizable && ['resizestart', 'resize', 'resizestop'].indexOf(eventName) > -1) {\n      this.ddResizable.on(eventName, callback);\n    }\n    return this;\n  }\n  off(eventName) {\n    if (this.ddDraggable && ['drag', 'dragstart', 'dragstop'].indexOf(eventName) > -1) {\n      this.ddDraggable.off(eventName);\n    } else if (this.ddDroppable && ['drop', 'dropover', 'dropout'].indexOf(eventName) > -1) {\n      this.ddDroppable.off(eventName);\n    } else if (this.ddResizable && ['resizestart', 'resize', 'resizestop'].indexOf(eventName) > -1) {\n      this.ddResizable.off(eventName);\n    }\n    return this;\n  }\n  setupDraggable(opts) {\n    if (!this.ddDraggable) {\n      this.ddDraggable = new _dd_draggable__WEBPACK_IMPORTED_MODULE_1__.DDDraggable(this.el, opts);\n    } else {\n      this.ddDraggable.updateOption(opts);\n    }\n    return this;\n  }\n  cleanDraggable() {\n    if (this.ddDraggable) {\n      this.ddDraggable.destroy();\n      delete this.ddDraggable;\n    }\n    return this;\n  }\n  setupResizable(opts) {\n    if (!this.ddResizable) {\n      this.ddResizable = new _dd_resizable__WEBPACK_IMPORTED_MODULE_0__.DDResizable(this.el, opts);\n    } else {\n      this.ddResizable.updateOption(opts);\n    }\n    return this;\n  }\n  cleanResizable() {\n    if (this.ddResizable) {\n      this.ddResizable.destroy();\n      delete this.ddResizable;\n    }\n    return this;\n  }\n  setupDroppable(opts) {\n    if (!this.ddDroppable) {\n      this.ddDroppable = new _dd_droppable__WEBPACK_IMPORTED_MODULE_2__.DDDroppable(this.el, opts);\n    } else {\n      this.ddDroppable.updateOption(opts);\n    }\n    return this;\n  }\n  cleanDroppable() {\n    if (this.ddDroppable) {\n      this.ddDroppable.destroy();\n      delete this.ddDroppable;\n    }\n    return this;\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/dd-element.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-gridstack.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-gridstack.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDGridStack: () => (/* binding */ DDGridStack)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/* harmony import */ var _dd_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-element */ \"./node_modules/gridstack/dist/dd-element.js\");\n/**\n * dd-gridstack.ts 8.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */\n\n\n\n// let count = 0; // TEST\n/**\n * HTML Native Mouse and Touch Events Drag and Drop functionality.\n */\nclass DDGridStack {\n  resizable(el, opts, key, value) {\n    this._getDDElements(el).forEach(dEl => {\n      if (opts === 'disable' || opts === 'enable') {\n        dEl.ddResizable && dEl.ddResizable[opts](); // can't create DD as it requires options for setupResizable()\n      } else if (opts === 'destroy') {\n        dEl.ddResizable && dEl.cleanResizable();\n      } else if (opts === 'option') {\n        dEl.setupResizable({\n          [key]: value\n        });\n      } else {\n        const grid = dEl.el.gridstackNode.grid;\n        let handles = dEl.el.getAttribute('gs-resize-handles') ? dEl.el.getAttribute('gs-resize-handles') : grid.opts.resizable.handles;\n        let autoHide = !grid.opts.alwaysShowResizeHandle;\n        dEl.setupResizable({\n          ...grid.opts.resizable,\n          ...{\n            handles,\n            autoHide\n          },\n          ...{\n            start: opts.start,\n            stop: opts.stop,\n            resize: opts.resize\n          }\n        });\n      }\n    });\n    return this;\n  }\n  draggable(el, opts, key, value) {\n    this._getDDElements(el).forEach(dEl => {\n      if (opts === 'disable' || opts === 'enable') {\n        dEl.ddDraggable && dEl.ddDraggable[opts](); // can't create DD as it requires options for setupDraggable()\n      } else if (opts === 'destroy') {\n        dEl.ddDraggable && dEl.cleanDraggable();\n      } else if (opts === 'option') {\n        dEl.setupDraggable({\n          [key]: value\n        });\n      } else {\n        const grid = dEl.el.gridstackNode.grid;\n        dEl.setupDraggable({\n          ...grid.opts.draggable,\n          ...{\n            // containment: (grid.parentGridItem && !grid.opts.dragOut) ? grid.el.parentElement : (grid.opts.draggable.containment || null),\n            start: opts.start,\n            stop: opts.stop,\n            drag: opts.drag\n          }\n        });\n      }\n    });\n    return this;\n  }\n  dragIn(el, opts) {\n    this._getDDElements(el).forEach(dEl => dEl.setupDraggable(opts));\n    return this;\n  }\n  droppable(el, opts, key, value) {\n    if (typeof opts.accept === 'function' && !opts._accept) {\n      opts._accept = opts.accept;\n      opts.accept = el => opts._accept(el);\n    }\n    this._getDDElements(el).forEach(dEl => {\n      if (opts === 'disable' || opts === 'enable') {\n        dEl.ddDroppable && dEl.ddDroppable[opts]();\n      } else if (opts === 'destroy') {\n        if (dEl.ddDroppable) {\n          // error to call destroy if not there\n          dEl.cleanDroppable();\n        }\n      } else if (opts === 'option') {\n        dEl.setupDroppable({\n          [key]: value\n        });\n      } else {\n        dEl.setupDroppable(opts);\n      }\n    });\n    return this;\n  }\n  /** true if element is droppable */\n  isDroppable(el) {\n    return !!(el && el.ddElement && el.ddElement.ddDroppable && !el.ddElement.ddDroppable.disabled);\n  }\n  /** true if element is draggable */\n  isDraggable(el) {\n    return !!(el && el.ddElement && el.ddElement.ddDraggable && !el.ddElement.ddDraggable.disabled);\n  }\n  /** true if element is draggable */\n  isResizable(el) {\n    return !!(el && el.ddElement && el.ddElement.ddResizable && !el.ddElement.ddResizable.disabled);\n  }\n  on(el, name, callback) {\n    this._getDDElements(el).forEach(dEl => dEl.on(name, event => {\n      callback(event, _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement ? _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement.el : event.target, _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement ? _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement.helper : null);\n    }));\n    return this;\n  }\n  off(el, name) {\n    this._getDDElements(el).forEach(dEl => dEl.off(name));\n    return this;\n  }\n  /** @internal returns a list of DD elements, creating them on the fly by default */\n  _getDDElements(els, create = true) {\n    let hosts = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.getElements(els);\n    if (!hosts.length) return [];\n    let list = hosts.map(e => e.ddElement || (create ? _dd_element__WEBPACK_IMPORTED_MODULE_2__.DDElement.init(e) : null));\n    if (!create) {\n      list.filter(d => d);\n    } // remove nulls\n    return list;\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/dd-gridstack.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-manager.js":
/*!***************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-manager.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDManager: () => (/* binding */ DDManager)\n/* harmony export */ });\n/**\n * dd-manager.ts 8.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */\n/**\n * globals that are shared across Drag & Drop instances\n */\nclass DDManager {}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/dd-manager.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-resizable-handle.js":
/*!************************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-resizable-handle.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDResizableHandle: () => (/* binding */ DDResizableHandle)\n/* harmony export */ });\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/**\n * dd-resizable-handle.ts 8.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */\n\nclass DDResizableHandle {\n  constructor(host, direction, option) {\n    /** @internal true after we've moved enough pixels to start a resize */\n    this.moving = false;\n    this.host = host;\n    this.dir = direction;\n    this.option = option;\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseDown = this._mouseDown.bind(this);\n    this._mouseMove = this._mouseMove.bind(this);\n    this._mouseUp = this._mouseUp.bind(this);\n    this._init();\n  }\n  /** @internal */\n  _init() {\n    const el = document.createElement('div');\n    el.classList.add('ui-resizable-handle');\n    el.classList.add(`${DDResizableHandle.prefix}${this.dir}`);\n    el.style.zIndex = '100';\n    el.style.userSelect = 'none';\n    this.el = el;\n    this.host.appendChild(this.el);\n    this.el.addEventListener('mousedown', this._mouseDown);\n    if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n      this.el.addEventListener('touchstart', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchstart);\n      this.el.addEventListener('pointerdown', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.pointerdown);\n      // this.el.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n    }\n\n    return this;\n  }\n  /** call this when resize handle needs to be removed and cleaned up */\n  destroy() {\n    if (this.moving) this._mouseUp(this.mouseDownEvent);\n    this.el.removeEventListener('mousedown', this._mouseDown);\n    if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n      this.el.removeEventListener('touchstart', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchstart);\n      this.el.removeEventListener('pointerdown', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.pointerdown);\n    }\n    this.host.removeChild(this.el);\n    delete this.el;\n    delete this.host;\n    return this;\n  }\n  /** @internal called on mouse down on us: capture move on the entire document (mouse might not stay on us) until we release the mouse */\n  _mouseDown(e) {\n    this.mouseDownEvent = e;\n    document.addEventListener('mousemove', this._mouseMove, true); // capture, not bubble\n    document.addEventListener('mouseup', this._mouseUp, true);\n    if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n      this.el.addEventListener('touchmove', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchmove);\n      this.el.addEventListener('touchend', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchend);\n    }\n    e.stopPropagation();\n    e.preventDefault();\n  }\n  /** @internal */\n  _mouseMove(e) {\n    let s = this.mouseDownEvent;\n    if (this.moving) {\n      this._triggerEvent('move', e);\n    } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 2) {\n      // don't start unless we've moved at least 3 pixels\n      this.moving = true;\n      this._triggerEvent('start', this.mouseDownEvent);\n      this._triggerEvent('move', e);\n    }\n    e.stopPropagation();\n    e.preventDefault();\n  }\n  /** @internal */\n  _mouseUp(e) {\n    if (this.moving) {\n      this._triggerEvent('stop', e);\n    }\n    document.removeEventListener('mousemove', this._mouseMove, true);\n    document.removeEventListener('mouseup', this._mouseUp, true);\n    if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n      this.el.removeEventListener('touchmove', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchmove);\n      this.el.removeEventListener('touchend', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchend);\n    }\n    delete this.moving;\n    delete this.mouseDownEvent;\n    e.stopPropagation();\n    e.preventDefault();\n  }\n  /** @internal */\n  _triggerEvent(name, event) {\n    if (this.option[name]) this.option[name](event);\n    return this;\n  }\n}\n/** @internal */\nDDResizableHandle.prefix = 'ui-resizable-';\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/dd-resizable-handle.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-resizable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-resizable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDResizable: () => (/* binding */ DDResizable)\n/* harmony export */ });\n/* harmony import */ var _dd_resizable_handle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-resizable-handle */ \"./node_modules/gridstack/dist/dd-resizable-handle.js\");\n/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-base-impl */ \"./node_modules/gridstack/dist/dd-base-impl.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/**\n * dd-resizable.ts 8.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */\n\n\n\n\nclass DDResizable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__.DDBaseImplement {\n  constructor(el, opts = {}) {\n    super();\n    /** @internal */\n    this._ui = () => {\n      const containmentEl = this.el.parentElement;\n      const containmentRect = containmentEl.getBoundingClientRect();\n      const newRect = {\n        width: this.originalRect.width,\n        height: this.originalRect.height + this.scrolled,\n        left: this.originalRect.left,\n        top: this.originalRect.top - this.scrolled\n      };\n      const rect = this.temporalRect || newRect;\n      return {\n        position: {\n          left: rect.left - containmentRect.left,\n          top: rect.top - containmentRect.top\n        },\n        size: {\n          width: rect.width,\n          height: rect.height\n        }\n        /* Gridstack ONLY needs position set above... keep around in case.\n        element: [this.el], // The object representing the element to be resized\n        helper: [], // TODO: not support yet - The object representing the helper that's being resized\n        originalElement: [this.el],// we don't wrap here, so simplify as this.el //The object representing the original element before it is wrapped\n        originalPosition: { // The position represented as { left, top } before the resizable is resized\n          left: this.originalRect.left - containmentRect.left,\n          top: this.originalRect.top - containmentRect.top\n        },\n        originalSize: { // The size represented as { width, height } before the resizable is resized\n          width: this.originalRect.width,\n          height: this.originalRect.height\n        }\n        */\n      };\n    };\n\n    this.el = el;\n    this.option = opts;\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseOver = this._mouseOver.bind(this);\n    this._mouseOut = this._mouseOut.bind(this);\n    this.enable();\n    this._setupAutoHide(this.option.autoHide);\n    this._setupHandlers();\n  }\n  on(event, callback) {\n    super.on(event, callback);\n  }\n  off(event) {\n    super.off(event);\n  }\n  enable() {\n    super.enable();\n    this.el.classList.remove('ui-resizable-disabled');\n    this._setupAutoHide(this.option.autoHide);\n  }\n  disable() {\n    super.disable();\n    this.el.classList.add('ui-resizable-disabled');\n    this._setupAutoHide(false);\n  }\n  destroy() {\n    this._removeHandlers();\n    this._setupAutoHide(false);\n    delete this.el;\n    super.destroy();\n  }\n  updateOption(opts) {\n    let updateHandles = opts.handles && opts.handles !== this.option.handles;\n    let updateAutoHide = opts.autoHide && opts.autoHide !== this.option.autoHide;\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    if (updateHandles) {\n      this._removeHandlers();\n      this._setupHandlers();\n    }\n    if (updateAutoHide) {\n      this._setupAutoHide(this.option.autoHide);\n    }\n    return this;\n  }\n  /** @internal turns auto hide on/off */\n  _setupAutoHide(auto) {\n    if (auto) {\n      this.el.classList.add('ui-resizable-autohide');\n      // use mouseover and not mouseenter to get better performance and track for nested cases\n      this.el.addEventListener('mouseover', this._mouseOver);\n      this.el.addEventListener('mouseout', this._mouseOut);\n    } else {\n      this.el.classList.remove('ui-resizable-autohide');\n      this.el.removeEventListener('mouseover', this._mouseOver);\n      this.el.removeEventListener('mouseout', this._mouseOut);\n      if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement === this) {\n        delete _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement;\n      }\n    }\n    return this;\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _mouseOver(e) {\n    // console.log(`${count++} pre-enter ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n    // already over a child, ignore. Ideally we just call e.stopPropagation() but see https://github.com/gridstack/gridstack.js/issues/2018\n    if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement || _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.dragElement) return;\n    _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement = this;\n    // console.log(`${count++} enter ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n    this.el.classList.remove('ui-resizable-autohide');\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _mouseOut(e) {\n    // console.log(`${count++} pre-leave ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n    if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement !== this) return;\n    delete _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement;\n    // console.log(`${count++} leave ${(this.el as GridItemHTMLElement).gridstackNode._id}`)\n    this.el.classList.add('ui-resizable-autohide');\n  }\n  /** @internal */\n  _setupHandlers() {\n    let handlerDirection = this.option.handles || 'e,s,se';\n    if (handlerDirection === 'all') {\n      handlerDirection = 'n,e,s,w,se,sw,ne,nw';\n    }\n    this.handlers = handlerDirection.split(',').map(dir => dir.trim()).map(dir => new _dd_resizable_handle__WEBPACK_IMPORTED_MODULE_0__.DDResizableHandle(this.el, dir, {\n      start: event => {\n        this._resizeStart(event);\n      },\n      stop: event => {\n        this._resizeStop(event);\n      },\n      move: event => {\n        this._resizing(event, dir);\n      }\n    }));\n    return this;\n  }\n  /** @internal */\n  _resizeStart(event) {\n    this.originalRect = this.el.getBoundingClientRect();\n    this.scrollEl = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.getScrollElement(this.el);\n    this.scrollY = this.scrollEl.scrollTop;\n    this.scrolled = 0;\n    this.startEvent = event;\n    this._setupHelper();\n    this._applyChange();\n    const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, {\n      type: 'resizestart',\n      target: this.el\n    });\n    if (this.option.start) {\n      this.option.start(ev, this._ui());\n    }\n    this.el.classList.add('ui-resizable-resizing');\n    this.triggerEvent('resizestart', ev);\n    return this;\n  }\n  /** @internal */\n  _resizing(event, dir) {\n    this.scrolled = this.scrollEl.scrollTop - this.scrollY;\n    this.temporalRect = this._getChange(event, dir);\n    this._applyChange();\n    const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, {\n      type: 'resize',\n      target: this.el\n    });\n    if (this.option.resize) {\n      this.option.resize(ev, this._ui());\n    }\n    this.triggerEvent('resize', ev);\n    return this;\n  }\n  /** @internal */\n  _resizeStop(event) {\n    const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, {\n      type: 'resizestop',\n      target: this.el\n    });\n    if (this.option.stop) {\n      this.option.stop(ev); // Note: ui() not used by gridstack so don't pass\n    }\n\n    this.el.classList.remove('ui-resizable-resizing');\n    this.triggerEvent('resizestop', ev);\n    this._cleanHelper();\n    delete this.startEvent;\n    delete this.originalRect;\n    delete this.temporalRect;\n    delete this.scrollY;\n    delete this.scrolled;\n    return this;\n  }\n  /** @internal */\n  _setupHelper() {\n    this.elOriginStyleVal = DDResizable._originStyleProp.map(prop => this.el.style[prop]);\n    this.parentOriginStylePosition = this.el.parentElement.style.position;\n    if (window.getComputedStyle(this.el.parentElement).position.match(/static/)) {\n      this.el.parentElement.style.position = 'relative';\n    }\n    this.el.style.position = 'absolute';\n    this.el.style.opacity = '0.8';\n    return this;\n  }\n  /** @internal */\n  _cleanHelper() {\n    DDResizable._originStyleProp.forEach((prop, i) => {\n      this.el.style[prop] = this.elOriginStyleVal[i] || null;\n    });\n    this.el.parentElement.style.position = this.parentOriginStylePosition || null;\n    return this;\n  }\n  /** @internal */\n  _getChange(event, dir) {\n    const oEvent = this.startEvent;\n    const newRect = {\n      width: this.originalRect.width,\n      height: this.originalRect.height + this.scrolled,\n      left: this.originalRect.left,\n      top: this.originalRect.top - this.scrolled\n    };\n    const offsetX = event.clientX - oEvent.clientX;\n    const offsetY = event.clientY - oEvent.clientY;\n    if (dir.indexOf('e') > -1) {\n      newRect.width += offsetX;\n    } else if (dir.indexOf('w') > -1) {\n      newRect.width -= offsetX;\n      newRect.left += offsetX;\n    }\n    if (dir.indexOf('s') > -1) {\n      newRect.height += offsetY;\n    } else if (dir.indexOf('n') > -1) {\n      newRect.height -= offsetY;\n      newRect.top += offsetY;\n    }\n    const constrain = this._constrainSize(newRect.width, newRect.height);\n    if (Math.round(newRect.width) !== Math.round(constrain.width)) {\n      // round to ignore slight round-off errors\n      if (dir.indexOf('w') > -1) {\n        newRect.left += newRect.width - constrain.width;\n      }\n      newRect.width = constrain.width;\n    }\n    if (Math.round(newRect.height) !== Math.round(constrain.height)) {\n      if (dir.indexOf('n') > -1) {\n        newRect.top += newRect.height - constrain.height;\n      }\n      newRect.height = constrain.height;\n    }\n    return newRect;\n  }\n  /** @internal constrain the size to the set min/max values */\n  _constrainSize(oWidth, oHeight) {\n    const maxWidth = this.option.maxWidth || Number.MAX_SAFE_INTEGER;\n    const minWidth = this.option.minWidth || oWidth;\n    const maxHeight = this.option.maxHeight || Number.MAX_SAFE_INTEGER;\n    const minHeight = this.option.minHeight || oHeight;\n    const width = Math.min(maxWidth, Math.max(minWidth, oWidth));\n    const height = Math.min(maxHeight, Math.max(minHeight, oHeight));\n    return {\n      width,\n      height\n    };\n  }\n  /** @internal */\n  _applyChange() {\n    let containmentRect = {\n      left: 0,\n      top: 0,\n      width: 0,\n      height: 0\n    };\n    if (this.el.style.position === 'absolute') {\n      const containmentEl = this.el.parentElement;\n      const {\n        left,\n        top\n      } = containmentEl.getBoundingClientRect();\n      containmentRect = {\n        left,\n        top,\n        width: 0,\n        height: 0\n      };\n    }\n    if (!this.temporalRect) return this;\n    Object.keys(this.temporalRect).forEach(key => {\n      const value = this.temporalRect[key];\n      this.el.style[key] = value - containmentRect[key] + 'px';\n    });\n    return this;\n  }\n  /** @internal */\n  _removeHandlers() {\n    this.handlers.forEach(handle => handle.destroy());\n    delete this.handlers;\n    return this;\n  }\n}\n/** @internal */\nDDResizable._originStyleProp = ['width', 'height', 'position', 'left', 'top', 'opacity', 'zIndex'];\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/dd-resizable.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-touch.js":
/*!*************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-touch.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTouch: () => (/* binding */ isTouch),\n/* harmony export */   pointerdown: () => (/* binding */ pointerdown),\n/* harmony export */   pointerenter: () => (/* binding */ pointerenter),\n/* harmony export */   pointerleave: () => (/* binding */ pointerleave),\n/* harmony export */   touchend: () => (/* binding */ touchend),\n/* harmony export */   touchmove: () => (/* binding */ touchmove),\n/* harmony export */   touchstart: () => (/* binding */ touchstart)\n/* harmony export */ });\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/**\n * touch.ts 8.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */\n\n/**\n * Detect touch support - Windows Surface devices and other touch devices\n * should we use this instead ? (what we had for always showing resize handles)\n * /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)\n */\nconst isTouch = typeof window !== 'undefined' && typeof document !== 'undefined' && ('ontouchstart' in document || 'ontouchstart' in window\n// || !!window.TouchEvent // true on Windows 10 Chrome desktop so don't use this\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n|| window.DocumentTouch && document instanceof window.DocumentTouch || navigator.maxTouchPoints > 0\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n|| navigator.msMaxTouchPoints > 0);\n// interface TouchCoord {x: number, y: number};\nclass DDTouch {}\n/**\n* Get the x,y position of a touch event\n*/\n// function getTouchCoords(e: TouchEvent): TouchCoord {\n//   return {\n//     x: e.changedTouches[0].pageX,\n//     y: e.changedTouches[0].pageY\n//   };\n// }\n/**\n * Simulate a mouse event based on a corresponding touch event\n * @param {Object} e A touch event\n * @param {String} simulatedType The corresponding mouse event\n */\nfunction simulateMouseEvent(e, simulatedType) {\n  // Ignore multi-touch events\n  if (e.touches.length > 1) return;\n  // Prevent \"Ignored attempt to cancel a touchmove event with cancelable=false\" errors\n  if (e.cancelable) e.preventDefault();\n  const touch = e.changedTouches[0],\n    simulatedEvent = document.createEvent('MouseEvents');\n  // Initialize the simulated mouse event using the touch event's coordinates\n  simulatedEvent.initMouseEvent(simulatedType,\n  // type\n  true,\n  // bubbles\n  true,\n  // cancelable\n  window,\n  // view\n  1,\n  // detail\n  touch.screenX,\n  // screenX\n  touch.screenY,\n  // screenY\n  touch.clientX,\n  // clientX\n  touch.clientY,\n  // clientY\n  false,\n  // ctrlKey\n  false,\n  // altKey\n  false,\n  // shiftKey\n  false,\n  // metaKey\n  0,\n  // button\n  null // relatedTarget\n  );\n  // Dispatch the simulated event to the target element\n  e.target.dispatchEvent(simulatedEvent);\n}\n/**\n * Simulate a mouse event based on a corresponding Pointer event\n * @param {Object} e A pointer event\n * @param {String} simulatedType The corresponding mouse event\n */\nfunction simulatePointerMouseEvent(e, simulatedType) {\n  // Prevent \"Ignored attempt to cancel a touchmove event with cancelable=false\" errors\n  if (e.cancelable) e.preventDefault();\n  const simulatedEvent = document.createEvent('MouseEvents');\n  // Initialize the simulated mouse event using the touch event's coordinates\n  simulatedEvent.initMouseEvent(simulatedType,\n  // type\n  true,\n  // bubbles\n  true,\n  // cancelable\n  window,\n  // view\n  1,\n  // detail\n  e.screenX,\n  // screenX\n  e.screenY,\n  // screenY\n  e.clientX,\n  // clientX\n  e.clientY,\n  // clientY\n  false,\n  // ctrlKey\n  false,\n  // altKey\n  false,\n  // shiftKey\n  false,\n  // metaKey\n  0,\n  // button\n  null // relatedTarget\n  );\n  // Dispatch the simulated event to the target element\n  e.target.dispatchEvent(simulatedEvent);\n}\n/**\n * Handle the touchstart events\n * @param {Object} e The widget element's touchstart event\n */\nfunction touchstart(e) {\n  // Ignore the event if another widget is already being handled\n  if (DDTouch.touchHandled) return;\n  DDTouch.touchHandled = true;\n  // Simulate the mouse events\n  // simulateMouseEvent(e, 'mouseover');\n  // simulateMouseEvent(e, 'mousemove');\n  simulateMouseEvent(e, 'mousedown');\n}\n/**\n * Handle the touchmove events\n * @param {Object} e The document's touchmove event\n */\nfunction touchmove(e) {\n  // Ignore event if not handled by us\n  if (!DDTouch.touchHandled) return;\n  simulateMouseEvent(e, 'mousemove');\n}\n/**\n * Handle the touchend events\n * @param {Object} e The document's touchend event\n */\nfunction touchend(e) {\n  // Ignore event if not handled\n  if (!DDTouch.touchHandled) return;\n  // cancel delayed leave event when we release on ourself which happens BEFORE we get this!\n  if (DDTouch.pointerLeaveTimeout) {\n    window.clearTimeout(DDTouch.pointerLeaveTimeout);\n    delete DDTouch.pointerLeaveTimeout;\n  }\n  const wasDragging = !!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;\n  // Simulate the mouseup event\n  simulateMouseEvent(e, 'mouseup');\n  // simulateMouseEvent(event, 'mouseout');\n  // If the touch interaction did not move, it should trigger a click\n  if (!wasDragging) {\n    simulateMouseEvent(e, 'click');\n  }\n  // Unset the flag to allow other widgets to inherit the touch event\n  DDTouch.touchHandled = false;\n}\n/**\n * Note we don't get touchenter/touchleave (which are deprecated)\n * see https://stackoverflow.com/questions/27908339/js-touch-equivalent-for-mouseenter\n * so instead of PointerEvent to still get enter/leave and send the matching mouse event.\n */\nfunction pointerdown(e) {\n  // console.log(\"pointer down\")\n  e.target.releasePointerCapture(e.pointerId); // <- Important!\n}\n\nfunction pointerenter(e) {\n  // ignore the initial one we get on pointerdown on ourself\n  if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement) {\n    // console.log('pointerenter ignored');\n    return;\n  }\n  // console.log('pointerenter');\n  simulatePointerMouseEvent(e, 'mouseenter');\n}\nfunction pointerleave(e) {\n  // ignore the leave on ourself we get before releasing the mouse over ourself\n  // by delaying sending the event and having the up event cancel us\n  if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement) {\n    // console.log('pointerleave ignored');\n    return;\n  }\n  DDTouch.pointerLeaveTimeout = window.setTimeout(() => {\n    delete DDTouch.pointerLeaveTimeout;\n    // console.log('pointerleave delayed');\n    simulatePointerMouseEvent(e, 'mouseleave');\n  }, 10);\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/dd-touch.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/gridstack-engine.js":
/*!*********************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack-engine.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridStackEngine: () => (/* binding */ GridStackEngine)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/**\n * gridstack-engine.ts 8.4.0\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */\n\n/**\n * Defines the GridStack engine that does most no DOM grid manipulation.\n * See GridStack methods and vars for descriptions.\n *\n * NOTE: values should not be modified directly - call the main GridStack API instead\n */\nclass GridStackEngine {\n  constructor(opts = {}) {\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.column = opts.column || 12;\n    this.maxRow = opts.maxRow;\n    this._float = opts.float;\n    this.nodes = opts.nodes || [];\n    this.onChange = opts.onChange;\n  }\n  batchUpdate(flag = true, doPack = true) {\n    if (!!this.batchMode === flag) return this;\n    this.batchMode = flag;\n    if (flag) {\n      this._prevFloat = this._float;\n      this._float = true; // let things go anywhere for now... will restore and possibly reposition later\n      this.saveInitial(); // since begin update (which is called multiple times) won't do this\n    } else {\n      this._float = this._prevFloat;\n      delete this._prevFloat;\n      if (doPack) this._packNodes();\n      this._notify();\n    }\n    return this;\n  }\n  // use entire row for hitting area (will use bottom reverse sorted first) if we not actively moving DOWN and didn't already skip\n  _useEntireRowArea(node, nn) {\n    return (!this.float || this.batchMode && !this._prevFloat) && !this._hasLocked && (!node._moving || node._skipDown || nn.y <= node.y);\n  }\n  /** @internal fix collision on given 'node', going to given new location 'nn', with optional 'collide' node already found.\n   * return true if we moved. */\n  _fixCollisions(node, nn = node, collide, opt = {}) {\n    this.sortNodes(-1); // from last to first, so recursive collision move items in the right order\n    collide = collide || this.collide(node, nn); // REAL area collide for swap and skip if none...\n    if (!collide) return false;\n    // swap check: if we're actively moving in gravity mode, see if we collide with an object the same size\n    if (node._moving && !opt.nested && !this.float) {\n      if (this.swap(node, collide)) return true;\n    }\n    // during while() collisions MAKE SURE to check entire row so larger items don't leap frog small ones (push them all down starting last in grid)\n    let area = nn;\n    if (this._useEntireRowArea(node, nn)) {\n      area = {\n        x: 0,\n        w: this.column,\n        y: nn.y,\n        h: nn.h\n      };\n      collide = this.collide(node, area, opt.skip); // force new hit\n    }\n\n    let didMove = false;\n    let newOpt = {\n      nested: true,\n      pack: false\n    };\n    while (collide = collide || this.collide(node, area, opt.skip)) {\n      // could collide with more than 1 item... so repeat for each\n      let moved;\n      // if colliding with a locked item OR moving down with top gravity (and collide could move up) -> skip past the collide,\n      // but remember that skip down so we only do this once (and push others otherwise).\n      if (collide.locked || node._moving && !node._skipDown && nn.y > node.y && !this.float && (\n      // can take space we had, or before where we're going\n      !this.collide(collide, {\n        ...collide,\n        y: node.y\n      }, node) || !this.collide(collide, {\n        ...collide,\n        y: nn.y - collide.h\n      }, node))) {\n        node._skipDown = node._skipDown || nn.y > node.y;\n        moved = this.moveNode(node, {\n          ...nn,\n          y: collide.y + collide.h,\n          ...newOpt\n        });\n        if (collide.locked && moved) {\n          _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(nn, node); // moving after lock become our new desired location\n        } else if (!collide.locked && moved && opt.pack) {\n          // we moved after and will pack: do it now and keep the original drop location, but past the old collide to see what else we might push way\n          this._packNodes();\n          nn.y = collide.y + collide.h;\n          _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(node, nn);\n        }\n        didMove = didMove || moved;\n      } else {\n        // move collide down *after* where we will be, ignoring where we are now (don't collide with us)\n        moved = this.moveNode(collide, {\n          ...collide,\n          y: nn.y + nn.h,\n          skip: node,\n          ...newOpt\n        });\n      }\n      if (!moved) {\n        return didMove;\n      } // break inf loop if we couldn't move after all (ex: maxRow, fixed)\n      collide = undefined;\n    }\n    return didMove;\n  }\n  /** return the nodes that intercept the given node. Optionally a different area can be used, as well as a second node to skip */\n  collide(skip, area = skip, skip2) {\n    const skipId = skip._id;\n    const skip2Id = skip2?._id;\n    return this.nodes.find(n => n._id !== skipId && n._id !== skip2Id && _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(n, area));\n  }\n  collideAll(skip, area = skip, skip2) {\n    const skipId = skip._id;\n    const skip2Id = skip2?._id;\n    return this.nodes.filter(n => n._id !== skipId && n._id !== skip2Id && _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(n, area));\n  }\n  /** does a pixel coverage collision based on where we started, returning the node that has the most coverage that is >50% mid line */\n  directionCollideCoverage(node, o, collides) {\n    if (!o.rect || !node._rect) return;\n    let r0 = node._rect; // where started\n    let r = {\n      ...o.rect\n    }; // where we are\n    // update dragged rect to show where it's coming from (above or below, etc...)\n    if (r.y > r0.y) {\n      r.h += r.y - r0.y;\n      r.y = r0.y;\n    } else {\n      r.h += r0.y - r.y;\n    }\n    if (r.x > r0.x) {\n      r.w += r.x - r0.x;\n      r.x = r0.x;\n    } else {\n      r.w += r0.x - r.x;\n    }\n    let collide;\n    collides.forEach(n => {\n      if (n.locked || !n._rect) return;\n      let r2 = n._rect; // overlapping target\n      let yOver = Number.MAX_VALUE,\n        xOver = Number.MAX_VALUE,\n        overMax = 0.5; // need >50%\n      // depending on which side we started from, compute the overlap % of coverage\n      // (ex: from above/below we only compute the max horizontal line coverage)\n      if (r0.y < r2.y) {\n        // from above\n        yOver = (r.y + r.h - r2.y) / r2.h;\n      } else if (r0.y + r0.h > r2.y + r2.h) {\n        // from below\n        yOver = (r2.y + r2.h - r.y) / r2.h;\n      }\n      if (r0.x < r2.x) {\n        // from the left\n        xOver = (r.x + r.w - r2.x) / r2.w;\n      } else if (r0.x + r0.w > r2.x + r2.w) {\n        // from the right\n        xOver = (r2.x + r2.w - r.x) / r2.w;\n      }\n      let over = Math.min(xOver, yOver);\n      if (over > overMax) {\n        overMax = over;\n        collide = n;\n      }\n    });\n    o.collide = collide; // save it so we don't have to find it again\n    return collide;\n  }\n  /** does a pixel coverage returning the node that has the most coverage by area */\n  /*\n  protected collideCoverage(r: GridStackPosition, collides: GridStackNode[]): {collide: GridStackNode, over: number} {\n    let collide: GridStackNode;\n    let overMax = 0;\n    collides.forEach(n => {\n      if (n.locked || !n._rect) return;\n      let over = Utils.areaIntercept(r, n._rect);\n      if (over > overMax) {\n        overMax = over;\n        collide = n;\n      }\n    });\n    return {collide, over: overMax};\n  }\n  */\n  /** called to cache the nodes pixel rectangles used for collision detection during drag */\n  cacheRects(w, h, top, right, bottom, left) {\n    this.nodes.forEach(n => n._rect = {\n      y: n.y * h + top,\n      x: n.x * w + left,\n      w: n.w * w - left - right,\n      h: n.h * h - top - bottom\n    });\n    return this;\n  }\n  /** called to possibly swap between 2 nodes (same size or column, not locked, touching), returning true if successful */\n  swap(a, b) {\n    if (!b || b.locked || !a || a.locked) return false;\n    function _doSwap() {\n      let x = b.x,\n        y = b.y;\n      b.x = a.x;\n      b.y = a.y; // b -> a position\n      if (a.h != b.h) {\n        a.x = x;\n        a.y = b.y + b.h; // a -> goes after b\n      } else if (a.w != b.w) {\n        a.x = b.x + b.w;\n        a.y = y; // a -> goes after b\n      } else {\n        a.x = x;\n        a.y = y; // a -> old b position\n      }\n\n      a._dirty = b._dirty = true;\n      return true;\n    }\n    let touching; // remember if we called it (vs undefined)\n    // same size and same row or column, and touching\n    if (a.w === b.w && a.h === b.h && (a.x === b.x || a.y === b.y) && (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b))) return _doSwap();\n    if (touching === false) return; // IFF ran test and fail, bail out\n    // check for taking same columns (but different height) and touching\n    if (a.w === b.w && a.x === b.x && (touching || (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b)))) {\n      if (b.y < a.y) {\n        let t = a;\n        a = b;\n        b = t;\n      } // swap a <-> b vars so a is first\n      return _doSwap();\n    }\n    if (touching === false) return;\n    // check if taking same row (but different width) and touching\n    if (a.h === b.h && a.y === b.y && (touching || (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b)))) {\n      if (b.x < a.x) {\n        let t = a;\n        a = b;\n        b = t;\n      } // swap a <-> b vars so a is first\n      return _doSwap();\n    }\n    return false;\n  }\n  isAreaEmpty(x, y, w, h) {\n    let nn = {\n      x: x || 0,\n      y: y || 0,\n      w: w || 1,\n      h: h || 1\n    };\n    return !this.collide(nn);\n  }\n  /** re-layout grid items to reclaim any empty space - optionally keeping the sort order exactly the same ('list' mode) vs truly finding an empty spaces */\n  compact(layout = 'compact', doSort = true) {\n    if (this.nodes.length === 0) return this;\n    if (doSort) this.sortNodes();\n    const wasBatch = this.batchMode;\n    if (!wasBatch) this.batchUpdate();\n    const wasColumnResize = this._inColumnResize;\n    if (!wasColumnResize) this._inColumnResize = true; // faster addNode()\n    let copyNodes = this.nodes;\n    this.nodes = []; // pretend we have no nodes to conflict layout to start with...\n    copyNodes.forEach((n, index, list) => {\n      let after;\n      if (!n.locked) {\n        n.autoPosition = true;\n        if (layout === 'list' && index) after = list[index - 1];\n      }\n      this.addNode(n, false, after); // 'false' for add event trigger\n    });\n\n    if (!wasColumnResize) delete this._inColumnResize;\n    if (!wasBatch) this.batchUpdate(false);\n    return this;\n  }\n  /** enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html) */\n  set float(val) {\n    if (this._float === val) return;\n    this._float = val || false;\n    if (!val) {\n      this._packNodes()._notify();\n    }\n  }\n  /** float getter method */\n  get float() {\n    return this._float || false;\n  }\n  /** sort the nodes array from first to last, or reverse. Called during collision/placement to force an order */\n  sortNodes(dir = 1, column = this.column) {\n    this.nodes = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(this.nodes, dir, column);\n    return this;\n  }\n  /** @internal called to top gravity pack the items back OR revert back to original Y positions when floating */\n  _packNodes() {\n    if (this.batchMode) {\n      return this;\n    }\n    this.sortNodes(); // first to last\n    if (this.float) {\n      // restore original Y pos\n      this.nodes.forEach(n => {\n        if (n._updating || n._orig === undefined || n.y === n._orig.y) return;\n        let newY = n.y;\n        while (newY > n._orig.y) {\n          --newY;\n          let collide = this.collide(n, {\n            x: n.x,\n            y: newY,\n            w: n.w,\n            h: n.h\n          });\n          if (!collide) {\n            n._dirty = true;\n            n.y = newY;\n          }\n        }\n      });\n    } else {\n      // top gravity pack\n      this.nodes.forEach((n, i) => {\n        if (n.locked) return;\n        while (n.y > 0) {\n          let newY = i === 0 ? 0 : n.y - 1;\n          let canBeMoved = i === 0 || !this.collide(n, {\n            x: n.x,\n            y: newY,\n            w: n.w,\n            h: n.h\n          });\n          if (!canBeMoved) break;\n          // Note: must be dirty (from last position) for GridStack::OnChange CB to update positions\n          // and move items back. The user 'change' CB should detect changes from the original\n          // starting position instead.\n          n._dirty = n.y !== newY;\n          n.y = newY;\n        }\n      });\n    }\n    return this;\n  }\n  /**\n   * given a random node, makes sure it's coordinates/values are valid in the current grid\n   * @param node to adjust\n   * @param resizing if out of bound, resize down or move into the grid to fit ?\n   */\n  prepareNode(node, resizing) {\n    node = node || {};\n    node._id = node._id ?? GridStackEngine._idSeq++;\n    // if we're missing position, have the grid position us automatically (before we set them to 0,0)\n    if (node.x === undefined || node.y === undefined || node.x === null || node.y === null) {\n      node.autoPosition = true;\n    }\n    // assign defaults for missing required fields\n    let defaults = {\n      x: 0,\n      y: 0,\n      w: 1,\n      h: 1\n    };\n    _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.defaults(node, defaults);\n    if (!node.autoPosition) {\n      delete node.autoPosition;\n    }\n    if (!node.noResize) {\n      delete node.noResize;\n    }\n    if (!node.noMove) {\n      delete node.noMove;\n    }\n    _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sanitizeMinMax(node);\n    // check for NaN (in case messed up strings were passed. can't do parseInt() || defaults.x above as 0 is valid #)\n    if (typeof node.x == 'string') {\n      node.x = Number(node.x);\n    }\n    if (typeof node.y == 'string') {\n      node.y = Number(node.y);\n    }\n    if (typeof node.w == 'string') {\n      node.w = Number(node.w);\n    }\n    if (typeof node.h == 'string') {\n      node.h = Number(node.h);\n    }\n    if (isNaN(node.x)) {\n      node.x = defaults.x;\n      node.autoPosition = true;\n    }\n    if (isNaN(node.y)) {\n      node.y = defaults.y;\n      node.autoPosition = true;\n    }\n    if (isNaN(node.w)) {\n      node.w = defaults.w;\n    }\n    if (isNaN(node.h)) {\n      node.h = defaults.h;\n    }\n    return this.nodeBoundFix(node, resizing);\n  }\n  /** part2 of preparing a node to fit inside our grid - checks for x,y,w from grid dimensions */\n  nodeBoundFix(node, resizing) {\n    let before = node._orig || _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node);\n    if (node.maxW) {\n      node.w = Math.min(node.w, node.maxW);\n    }\n    if (node.maxH) {\n      node.h = Math.min(node.h, node.maxH);\n    }\n    if (node.minW && node.minW <= this.column) {\n      node.w = Math.max(node.w, node.minW);\n    }\n    if (node.minH) {\n      node.h = Math.max(node.h, node.minH);\n    }\n    // if user loaded a larger than allowed widget for current # of columns (or force 1 column mode),\n    // remember it's position & width so we can restore back (1 -> 12 column) #1655 #1985\n    // IFF we're not in the middle of column resizing!\n    const saveOrig = this.column === 1 || node.x + node.w > this.column;\n    if (saveOrig && this.column < 12 && !this._inColumnResize && node._id && this.findCacheLayout(node, 12) === -1) {\n      let copy = {\n        ...node\n      }; // need _id + positions\n      if (copy.autoPosition) {\n        delete copy.x;\n        delete copy.y;\n      } else copy.x = Math.min(11, copy.x);\n      copy.w = Math.min(12, copy.w);\n      this.cacheOneLayout(copy, 12);\n    }\n    if (node.w > this.column) {\n      node.w = this.column;\n    } else if (node.w < 1) {\n      node.w = 1;\n    }\n    if (this.maxRow && node.h > this.maxRow) {\n      node.h = this.maxRow;\n    } else if (node.h < 1) {\n      node.h = 1;\n    }\n    if (node.x < 0) {\n      node.x = 0;\n    }\n    if (node.y < 0) {\n      node.y = 0;\n    }\n    if (node.x + node.w > this.column) {\n      if (resizing) {\n        node.w = this.column - node.x;\n      } else {\n        node.x = this.column - node.w;\n      }\n    }\n    if (this.maxRow && node.y + node.h > this.maxRow) {\n      if (resizing) {\n        node.h = this.maxRow - node.y;\n      } else {\n        node.y = this.maxRow - node.h;\n      }\n    }\n    if (!_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, before)) {\n      node._dirty = true;\n    }\n    return node;\n  }\n  /** returns a list of modified nodes from their original values */\n  getDirtyNodes(verify) {\n    // compare original x,y,w,h instead as _dirty can be a temporary state\n    if (verify) {\n      return this.nodes.filter(n => n._dirty && !_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(n, n._orig));\n    }\n    return this.nodes.filter(n => n._dirty);\n  }\n  /** @internal call this to call onChange callback with dirty nodes so DOM can be updated */\n  _notify(removedNodes) {\n    if (this.batchMode || !this.onChange) return this;\n    let dirtyNodes = (removedNodes || []).concat(this.getDirtyNodes());\n    this.onChange(dirtyNodes);\n    return this;\n  }\n  /** @internal remove dirty and last tried info */\n  cleanNodes() {\n    if (this.batchMode) return this;\n    this.nodes.forEach(n => {\n      delete n._dirty;\n      delete n._lastTried;\n    });\n    return this;\n  }\n  /** @internal called to save initial position/size to track real dirty state.\n   * Note: should be called right after we call change event (so next API is can detect changes)\n   * as well as right before we start move/resize/enter (so we can restore items to prev values) */\n  saveInitial() {\n    this.nodes.forEach(n => {\n      n._orig = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, n);\n      delete n._dirty;\n    });\n    this._hasLocked = this.nodes.some(n => n.locked);\n    return this;\n  }\n  /** @internal restore all the nodes back to initial values (called when we leave) */\n  restoreInitial() {\n    this.nodes.forEach(n => {\n      if (_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(n, n._orig)) return;\n      _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(n, n._orig);\n      n._dirty = true;\n    });\n    this._notify();\n    return this;\n  }\n  /** find the first available empty spot for the given node width/height, updating the x,y attributes. return true if found.\n   * optionally you can pass your own existing node list and column count, otherwise defaults to that engine data.\n   * Optionally pass a widget to start search AFTER, meaning the order will remain the same but possibly have empty slots we skipped\n   */\n  findEmptyPosition(node, nodeList = this.nodes, column = this.column, after) {\n    let start = after ? after.y * column + (after.x + after.w) : 0;\n    let found = false;\n    for (let i = start; !found; ++i) {\n      let x = i % column;\n      let y = Math.floor(i / column);\n      if (x + node.w > column) {\n        continue;\n      }\n      let box = {\n        x,\n        y,\n        w: node.w,\n        h: node.h\n      };\n      if (!nodeList.find(n => _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(box, n))) {\n        if (node.x !== x || node.y !== y) node._dirty = true;\n        node.x = x;\n        node.y = y;\n        delete node.autoPosition;\n        found = true;\n      }\n    }\n    return found;\n  }\n  /** call to add the given node to our list, fixing collision and re-packing */\n  addNode(node, triggerAddEvent = false, after) {\n    let dup = this.nodes.find(n => n._id === node._id);\n    if (dup) return dup; // prevent inserting twice! return it instead.\n    // skip prepareNode if we're in middle of column resize (not new) but do check for bounds!\n    node = this._inColumnResize ? this.nodeBoundFix(node) : this.prepareNode(node);\n    delete node._temporaryRemoved;\n    delete node._removeDOM;\n    let skipCollision;\n    if (node.autoPosition && this.findEmptyPosition(node, this.nodes, this.column, after)) {\n      delete node.autoPosition; // found our slot\n      skipCollision = true;\n    }\n    this.nodes.push(node);\n    if (triggerAddEvent) {\n      this.addedNodes.push(node);\n    }\n    if (!skipCollision) this._fixCollisions(node);\n    if (!this.batchMode) {\n      this._packNodes()._notify();\n    }\n    return node;\n  }\n  removeNode(node, removeDOM = true, triggerEvent = false) {\n    if (!this.nodes.find(n => n._id === node._id)) {\n      // TEST console.log(`Error: GridStackEngine.removeNode() node._id=${node._id} not found!`)\n      return this;\n    }\n    if (triggerEvent) {\n      // we wait until final drop to manually track removed items (rather than during drag)\n      this.removedNodes.push(node);\n    }\n    if (removeDOM) node._removeDOM = true; // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n    // don't use 'faster' .splice(findIndex(),1) in case node isn't in our list, or in multiple times.\n    this.nodes = this.nodes.filter(n => n._id !== node._id);\n    if (!node._isAboutToRemove) this._packNodes(); // if dragged out, no need to relayout as already done...\n    this._notify([node]);\n    return this;\n  }\n  removeAll(removeDOM = true) {\n    delete this._layouts;\n    if (!this.nodes.length) return this;\n    removeDOM && this.nodes.forEach(n => n._removeDOM = true); // let CB remove actual HTML (used to set _id to null, but then we loose layout info)\n    this.removedNodes = this.nodes;\n    this.nodes = [];\n    return this._notify(this.removedNodes);\n  }\n  /** checks if item can be moved (layout constrain) vs moveNode(), returning true if was able to move.\n   * In more complicated cases (maxRow) it will attempt at moving the item and fixing\n   * others in a clone first, then apply those changes if still within specs. */\n  moveNodeCheck(node, o) {\n    // if (node.locked) return false;\n    if (!this.changedPosConstrain(node, o)) return false;\n    o.pack = true;\n    // simpler case: move item directly...\n    if (!this.maxRow) {\n      return this.moveNode(node, o);\n    }\n    // complex case: create a clone with NO maxRow (will check for out of bounds at the end)\n    let clonedNode;\n    let clone = new GridStackEngine({\n      column: this.column,\n      float: this.float,\n      nodes: this.nodes.map(n => {\n        if (n._id === node._id) {\n          clonedNode = {\n            ...n\n          };\n          return clonedNode;\n        }\n        return {\n          ...n\n        };\n      })\n    });\n    if (!clonedNode) return false;\n    // check if we're covering 50% collision and could move\n    let canMove = clone.moveNode(clonedNode, o) && clone.getRow() <= this.maxRow;\n    // else check if we can force a swap (float=true, or different shapes) on non-resize\n    if (!canMove && !o.resizing && o.collide) {\n      let collide = o.collide.el.gridstackNode; // find the source node the clone collided with at 50%\n      if (this.swap(node, collide)) {\n        // swaps and mark dirty\n        this._notify();\n        return true;\n      }\n    }\n    if (!canMove) return false;\n    // if clone was able to move, copy those mods over to us now instead of caller trying to do this all over!\n    // Note: we can't use the list directly as elements and other parts point to actual node, so copy content\n    clone.nodes.filter(n => n._dirty).forEach(c => {\n      let n = this.nodes.find(a => a._id === c._id);\n      if (!n) return;\n      _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(n, c);\n      n._dirty = true;\n    });\n    this._notify();\n    return true;\n  }\n  /** return true if can fit in grid height constrain only (always true if no maxRow) */\n  willItFit(node) {\n    delete node._willFitPos;\n    if (!this.maxRow) return true;\n    // create a clone with NO maxRow and check if still within size\n    let clone = new GridStackEngine({\n      column: this.column,\n      float: this.float,\n      nodes: this.nodes.map(n => {\n        return {\n          ...n\n        };\n      })\n    });\n    let n = {\n      ...node\n    }; // clone node so we don't mod any settings on it but have full autoPosition and min/max as well! #1687\n    this.cleanupNode(n);\n    delete n.el;\n    delete n._id;\n    delete n.content;\n    delete n.grid;\n    clone.addNode(n);\n    if (clone.getRow() <= this.maxRow) {\n      node._willFitPos = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, n);\n      return true;\n    }\n    return false;\n  }\n  /** true if x,y or w,h are different after clamping to min/max */\n  changedPosConstrain(node, p) {\n    // first make sure w,h are set for caller\n    p.w = p.w || node.w;\n    p.h = p.h || node.h;\n    if (node.x !== p.x || node.y !== p.y) return true;\n    // check constrained w,h\n    if (node.maxW) {\n      p.w = Math.min(p.w, node.maxW);\n    }\n    if (node.maxH) {\n      p.h = Math.min(p.h, node.maxH);\n    }\n    if (node.minW) {\n      p.w = Math.max(p.w, node.minW);\n    }\n    if (node.minH) {\n      p.h = Math.max(p.h, node.minH);\n    }\n    return node.w !== p.w || node.h !== p.h;\n  }\n  /** return true if the passed in node was actually moved (checks for no-op and locked) */\n  moveNode(node, o) {\n    if (!node || /*node.locked ||*/!o) return false;\n    let wasUndefinedPack;\n    if (o.pack === undefined) {\n      wasUndefinedPack = o.pack = true;\n    }\n    // constrain the passed in values and check if we're still changing our node\n    if (typeof o.x !== 'number') {\n      o.x = node.x;\n    }\n    if (typeof o.y !== 'number') {\n      o.y = node.y;\n    }\n    if (typeof o.w !== 'number') {\n      o.w = node.w;\n    }\n    if (typeof o.h !== 'number') {\n      o.h = node.h;\n    }\n    let resizing = node.w !== o.w || node.h !== o.h;\n    let nn = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node, true); // get min/max out first, then opt positions next\n    _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(nn, o);\n    nn = this.nodeBoundFix(nn, resizing);\n    _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(o, nn);\n    if (_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, o)) return false;\n    let prevPos = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node);\n    // check if we will need to fix collision at our new location\n    let collides = this.collideAll(node, nn, o.skip);\n    let needToMove = true;\n    if (collides.length) {\n      let activeDrag = node._moving && !o.nested;\n      // check to make sure we actually collided over 50% surface area while dragging\n      let collide = activeDrag ? this.directionCollideCoverage(node, o, collides) : collides[0];\n      // if we're enabling creation of sub-grids on the fly, see if we're covering 80% of either one, if we didn't already do that\n      if (activeDrag && collide && node.grid?.opts?.subGridDynamic && !node.grid._isTemp) {\n        let over = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.areaIntercept(o.rect, collide._rect);\n        let a1 = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.area(o.rect);\n        let a2 = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.area(collide._rect);\n        let perc = over / (a1 < a2 ? a1 : a2);\n        if (perc > .8) {\n          collide.grid.makeSubGrid(collide.el, undefined, node);\n          collide = undefined;\n        }\n      }\n      if (collide) {\n        needToMove = !this._fixCollisions(node, nn, collide, o); // check if already moved...\n      } else {\n        needToMove = false; // we didn't cover >50% for a move, skip...\n        if (wasUndefinedPack) delete o.pack;\n      }\n    }\n    // now move (to the original ask vs the collision version which might differ) and repack things\n    if (needToMove) {\n      node._dirty = true;\n      _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(node, nn);\n    }\n    if (o.pack) {\n      this._packNodes()._notify();\n    }\n    return !_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, prevPos); // pack might have moved things back\n  }\n\n  getRow() {\n    return this.nodes.reduce((row, n) => Math.max(row, n.y + n.h), 0);\n  }\n  beginUpdate(node) {\n    if (!node._updating) {\n      node._updating = true;\n      delete node._skipDown;\n      if (!this.batchMode) this.saveInitial();\n    }\n    return this;\n  }\n  endUpdate() {\n    let n = this.nodes.find(n => n._updating);\n    if (n) {\n      delete n._updating;\n      delete n._skipDown;\n    }\n    return this;\n  }\n  /** saves a copy of the largest column layout (eg 12 even when rendering oneColumnMode) so we don't loose orig layout,\n   * returning a list of widgets for serialization */\n  save(saveElement = true, saveCB) {\n    // use the highest layout for any saved info so we can have full detail on reload #1849\n    let len = this._layouts?.length;\n    let layout = len && this.column !== len - 1 ? this._layouts[len - 1] : null;\n    let list = [];\n    this.sortNodes();\n    this.nodes.forEach(n => {\n      let wl = layout?.find(l => l._id === n._id);\n      let w = {\n        ...n\n      };\n      // use layout info instead if set\n      if (wl) {\n        w.x = wl.x;\n        w.y = wl.y;\n        w.w = wl.w;\n      }\n      _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.removeInternalForSave(w, !saveElement);\n      if (saveCB) saveCB(n, w);\n      list.push(w);\n    });\n    return list;\n  }\n  /** @internal called whenever a node is added or moved - updates the cached layouts */\n  layoutsNodesChange(nodes) {\n    if (!this._layouts || this._inColumnResize) return this;\n    // remove smaller layouts - we will re-generate those on the fly... larger ones need to update\n    this._layouts.forEach((layout, column) => {\n      if (!layout || column === this.column) return this;\n      if (column < this.column) {\n        this._layouts[column] = undefined;\n      } else {\n        // we save the original x,y,w (h isn't cached) to see what actually changed to propagate better.\n        // NOTE: we don't need to check against out of bound scaling/moving as that will be done when using those cache values. #1785\n        let ratio = column / this.column;\n        nodes.forEach(node => {\n          if (!node._orig) return; // didn't change (newly added ?)\n          let n = layout.find(l => l._id === node._id);\n          if (!n) return; // no cache for new nodes. Will use those values.\n          // Y changed, push down same amount\n          // TODO: detect doing item 'swaps' will help instead of move (especially in 1 column mode)\n          if (node.y !== node._orig.y) {\n            n.y += node.y - node._orig.y;\n          }\n          // X changed, scale from new position\n          if (node.x !== node._orig.x) {\n            n.x = Math.round(node.x * ratio);\n          }\n          // width changed, scale from new width\n          if (node.w !== node._orig.w) {\n            n.w = Math.round(node.w * ratio);\n          }\n          // ...height always carries over from cache\n        });\n      }\n    });\n\n    return this;\n  }\n  /**\n   * @internal Called to scale the widget width & position up/down based on the column change.\n   * Note we store previous layouts (especially original ones) to make it possible to go\n   * from say 12 -> 1 -> 12 and get back to where we were.\n   *\n   * @param prevColumn previous number of columns\n   * @param column  new column number\n   * @param nodes different sorted list (ex: DOM order) instead of current list\n   * @param layout specify the type of re-layout that will happen (position, size, etc...).\n   * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column\n   */\n  columnChanged(prevColumn, column, nodes, layout = 'moveScale') {\n    if (!this.nodes.length || !column || prevColumn === column) return this;\n    // simpler shortcuts layouts\n    const doCompact = layout === 'compact' || layout === 'list';\n    if (doCompact) {\n      this.sortNodes(1, prevColumn); // sort with original layout once and only once (new column will affect order otherwise)\n    }\n    // cache the current layout in case they want to go back (like 12 -> 1 -> 12) as it requires original data IFF we're sizing down (see below)\n    if (column < prevColumn) this.cacheLayout(this.nodes, prevColumn);\n    this.batchUpdate(); // do this EARLY as it will call saveInitial() so we can detect where we started for _dirty and collision\n    let newNodes = [];\n    // if we're going to 1 column and using DOM order (item passed in) rather than default sorting, then generate that layout\n    let domOrder = false;\n    if (column === 1 && nodes?.length) {\n      domOrder = true;\n      let top = 0;\n      nodes.forEach(n => {\n        n.x = 0;\n        n.w = 1;\n        n.y = Math.max(n.y, top);\n        top = n.y + n.h;\n      });\n      newNodes = nodes;\n      nodes = [];\n    } else {\n      nodes = doCompact ? this.nodes : _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(this.nodes, -1, prevColumn); // current column reverse sorting so we can insert last to front (limit collision)\n    }\n    // see if we have cached previous layout IFF we are going up in size (restore) otherwise always\n    // generate next size down from where we are (looks more natural as you gradually size down).\n    if (column > prevColumn && this._layouts) {\n      const cacheNodes = this._layouts[column] || [];\n      // ...if not, start with the largest layout (if not already there) as down-scaling is more accurate\n      // by pretending we came from that larger column by assigning those values as starting point\n      let lastIndex = this._layouts.length - 1;\n      if (!cacheNodes.length && prevColumn !== lastIndex && this._layouts[lastIndex]?.length) {\n        prevColumn = lastIndex;\n        this._layouts[lastIndex].forEach(cacheNode => {\n          let n = nodes.find(n => n._id === cacheNode._id);\n          if (n) {\n            // still current, use cache info positions\n            if (!doCompact) {\n              n.x = cacheNode.x;\n              n.y = cacheNode.y;\n            }\n            n.w = cacheNode.w;\n          }\n        });\n      }\n      // if we found cache re-use those nodes that are still current\n      cacheNodes.forEach(cacheNode => {\n        let j = nodes.findIndex(n => n._id === cacheNode._id);\n        if (j !== -1) {\n          // still current, use cache info positions\n          if (doCompact) {\n            nodes[j].w = cacheNode.w; // only w is used, and don't trim the list\n            return;\n          }\n          if (cacheNode.autoPosition || isNaN(cacheNode.x) || isNaN(cacheNode.y)) {\n            this.findEmptyPosition(cacheNode, newNodes);\n          }\n          if (!cacheNode.autoPosition) {\n            nodes[j].x = cacheNode.x;\n            nodes[j].y = cacheNode.y;\n            nodes[j].w = cacheNode.w;\n            newNodes.push(nodes[j]);\n          }\n          nodes.splice(j, 1);\n        }\n      });\n    }\n    // much simpler layout that just compacts\n    if (doCompact) {\n      this.compact(layout, false);\n    } else {\n      // ...and add any extra non-cached ones\n      if (nodes.length) {\n        if (typeof layout === 'function') {\n          layout(column, prevColumn, newNodes, nodes);\n        } else if (!domOrder) {\n          let ratio = doCompact || layout === 'none' ? 1 : column / prevColumn;\n          let move = layout === 'move' || layout === 'moveScale';\n          let scale = layout === 'scale' || layout === 'moveScale';\n          nodes.forEach(node => {\n            // NOTE: x + w could be outside of the grid, but addNode() below will handle that\n            node.x = column === 1 ? 0 : move ? Math.round(node.x * ratio) : Math.min(node.x, column - 1);\n            node.w = column === 1 || prevColumn === 1 ? 1 : scale ? Math.round(node.w * ratio) || 1 : Math.min(node.w, column);\n            newNodes.push(node);\n          });\n          nodes = [];\n        }\n      }\n      // finally re-layout them in reverse order (to get correct placement)\n      if (!domOrder) newNodes = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(newNodes, -1, column);\n      this._inColumnResize = true; // prevent cache update\n      this.nodes = []; // pretend we have no nodes to start with (add() will use same structures) to simplify layout\n      newNodes.forEach(node => {\n        this.addNode(node, false); // 'false' for add event trigger\n        delete node._orig; // make sure the commit doesn't try to restore things back to original\n      });\n    }\n\n    this.nodes.forEach(n => delete n._orig); // clear _orig before batch=false so it doesn't handle float=true restore\n    this.batchUpdate(false, !doCompact);\n    delete this._inColumnResize;\n    return this;\n  }\n  /**\n   * call to cache the given layout internally to the given location so we can restore back when column changes size\n   * @param nodes list of nodes\n   * @param column corresponding column index to save it under\n   * @param clear if true, will force other caches to be removed (default false)\n   */\n  cacheLayout(nodes, column, clear = false) {\n    let copy = [];\n    nodes.forEach((n, i) => {\n      n._id = n._id ?? GridStackEngine._idSeq++; // make sure we have an id in case this is new layout, else re-use id already set\n      copy[i] = {\n        x: n.x,\n        y: n.y,\n        w: n.w,\n        _id: n._id\n      }; // only thing we change is x,y,w and id to find it back\n    });\n\n    this._layouts = clear ? [] : this._layouts || []; // use array to find larger quick\n    this._layouts[column] = copy;\n    return this;\n  }\n  /**\n   * call to cache the given node layout internally to the given location so we can restore back when column changes size\n   * @param node single node to cache\n   * @param column corresponding column index to save it under\n   */\n  cacheOneLayout(n, column) {\n    n._id = n._id ?? GridStackEngine._idSeq++;\n    let l = {\n      x: n.x,\n      y: n.y,\n      w: n.w,\n      _id: n._id\n    };\n    if (n.autoPosition) {\n      delete l.x;\n      delete l.y;\n      l.autoPosition = true;\n    }\n    this._layouts = this._layouts || [];\n    this._layouts[column] = this._layouts[column] || [];\n    let index = this.findCacheLayout(n, column);\n    if (index === -1) this._layouts[column].push(l);else this._layouts[column][index] = l;\n    return this;\n  }\n  findCacheLayout(n, column) {\n    return this._layouts?.[column]?.findIndex(l => l._id === n._id) ?? -1;\n  }\n  /** called to remove all internal values but the _id */\n  cleanupNode(node) {\n    for (let prop in node) {\n      if (prop[0] === '_' && prop !== '_id') delete node[prop];\n    }\n    return this;\n  }\n}\n/** @internal unique global internal _id counter */\nGridStackEngine._idSeq = 0;\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/gridstack-engine.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/gridstack.js":
/*!**************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DDGridStack: () => (/* reexport safe */ _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__.DDGridStack),\n/* harmony export */   GridStack: () => (/* binding */ GridStack),\n/* harmony export */   GridStackEngine: () => (/* reexport safe */ _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine),\n/* harmony export */   Utils: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.Utils),\n/* harmony export */   dragInDefaultOptions: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_2__.dragInDefaultOptions),\n/* harmony export */   gridDefaults: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults),\n/* harmony export */   obsolete: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.obsolete),\n/* harmony export */   obsoleteAttr: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.obsoleteAttr),\n/* harmony export */   obsoleteOpts: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.obsoleteOpts),\n/* harmony export */   obsoleteOptsDel: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.obsoleteOptsDel)\n/* harmony export */ });\n/* harmony import */ var _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gridstack-engine */ \"./node_modules/gridstack/dist/gridstack-engine.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/gridstack/dist/utils.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"./node_modules/gridstack/dist/types.js\");\n/* harmony import */ var _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-gridstack */ \"./node_modules/gridstack/dist/dd-gridstack.js\");\n/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dd-touch */ \"./node_modules/gridstack/dist/dd-touch.js\");\n/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dd-manager */ \"./node_modules/gridstack/dist/dd-manager.js\");\n/*!\n * GridStack 8.4.0\n * https://gridstackjs.com/\n *\n * Copyright (c) 2021-2022 Alain Dumesny\n * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE\n */\n\n\n\n/*\n * and include D&D by default\n * TODO: while we could generate a gridstack-static.js at smaller size - saves about 31k (41k -> 72k)\n * I don't know how to generate the DD only code at the remaining 31k to delay load as code depends on Gridstack.ts\n * also it caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\n */\n\n\n\n/** global instance */\nconst dd = new _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__.DDGridStack();\n// export all dependent file as well to make it easier for users to just import the main file\n\n\n\n\n/**\n * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.\n * Note: your grid elements MUST have the following classes for the CSS layout to work:\n * @example\n * <div class=\"grid-stack\">\n *   <div class=\"grid-stack-item\">\n *     <div class=\"grid-stack-item-content\">Item 1</div>\n *   </div>\n * </div>\n */\nclass GridStack {\n  /**\n   * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will\n   * simply return the existing instance (ignore any passed options). There is also an initAll() version that support\n   * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.\n   * @param options grid options (optional)\n   * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)\n   *\n   * @example\n   * let grid = GridStack.init();\n   *\n   * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later\n   * let grid = document.querySelector('.grid-stack').gridstack;\n   */\n  static init(options = {}, elOrString = '.grid-stack') {\n    let el = GridStack.getGridElement(elOrString);\n    if (!el) {\n      if (typeof elOrString === 'string') {\n        console.error('GridStack.initAll() no grid was found with selector \"' + elOrString + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n      } else {\n        console.error('GridStack.init() no grid element was passed.');\n      }\n      return null;\n    }\n    if (!el.gridstack) {\n      el.gridstack = new GridStack(el, _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options));\n    }\n    return el.gridstack;\n  }\n  /**\n   * Will initialize a list of elements (given a selector) and return an array of grids.\n   * @param options grid options (optional)\n   * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)\n   *\n   * @example\n   * let grids = GridStack.initAll();\n   * grids.forEach(...)\n   */\n  static initAll(options = {}, selector = '.grid-stack') {\n    let grids = [];\n    GridStack.getGridElements(selector).forEach(el => {\n      if (!el.gridstack) {\n        el.gridstack = new GridStack(el, _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options));\n      }\n      grids.push(el.gridstack);\n    });\n    if (grids.length === 0) {\n      console.error('GridStack.initAll() no grid was found with selector \"' + selector + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n    }\n    return grids;\n  }\n  /**\n   * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then\n   * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from\n   * JSON serialized data, including options.\n   * @param parent HTML element parent to the grid\n   * @param opt grids options used to initialize the grid, and list of children\n   */\n  static addGrid(parent, opt = {}) {\n    if (!parent) return null;\n    let el = parent;\n    if (el.gridstack) {\n      // already a grid - set option and load data\n      const grid = el.gridstack;\n      if (opt) grid.opts = {\n        ...grid.opts,\n        ...opt\n      };\n      if (opt.children !== undefined) grid.load(opt.children);\n      return grid;\n    }\n    // create the grid element, but check if the passed 'parent' already has grid styling and should be used instead\n    const parentIsGrid = parent.classList.contains('grid-stack');\n    if (!parentIsGrid || GridStack.addRemoveCB) {\n      if (GridStack.addRemoveCB) {\n        el = GridStack.addRemoveCB(parent, opt, true, true);\n      } else {\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n        doc.body.innerHTML = `<div class=\"grid-stack ${opt.class || ''}\"></div>`;\n        el = doc.body.children[0];\n        parent.appendChild(el);\n      }\n    }\n    // create grid class and load any children\n    let grid = GridStack.init(opt, el);\n    return grid;\n  }\n  /** call this method to register your engine instead of the default one.\n   * See instead `GridStackOptions.engineClass` if you only need to\n   * replace just one instance.\n   */\n  static registerEngine(engineClass) {\n    GridStack.engineClass = engineClass;\n  }\n  /** @internal create placeholder DIV as needed */\n  get placeholder() {\n    if (!this._placeholder) {\n      let placeholderChild = document.createElement('div'); // child so padding match item-content\n      placeholderChild.className = 'placeholder-content';\n      if (this.opts.placeholderText) {\n        placeholderChild.innerHTML = this.opts.placeholderText;\n      }\n      this._placeholder = document.createElement('div');\n      this._placeholder.classList.add(this.opts.placeholderClass, _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass, this.opts.itemClass);\n      this.placeholder.appendChild(placeholderChild);\n    }\n    return this._placeholder;\n  }\n  /**\n   * Construct a grid item from the given element and options\n   * @param el\n   * @param opts\n   */\n  constructor(el, opts = {}) {\n    /** @internal */\n    this._gsEventHandler = {};\n    /** @internal extra row added when dragging at the bottom of the grid */\n    this._extraDragRow = 0;\n    this.el = el; // exposed HTML element to the user\n    opts = opts || {}; // handles null/undefined/0\n    if (!el.classList.contains('grid-stack')) {\n      this.el.classList.add('grid-stack');\n    }\n    // if row property exists, replace minRow and maxRow instead\n    if (opts.row) {\n      opts.minRow = opts.maxRow = opts.row;\n      delete opts.row;\n    }\n    let rowAttr = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-row'));\n    // flag only valid in sub-grids (handled by parent, not here)\n    if (opts.column === 'auto') {\n      delete opts.column;\n    }\n    // save original setting so we can restore on save\n    if (opts.alwaysShowResizeHandle !== undefined) {\n      opts._alwaysShowResizeHandle = opts.alwaysShowResizeHandle;\n    }\n    // elements DOM attributes override any passed options (like CSS style) - merge the two together\n    let defaults = {\n      ..._utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(_types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults),\n      column: _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-column')) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.column,\n      minRow: rowAttr ? rowAttr : _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-min-row')) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.minRow,\n      maxRow: rowAttr ? rowAttr : _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-max-row')) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.maxRow,\n      staticGrid: _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-static')) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.staticGrid,\n      draggable: {\n        handle: (opts.handleClass ? '.' + opts.handleClass : opts.handle ? opts.handle : '') || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.draggable.handle\n      },\n      removableOptions: {\n        accept: opts.itemClass || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.removableOptions.accept,\n        decline: _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.removableOptions.decline\n      }\n    };\n    if (el.getAttribute('gs-animate')) {\n      // default to true, but if set to false use that instead\n      defaults.animate = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-animate'));\n    }\n    this.opts = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.defaults(opts, defaults);\n    opts = null; // make sure we use this.opts instead\n    this._initMargin(); // part of settings defaults...\n    // Now check if we're loading into 1 column mode FIRST so we don't do un-necessary work (like cellHeight = width / 12 then go 1 column)\n    if (this.opts.column !== 1 && !this.opts.disableOneColumnMode && this._widthOrContainer() <= this.opts.oneColumnSize) {\n      this._prevColumn = this.getColumn();\n      this.opts.column = 1;\n    }\n    if (this.opts.rtl === 'auto') {\n      this.opts.rtl = el.style.direction === 'rtl';\n    }\n    if (this.opts.rtl) {\n      this.el.classList.add('grid-stack-rtl');\n    }\n    // check if we're been nested, and if so update our style and keep pointer around (used during save)\n    let parentGridItem = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.closestUpByClass(this.el, _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass)?.gridstackNode;\n    if (parentGridItem) {\n      parentGridItem.subGrid = this;\n      this.parentGridItem = parentGridItem;\n      this.el.classList.add('grid-stack-nested');\n      parentGridItem.el.classList.add('grid-stack-sub-grid');\n    }\n    this._isAutoCellHeight = this.opts.cellHeight === 'auto';\n    if (this._isAutoCellHeight || this.opts.cellHeight === 'initial') {\n      // make the cell content square initially (will use resize/column event to keep it square)\n      this.cellHeight(undefined, false);\n    } else {\n      // append unit if any are set\n      if (typeof this.opts.cellHeight == 'number' && this.opts.cellHeightUnit && this.opts.cellHeightUnit !== _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.cellHeightUnit) {\n        this.opts.cellHeight = this.opts.cellHeight + this.opts.cellHeightUnit;\n        delete this.opts.cellHeightUnit;\n      }\n      this.cellHeight(this.opts.cellHeight, false);\n    }\n    // see if we need to adjust auto-hide\n    if (this.opts.alwaysShowResizeHandle === 'mobile') {\n      this.opts.alwaysShowResizeHandle = _dd_touch__WEBPACK_IMPORTED_MODULE_4__.isTouch;\n    }\n    this._styleSheetClass = 'gs-id-' + _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine._idSeq++;\n    this.el.classList.add(this._styleSheetClass);\n    this._setStaticClass();\n    let engineClass = this.opts.engineClass || GridStack.engineClass || _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine;\n    this.engine = new engineClass({\n      column: this.getColumn(),\n      float: this.opts.float,\n      maxRow: this.opts.maxRow,\n      onChange: cbNodes => {\n        let maxH = 0;\n        this.engine.nodes.forEach(n => {\n          maxH = Math.max(maxH, n.y + n.h);\n        });\n        cbNodes.forEach(n => {\n          let el = n.el;\n          if (!el) return;\n          if (n._removeDOM) {\n            if (el) el.remove();\n            delete n._removeDOM;\n          } else {\n            this._writePosAttr(el, n);\n          }\n        });\n        this._updateStyles(false, maxH); // false = don't recreate, just append if need be\n      }\n    });\n\n    if (this.opts.auto) {\n      this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...\n      this.getGridItems().forEach(el => this._prepareElement(el));\n      this.batchUpdate(false);\n    }\n    // load any passed in children as well, which overrides any DOM layout done above\n    if (this.opts.children) {\n      let children = this.opts.children;\n      delete this.opts.children;\n      if (children.length) this.load(children); // don't load empty\n    }\n\n    this.setAnimation(this.opts.animate);\n    this._updateStyles();\n    this.el.classList.add('gs-' + this.opts.column);\n    // dynamic grids require pausing during drag to detect over to nest vs push\n    if (this.opts.subGridDynamic && !_dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag) _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = true;\n    if (this.opts.draggable?.pause !== undefined) _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = this.opts.draggable.pause;\n    this._setupRemoveDrop();\n    this._setupAcceptWidget();\n    this._updateWindowResizeEvent();\n  }\n  /**\n   * add a new widget and returns it.\n   *\n   * Widget will be always placed even if result height is more than actual grid height.\n   * You need to use `willItFit()` before calling addWidget for additional check.\n   * See also `makeWidget()`.\n   *\n   * @example\n   * let grid = GridStack.init();\n   * grid.addWidget({w: 3, content: 'hello'});\n   * grid.addWidget('<div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">hello</div></div>', {w: 3});\n   *\n   * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add\n   * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget\n   */\n  addWidget(els, options) {\n    function isGridStackWidget(w) {\n      return w.el !== undefined || w.x !== undefined || w.y !== undefined || w.w !== undefined || w.h !== undefined || w.content !== undefined ? true : false;\n    }\n    let el;\n    let node;\n    if (typeof els === 'string') {\n      let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n      doc.body.innerHTML = els;\n      el = doc.body.children[0];\n    } else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {\n      node = options = els;\n      if (node?.el) {\n        el = node.el; // re-use element stored in the node\n      } else if (GridStack.addRemoveCB) {\n        el = GridStack.addRemoveCB(this.el, options, true, false);\n      } else {\n        let content = options?.content || '';\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n        doc.body.innerHTML = `<div class=\"grid-stack-item ${this.opts.itemClass || ''}\"><div class=\"grid-stack-item-content\">${content}</div></div>`;\n        el = doc.body.children[0];\n      }\n    } else {\n      el = els;\n    }\n    if (!el) return;\n    // if the caller ended up initializing the widget in addRemoveCB, or we stared with one already, skip the rest\n    node = el.gridstackNode;\n    if (node && el.parentElement === this.el && this.engine.nodes.find(n => n._id === node._id)) return el;\n    // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos\n    // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz') before adding the node.\n    // So make sure we load any DOM attributes that are not specified in passed in options (which override)\n    let domAttr = this._readAttr(el);\n    options = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options) || {}; // make a copy before we modify in case caller re-uses it\n    _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.defaults(options, domAttr);\n    node = this.engine.prepareNode(options);\n    this._writeAttr(el, options);\n    if (this._insertNotAppend) {\n      this.el.prepend(el);\n    } else {\n      this.el.appendChild(el);\n    }\n    this.makeWidget(el, options);\n    return el;\n  }\n  /**\n   * Convert an existing gridItem element into a sub-grid with the given (optional) options, else inherit them\n   * from the parent's subGrid options.\n   * @param el gridItem element to convert\n   * @param ops (optional) sub-grid options, else default to node, then parent settings, else defaults\n   * @param nodeToAdd (optional) node to add to the newly created sub grid (used when dragging over existing regular item)\n   * @returns newly created grid\n   */\n  makeSubGrid(el, ops, nodeToAdd, saveContent = true) {\n    let node = el.gridstackNode;\n    if (!node) {\n      node = this.makeWidget(el).gridstackNode;\n    }\n    if (node.subGrid?.el) return node.subGrid; // already done\n    // find the template subGrid stored on a parent as fallback...\n    let subGridTemplate; // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let grid = this;\n    while (grid && !subGridTemplate) {\n      subGridTemplate = grid.opts?.subGridOpts;\n      grid = grid.parentGridItem?.grid;\n    }\n    //... and set the create options\n    ops = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep({\n      ...(subGridTemplate || {}),\n      children: undefined,\n      ...(ops || node.subGridOpts)\n    });\n    node.subGridOpts = ops;\n    // if column special case it set, remember that flag and set default\n    let autoColumn;\n    if (ops.column === 'auto') {\n      autoColumn = true;\n      ops.column = Math.max(node.w || 1, nodeToAdd?.w || 1);\n      ops.disableOneColumnMode = true; // driven by parent\n    }\n    // if we're converting an existing full item, move over the content to be the first sub item in the new grid\n    let content = node.el.querySelector('.grid-stack-item-content');\n    let newItem;\n    let newItemOpt;\n    if (saveContent) {\n      this._removeDD(node.el); // remove D&D since it's set on content div\n      newItemOpt = {\n        ...node,\n        x: 0,\n        y: 0\n      };\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeInternalForSave(newItemOpt);\n      delete newItemOpt.subGridOpts;\n      if (node.content) {\n        newItemOpt.content = node.content;\n        delete node.content;\n      }\n      if (GridStack.addRemoveCB) {\n        newItem = GridStack.addRemoveCB(this.el, newItemOpt, true, false);\n      } else {\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n        doc.body.innerHTML = `<div class=\"grid-stack-item\"></div>`;\n        newItem = doc.body.children[0];\n        newItem.appendChild(content);\n        doc.body.innerHTML = `<div class=\"grid-stack-item-content\"></div>`;\n        content = doc.body.children[0];\n        node.el.appendChild(content);\n      }\n      this._prepareDragDropByNode(node); // ... and restore original D&D\n    }\n    // if we're adding an additional item, make the container large enough to have them both\n    if (nodeToAdd) {\n      let w = autoColumn ? ops.column : node.w;\n      let h = node.h + nodeToAdd.h;\n      let style = node.el.style;\n      style.transition = 'none'; // show up instantly so we don't see scrollbar with nodeToAdd\n      this.update(node.el, {\n        w,\n        h\n      });\n      setTimeout(() => style.transition = null); // recover animation\n    }\n\n    let subGrid = node.subGrid = GridStack.addGrid(content, ops);\n    if (nodeToAdd?._moving) subGrid._isTemp = true; // prevent re-nesting as we add over\n    if (autoColumn) subGrid._autoColumn = true;\n    // add the original content back as a child of hte newly created grid\n    if (saveContent) {\n      subGrid.addWidget(newItem, newItemOpt);\n    }\n    // now add any additional node\n    if (nodeToAdd) {\n      if (nodeToAdd._moving) {\n        // create an artificial event even for the just created grid to receive this item\n        window.setTimeout(() => _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.simulateMouseEvent(nodeToAdd._event, 'mouseenter', subGrid.el), 0);\n      } else {\n        subGrid.addWidget(node.el, node);\n      }\n    }\n    return subGrid;\n  }\n  /**\n   * called when an item was converted into a nested grid to accommodate a dragged over item, but then item leaves - return back\n   * to the original grid-item. Also called to remove empty sub-grids when last item is dragged out (since re-creating is simple)\n   */\n  removeAsSubGrid(nodeThatRemoved) {\n    let pGrid = this.parentGridItem?.grid;\n    if (!pGrid) return;\n    pGrid.batchUpdate();\n    pGrid.removeWidget(this.parentGridItem.el, true, true);\n    this.engine.nodes.forEach(n => {\n      // migrate any children over and offsetting by our location\n      n.x += this.parentGridItem.x;\n      n.y += this.parentGridItem.y;\n      pGrid.addWidget(n.el, n);\n    });\n    pGrid.batchUpdate(false);\n    if (this.parentGridItem) delete this.parentGridItem.subGrid;\n    delete this.parentGridItem;\n    // create an artificial event for the original grid now that this one is gone (got a leave, but won't get enter)\n    if (nodeThatRemoved) {\n      window.setTimeout(() => _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.simulateMouseEvent(nodeThatRemoved._event, 'mouseenter', pGrid.el), 0);\n    }\n  }\n  /**\n   * saves the current layout returning a list of widgets for serialization which might include any nested grids.\n   * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will\n   * be removed.\n   * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()\n   * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.\n   * @param saveCB callback for each node -> widget, so application can insert additional data to be saved into the widget data structure.\n   * @returns list of widgets or full grid option, including .children list of widgets\n   */\n  save(saveContent = true, saveGridOpt = false, saveCB = GridStack.saveCB) {\n    // return copied GridStackWidget (with optionally .el) we can modify at will...\n    let list = this.engine.save(saveContent, saveCB);\n    // check for HTML content and nested grids\n    list.forEach(n => {\n      if (saveContent && n.el && !n.subGrid && !saveCB) {\n        // sub-grid are saved differently, not plain content\n        let sub = n.el.querySelector('.grid-stack-item-content');\n        n.content = sub ? sub.innerHTML : undefined;\n        if (!n.content) delete n.content;\n      } else {\n        if (!saveContent && !saveCB) {\n          delete n.content;\n        }\n        // check for nested grid\n        if (n.subGrid?.el) {\n          const listOrOpt = n.subGrid.save(saveContent, saveGridOpt, saveCB);\n          n.subGridOpts = saveGridOpt ? listOrOpt : {\n            children: listOrOpt\n          };\n          delete n.subGrid;\n        }\n      }\n      delete n.el;\n    });\n    // check if save entire grid options (needed for recursive) + children...\n    if (saveGridOpt) {\n      let o = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(this.opts);\n      // delete default values that will be recreated on launch\n      if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {\n        o.margin = o.marginTop;\n        delete o.marginTop;\n        delete o.marginRight;\n        delete o.marginBottom;\n        delete o.marginLeft;\n      }\n      if (o.rtl === (this.el.style.direction === 'rtl')) {\n        o.rtl = 'auto';\n      }\n      if (this._isAutoCellHeight) {\n        o.cellHeight = 'auto';\n      }\n      if (this._autoColumn) {\n        o.column = 'auto';\n        delete o.disableOneColumnMode;\n      }\n      const origShow = o._alwaysShowResizeHandle;\n      delete o._alwaysShowResizeHandle;\n      if (origShow !== undefined) {\n        o.alwaysShowResizeHandle = origShow;\n      } else {\n        delete o.alwaysShowResizeHandle;\n      }\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeInternalAndSame(o, _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults);\n      o.children = list;\n      return o;\n    }\n    return list;\n  }\n  /**\n   * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.\n   *\n   * @param layout list of widgets definition to update/create\n   * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving\n   * the user control of insertion.\n   *\n   * @example\n   * see http://gridstackjs.com/demo/serialization.html\n   **/\n  load(layout, addRemove = GridStack.addRemoveCB || true) {\n    // if passed list has coordinates, use them (insert from end to beginning for conflict resolution) else force widget same order\n    const haveCoord = layout.some(w => w.x !== undefined || w.y !== undefined);\n    let items = haveCoord ? _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.sort(layout, -1, this._prevColumn || this.getColumn()) : layout;\n    this._insertNotAppend = haveCoord; // if we create in reverse order...\n    // if we're loading a layout into for example 1 column (_prevColumn is set only when going to 1) and items don't fit, make sure to save\n    // the original wanted layout so we can scale back up correctly #1471\n    if (this._prevColumn && this._prevColumn !== this.opts.column && items.some(n => (n.x || 0) + n.w > this.opts.column)) {\n      this._ignoreLayoutsNodeChange = true; // skip layout update\n      this.engine.cacheLayout(items, this._prevColumn, true);\n    }\n    // if given a different callback, temporally set it as global option so creating will use it\n    const prevCB = GridStack.addRemoveCB;\n    if (typeof addRemove === 'function') GridStack.addRemoveCB = addRemove;\n    let removed = [];\n    this.batchUpdate();\n    // see if any items are missing from new layout and need to be removed first\n    if (addRemove) {\n      let copyNodes = [...this.engine.nodes]; // don't loop through array you modify\n      copyNodes.forEach(n => {\n        let item = items.find(w => n.id === w.id);\n        if (!item) {\n          if (GridStack.addRemoveCB) GridStack.addRemoveCB(this.el, n, false, false);\n          removed.push(n); // batch keep track\n          this.removeWidget(n.el, true, false);\n        }\n      });\n    }\n    // now add/update the widgets - starting with an empty list to reduce collision and add no-coord ones at next available spot\n    let copyNodes = this.engine.nodes;\n    this.engine.nodes = [];\n    items.forEach(w => {\n      let item = w.id !== undefined ? copyNodes.find(n => n.id === w.id) : undefined;\n      if (item) {\n        // check if missing coord, in which case find next empty slot with new (or old if missing) sizes\n        if (w.autoPosition || w.x === undefined || w.y === undefined) {\n          w.w = w.w || item.w;\n          w.h = w.h || item.h;\n          this.engine.findEmptyPosition(w);\n        }\n        this.engine.nodes.push(item); // now back to current list...\n        this.update(item.el, w);\n        if (w.subGridOpts?.children) {\n          // update any sub grid as well\n          let sub = item.el.querySelector('.grid-stack');\n          if (sub && sub.gridstack) {\n            sub.gridstack.load(w.subGridOpts.children); // TODO: support updating grid options ?\n            this._insertNotAppend = true; // got reset by above call\n          }\n        }\n      } else if (addRemove) {\n        this.addWidget(w);\n      }\n    });\n    this.engine.removedNodes = removed;\n    this.batchUpdate(false);\n    // after commit, clear that flag\n    delete this._ignoreLayoutsNodeChange;\n    delete this._insertNotAppend;\n    prevCB ? GridStack.addRemoveCB = prevCB : delete GridStack.addRemoveCB;\n    return this;\n  }\n  /**\n   * use before calling a bunch of `addWidget()` to prevent un-necessary relayouts in between (more efficient)\n   * and get a single event callback. You will see no changes until `batchUpdate(false)` is called.\n   */\n  batchUpdate(flag = true) {\n    this.engine.batchUpdate(flag);\n    if (!flag) {\n      this._triggerRemoveEvent();\n      this._triggerAddEvent();\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\n   * Gets current cell height.\n   */\n  getCellHeight(forcePixel = false) {\n    if (this.opts.cellHeight && this.opts.cellHeight !== 'auto' && (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === 'px')) {\n      return this.opts.cellHeight;\n    }\n    // else get first cell height\n    let el = this.el.querySelector('.' + this.opts.itemClass);\n    if (el) {\n      let height = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-h')) || 1; // since we don't write 1 anymore\n      return Math.round(el.offsetHeight / height);\n    }\n    // else do entire grid and # of rows (but doesn't work if min-height is the actual constrain)\n    let rows = parseInt(this.el.getAttribute('gs-current-row'));\n    return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight;\n  }\n  /**\n   * Update current cell height - see `GridStackOptions.cellHeight` for format.\n   * This method rebuilds an internal CSS style sheet.\n   * Note: You can expect performance issues if call this method too often.\n   *\n   * @param val the cell height. If not passed (undefined), cells content will be made square (match width minus margin),\n   * if pass 0 the CSS will be generated by the application instead.\n   * @param update (Optional) if false, styles will not be updated\n   *\n   * @example\n   * grid.cellHeight(100); // same as 100px\n   * grid.cellHeight('70px');\n   * grid.cellHeight(grid.cellWidth() * 1.2);\n   */\n  cellHeight(val, update = true) {\n    // if not called internally, check if we're changing mode\n    if (update && val !== undefined) {\n      if (this._isAutoCellHeight !== (val === 'auto')) {\n        this._isAutoCellHeight = val === 'auto';\n        this._updateWindowResizeEvent();\n      }\n    }\n    if (val === 'initial' || val === 'auto') {\n      val = undefined;\n    }\n    // make item content be square\n    if (val === undefined) {\n      let marginDiff = -this.opts.marginRight - this.opts.marginLeft + this.opts.marginTop + this.opts.marginBottom;\n      val = this.cellWidth() + marginDiff;\n    }\n    let data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(val);\n    if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {\n      return this;\n    }\n    this.opts.cellHeightUnit = data.unit;\n    this.opts.cellHeight = data.h;\n    if (update) {\n      this._updateStyles(true); // true = force re-create for current # of rows\n    }\n\n    return this;\n  }\n  /** Gets current cell width. */\n  cellWidth() {\n    return this._widthOrContainer() / this.getColumn();\n  }\n  /** return our expected width (or parent) for 1 column check */\n  _widthOrContainer() {\n    // use `offsetWidth` or `clientWidth` (no scrollbar) ?\n    // https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively\n    return this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth;\n  }\n  /**\n   * re-layout grid items to reclaim any empty space. Options are:\n   * 'list' keep the widget left->right order the same, even if that means leaving an empty slot if things don't fit\n   * 'compact' might re-order items to fill any empty space\n   *\n   * doSort - 'false' to let you do your own sorting ahead in case you need to control a different order. (default to sort)\n   **/\n  compact(layout = 'compact', doSort = true) {\n    this.engine.compact(layout, doSort);\n    this._triggerChangeEvent();\n    return this;\n  }\n  /**\n   * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,\n   * as well as cache the original layout so you can revert back to previous positions without loss.\n   * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],\n   * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)\n   * @param column - Integer > 0 (default 12).\n   * @param layout specify the type of re-layout that will happen (position, size, etc...).\n   * Note: items will never be outside of the current column boundaries. default ('moveScale'). Ignored for 1 column\n   */\n  column(column, layout = 'moveScale') {\n    if (column < 1 || this.opts.column === column) return this;\n    let oldColumn = this.getColumn();\n    // if we go into 1 column mode (which happens if we're sized less than minW unless disableOneColumnMode is on)\n    // then remember the original columns so we can restore.\n    if (column === 1) {\n      this._prevColumn = oldColumn;\n    } else {\n      delete this._prevColumn;\n    }\n    this.el.classList.remove('gs-' + oldColumn);\n    this.el.classList.add('gs-' + column);\n    this.opts.column = this.engine.column = column;\n    // update the items now - see if the dom order nodes should be passed instead (else default to current list)\n    let domNodes;\n    if (column === 1 && this.opts.oneColumnModeDomSort) {\n      domNodes = [];\n      this.getGridItems().forEach(el => {\n        if (el.gridstackNode) {\n          domNodes.push(el.gridstackNode);\n        }\n      });\n      if (!domNodes.length) {\n        domNodes = undefined;\n      }\n    }\n    this.engine.columnChanged(oldColumn, column, domNodes, layout);\n    if (this._isAutoCellHeight) this.cellHeight();\n    // and trigger our event last...\n    this._ignoreLayoutsNodeChange = true; // skip layout update\n    this._triggerChangeEvent();\n    delete this._ignoreLayoutsNodeChange;\n    return this;\n  }\n  /**\n   * get the number of columns in the grid (default 12)\n   */\n  getColumn() {\n    return this.opts.column;\n  }\n  /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order */\n  getGridItems() {\n    return Array.from(this.el.children).filter(el => el.matches('.' + this.opts.itemClass) && !el.matches('.' + this.opts.placeholderClass));\n  }\n  /**\n   * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.\n   * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).\n   */\n  destroy(removeDOM = true) {\n    if (!this.el) return; // prevent multiple calls\n    this.offAll();\n    this._updateWindowResizeEvent(true);\n    this.setStatic(true, false); // permanently removes DD but don't set CSS class (we're going away)\n    this.setAnimation(false);\n    if (!removeDOM) {\n      this.removeAll(removeDOM);\n      this.el.classList.remove(this._styleSheetClass);\n      this.el.removeAttribute('gs-current-row');\n    } else {\n      this.el.parentNode.removeChild(this.el);\n    }\n    this._removeStylesheet();\n    if (this.parentGridItem) delete this.parentGridItem.subGrid;\n    delete this.parentGridItem;\n    delete this.opts;\n    delete this._placeholder;\n    delete this.engine;\n    delete this.el.gridstack; // remove circular dependency that would prevent a freeing\n    delete this.el;\n    return this;\n  }\n  /**\n   * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)\n   */\n  float(val) {\n    if (this.opts.float !== val) {\n      this.opts.float = this.engine.float = val;\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\n   * get the current float mode\n   */\n  getFloat() {\n    return this.engine.float;\n  }\n  /**\n   * Get the position of the cell under a pixel on screen.\n   * @param position the position of the pixel to resolve in\n   * absolute coordinates, as an object with top and left properties\n   * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).\n   * Useful when grid is within `position: relative` element\n   *\n   * Returns an object with properties `x` and `y` i.e. the column and row in the grid.\n   */\n  getCellFromPixel(position, useDocRelative = false) {\n    let box = this.el.getBoundingClientRect();\n    // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)\n    let containerPos;\n    if (useDocRelative) {\n      containerPos = {\n        top: box.top + document.documentElement.scrollTop,\n        left: box.left\n      };\n      // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)\n    } else {\n      containerPos = {\n        top: this.el.offsetTop,\n        left: this.el.offsetLeft\n      };\n      // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)\n    }\n\n    let relativeLeft = position.left - containerPos.left;\n    let relativeTop = position.top - containerPos.top;\n    let columnWidth = box.width / this.getColumn();\n    let rowHeight = box.height / parseInt(this.el.getAttribute('gs-current-row'));\n    return {\n      x: Math.floor(relativeLeft / columnWidth),\n      y: Math.floor(relativeTop / rowHeight)\n    };\n  }\n  /** returns the current number of rows, which will be at least `minRow` if set */\n  getRow() {\n    return Math.max(this.engine.getRow(), this.opts.minRow);\n  }\n  /**\n   * Checks if specified area is empty.\n   * @param x the position x.\n   * @param y the position y.\n   * @param w the width of to check\n   * @param h the height of to check\n   */\n  isAreaEmpty(x, y, w, h) {\n    return this.engine.isAreaEmpty(x, y, w, h);\n  }\n  /**\n   * If you add elements to your grid by hand (or have some framework creating DOM), you have to tell gridstack afterwards to make them widgets.\n   * If you want gridstack to add the elements for you, use `addWidget()` instead.\n   * Makes the given element a widget and returns it.\n   * @param els widget or single selector to convert.\n   * @param options widget definition to use instead of reading attributes or using default sizing values\n   *\n   * @example\n   * let grid = GridStack.init();\n   * grid.el.appendChild('<div id=\"1\" gs-w=\"3\"></div>');\n   * grid.el.appendChild('<div id=\"2\"></div>');\n   * grid.makeWidget('1');\n   * grid.makeWidget('2', {w:2, content: 'hello'});\n   */\n  makeWidget(els, options) {\n    let el = GridStack.getElement(els);\n    this._prepareElement(el, true, options);\n    this._updateContainerHeight();\n    // see if there is a sub-grid to create\n    const node = el.gridstackNode;\n    if (node.subGridOpts) {\n      this.makeSubGrid(el, node.subGridOpts, undefined, false); // node.subGrid will be used as option in method, no need to pass\n    }\n    // if we're adding an item into 1 column (_prevColumn is set only when going to 1) make sure\n    // we don't override the larger 12 column layout that was already saved. #1985\n    if (this._prevColumn && this.opts.column === 1) {\n      this._ignoreLayoutsNodeChange = true;\n    }\n    this._triggerAddEvent();\n    this._triggerChangeEvent();\n    delete this._ignoreLayoutsNodeChange;\n    return el;\n  }\n  /**\n   * Event handler that extracts our CustomEvent data out automatically for receiving custom\n   * notifications (see doc for supported events)\n   * @param name of the event (see possible values) or list of names space separated\n   * @param callback function called with event and optional second/third param\n   * (see README documentation for each signature).\n   *\n   * @example\n   * grid.on('added', function(e, items) { log('added ', items)} );\n   * or\n   * grid.on('added removed change', function(e, items) { log(e.type, items)} );\n   *\n   * Note: in some cases it is the same as calling native handler and parsing the event.\n   * grid.el.addEventListener('added', function(event) { log('added ', event.detail)} );\n   *\n   */\n  on(name, callback) {\n    // check for array of names being passed instead\n    if (name.indexOf(' ') !== -1) {\n      let names = name.split(' ');\n      names.forEach(name => this.on(name, callback));\n      return this;\n    }\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\n      // native CustomEvent handlers - cash the generic handlers so we can easily remove\n      let noData = name === 'enable' || name === 'disable';\n      if (noData) {\n        this._gsEventHandler[name] = event => callback(event);\n      } else {\n        this._gsEventHandler[name] = event => callback(event, event.detail);\n      }\n      this.el.addEventListener(name, this._gsEventHandler[name]);\n    } else if (name === 'drag' || name === 'dragstart' || name === 'dragstop' || name === 'resizestart' || name === 'resize' || name === 'resizestop' || name === 'dropped') {\n      // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.\n      // do same for start event to make it easier...\n      this._gsEventHandler[name] = callback;\n    } else {\n      console.log('GridStack.on(' + name + ') event not supported, but you can still use $(\".grid-stack\").on(...) while jquery-ui is still used internally.');\n    }\n    return this;\n  }\n  /**\n   * unsubscribe from the 'on' event below\n   * @param name of the event (see possible values)\n   */\n  off(name) {\n    // check for array of names being passed instead\n    if (name.indexOf(' ') !== -1) {\n      let names = name.split(' ');\n      names.forEach(name => this.off(name));\n      return this;\n    }\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\n      // remove native CustomEvent handlers\n      if (this._gsEventHandler[name]) {\n        this.el.removeEventListener(name, this._gsEventHandler[name]);\n      }\n    }\n    delete this._gsEventHandler[name];\n    return this;\n  }\n  /** remove all event handlers */\n  offAll() {\n    Object.keys(this._gsEventHandler).forEach(key => this.off(key));\n    return this;\n  }\n  /**\n   * Removes widget from the grid.\n   * @param el  widget or selector to modify\n   * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).\n   * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\n   */\n  removeWidget(els, removeDOM = true, triggerEvent = true) {\n    GridStack.getElements(els).forEach(el => {\n      if (el.parentElement && el.parentElement !== this.el) return; // not our child!\n      let node = el.gridstackNode;\n      // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272\n      if (!node) {\n        node = this.engine.nodes.find(n => el === n.el);\n      }\n      if (!node) return;\n      if (GridStack.addRemoveCB) {\n        GridStack.addRemoveCB(this.el, node, false, false);\n      }\n      // remove our DOM data (circular link) and drag&drop permanently\n      delete el.gridstackNode;\n      this._removeDD(el);\n      this.engine.removeNode(node, removeDOM, triggerEvent);\n      if (removeDOM && el.parentElement) {\n        el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM\n      }\n    });\n\n    if (triggerEvent) {\n      this._triggerRemoveEvent();\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\n   * Removes all widgets from the grid.\n   * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).\n   */\n  removeAll(removeDOM = true) {\n    // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently\n    this.engine.nodes.forEach(n => {\n      delete n.el.gridstackNode;\n      this._removeDD(n.el);\n    });\n    this.engine.removeAll(removeDOM);\n    this._triggerRemoveEvent();\n    return this;\n  }\n  /**\n   * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.\n   * @param doAnimate if true the grid will animate.\n   */\n  setAnimation(doAnimate) {\n    if (doAnimate) {\n      this.el.classList.add('grid-stack-animate');\n    } else {\n      this.el.classList.remove('grid-stack-animate');\n    }\n    return this;\n  }\n  /**\n   * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.\n   * Also toggle the grid-stack-static class.\n   * @param val if true the grid become static.\n   * @param updateClass true (default) if css class gets updated\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  setStatic(val, updateClass = true, recurse = true) {\n    if (!!this.opts.staticGrid === val) return this;\n    val ? this.opts.staticGrid = true : delete this.opts.staticGrid;\n    this._setupRemoveDrop();\n    this._setupAcceptWidget();\n    this.engine.nodes.forEach(n => {\n      this._prepareDragDropByNode(n); // either delete or init Drag&drop\n      if (n.subGrid && recurse) n.subGrid.setStatic(val, updateClass, recurse);\n    });\n    if (updateClass) {\n      this._setStaticClass();\n    }\n    return this;\n  }\n  /**\n   * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.\n   * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)\n   * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.\n   */\n  update(els, opt) {\n    // support legacy call for now ?\n    if (arguments.length > 2) {\n      console.warn('gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon');\n      // eslint-disable-next-line prefer-rest-params\n      let a = arguments,\n        i = 1;\n      opt = {\n        x: a[i++],\n        y: a[i++],\n        w: a[i++],\n        h: a[i++]\n      };\n      return this.update(els, opt);\n    }\n    GridStack.getElements(els).forEach(el => {\n      let n = el?.gridstackNode;\n      if (!n) return;\n      let w = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(opt); // make a copy we can modify in case they re-use it or multiple items\n      delete w.autoPosition;\n      // move/resize widget if anything changed\n      let keys = ['x', 'y', 'w', 'h'];\n      let m;\n      if (keys.some(k => w[k] !== undefined && w[k] !== n[k])) {\n        m = {};\n        keys.forEach(k => {\n          m[k] = w[k] !== undefined ? w[k] : n[k];\n          delete w[k];\n        });\n      }\n      // for a move as well IFF there is any min/max fields set\n      if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {\n        m = {}; // will use node position but validate values\n      }\n      // check for content changing\n      if (w.content !== undefined) {\n        const itemContent = el.querySelector('.grid-stack-item-content');\n        if (!itemContent || itemContent.innerHTML === w.content) return;\n        itemContent.innerHTML = w.content;\n        // restore any sub-grid back\n        if (n.subGrid?.el) {\n          itemContent.appendChild(n.subGrid.el);\n          if (!n.subGrid.opts.styleInHead) n.subGrid._updateStyles(true); // force create\n        }\n\n        delete w.content;\n      }\n      // any remaining fields are assigned, but check for dragging changes, resize constrain\n      let changed = false;\n      let ddChanged = false;\n      for (const key in w) {\n        if (key[0] !== '_' && n[key] !== w[key]) {\n          n[key] = w[key];\n          changed = true;\n          ddChanged = ddChanged || !this.opts.staticGrid && (key === 'noResize' || key === 'noMove' || key === 'locked');\n        }\n      }\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.sanitizeMinMax(n);\n      // finally move the widget\n      if (m) {\n        this.engine.cleanNodes().beginUpdate(n).moveNode(n, m);\n        this._updateContainerHeight();\n        this._triggerChangeEvent();\n        this.engine.endUpdate();\n      }\n      if (changed) {\n        // move will only update x,y,w,h so update the rest too\n        this._writeAttr(el, n);\n      }\n      if (ddChanged) {\n        this._prepareDragDropByNode(n);\n      }\n    });\n    return this;\n  }\n  /**\n   * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).\n   * @param value margin value\n   */\n  margin(value) {\n    let isMultiValue = typeof value === 'string' && value.split(' ').length > 1;\n    // check if we can skip re-creating our CSS file... won't check if multi values (too much hassle)\n    if (!isMultiValue) {\n      let data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(value);\n      if (this.opts.marginUnit === data.unit && this.opts.margin === data.h) return;\n    }\n    // re-use existing margin handling\n    this.opts.margin = value;\n    this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;\n    this._initMargin();\n    this._updateStyles(true); // true = force re-create\n    return this;\n  }\n  /** returns current margin number value (undefined if 4 sides don't match) */\n  getMargin() {\n    return this.opts.margin;\n  }\n  /**\n   * Returns true if the height of the grid will be less than the vertical\n   * constraint. Always returns true if grid doesn't have height constraint.\n   * @param node contains x,y,w,h,auto-position options\n   *\n   * @example\n   * if (grid.willItFit(newWidget)) {\n   *   grid.addWidget(newWidget);\n   * } else {\n   *   alert('Not enough free space to place the widget');\n   * }\n   */\n  willItFit(node) {\n    // support legacy call for now\n    if (arguments.length > 1) {\n      console.warn('gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon');\n      // eslint-disable-next-line prefer-rest-params\n      let a = arguments,\n        i = 0,\n        w = {\n          x: a[i++],\n          y: a[i++],\n          w: a[i++],\n          h: a[i++],\n          autoPosition: a[i++]\n        };\n      return this.willItFit(w);\n    }\n    return this.engine.willItFit(node);\n  }\n  /** @internal */\n  _triggerChangeEvent() {\n    if (this.engine.batchMode) return this;\n    let elements = this.engine.getDirtyNodes(true); // verify they really changed\n    if (elements && elements.length) {\n      if (!this._ignoreLayoutsNodeChange) {\n        this.engine.layoutsNodesChange(elements);\n      }\n      this._triggerEvent('change', elements);\n    }\n    this.engine.saveInitial(); // we called, now reset initial values & dirty flags\n    return this;\n  }\n  /** @internal */\n  _triggerAddEvent() {\n    if (this.engine.batchMode) return this;\n    if (this.engine.addedNodes?.length) {\n      if (!this._ignoreLayoutsNodeChange) {\n        this.engine.layoutsNodesChange(this.engine.addedNodes);\n      }\n      // prevent added nodes from also triggering 'change' event (which is called next)\n      this.engine.addedNodes.forEach(n => {\n        delete n._dirty;\n      });\n      this._triggerEvent('added', this.engine.addedNodes);\n      this.engine.addedNodes = [];\n    }\n    return this;\n  }\n  /** @internal */\n  _triggerRemoveEvent() {\n    if (this.engine.batchMode) return this;\n    if (this.engine.removedNodes?.length) {\n      this._triggerEvent('removed', this.engine.removedNodes);\n      this.engine.removedNodes = [];\n    }\n    return this;\n  }\n  /** @internal */\n  _triggerEvent(type, data) {\n    let event = data ? new CustomEvent(type, {\n      bubbles: false,\n      detail: data\n    }) : new Event(type);\n    this.el.dispatchEvent(event);\n    return this;\n  }\n  /** @internal called to delete the current dynamic style sheet used for our layout */\n  _removeStylesheet() {\n    if (this._styles) {\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeStylesheet(this._styleSheetClass);\n      delete this._styles;\n    }\n    return this;\n  }\n  /** @internal updated/create the CSS styles for row based layout and initial margin setting */\n  _updateStyles(forceUpdate = false, maxH) {\n    // call to delete existing one if we change cellHeight / margin\n    if (forceUpdate) {\n      this._removeStylesheet();\n    }\n    if (!maxH) maxH = this.getRow();\n    this._updateContainerHeight();\n    // if user is telling us they will handle the CSS themselves by setting heights to 0. Do we need this opts really ??\n    if (this.opts.cellHeight === 0) {\n      return this;\n    }\n    let cellHeight = this.opts.cellHeight;\n    let cellHeightUnit = this.opts.cellHeightUnit;\n    let prefix = `.${this._styleSheetClass} > .${this.opts.itemClass}`;\n    // create one as needed\n    if (!this._styles) {\n      // insert style to parent (instead of 'head' by default) to support WebComponent\n      let styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode;\n      this._styles = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.createStylesheet(this._styleSheetClass, styleLocation, {\n        nonce: this.opts.nonce\n      });\n      if (!this._styles) return this;\n      this._styles._max = 0;\n      // these are done once only\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, prefix, `height: ${cellHeight}${cellHeightUnit}`);\n      // content margins\n      let top = this.opts.marginTop + this.opts.marginUnit;\n      let bottom = this.opts.marginBottom + this.opts.marginUnit;\n      let right = this.opts.marginRight + this.opts.marginUnit;\n      let left = this.opts.marginLeft + this.opts.marginUnit;\n      let content = `${prefix} > .grid-stack-item-content`;\n      let placeholder = `.${this._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\n      // resize handles offset (to match margin)\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);\n    }\n    // now update the height specific fields\n    maxH = maxH || this._styles._max;\n    if (maxH > this._styles._max) {\n      let getHeight = rows => cellHeight * rows + cellHeightUnit;\n      for (let i = this._styles._max + 1; i <= maxH; i++) {\n        // start at 1\n        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix}[gs-y=\"${i}\"]`, `top: ${getHeight(i)}`);\n        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix}[gs-h=\"${i + 1}\"]`, `height: ${getHeight(i + 1)}`); // start at 2\n      }\n\n      this._styles._max = maxH;\n    }\n    return this;\n  }\n  /** @internal */\n  _updateContainerHeight() {\n    if (!this.engine || this.engine.batchMode) return this;\n    let row = this.getRow() + this._extraDragRow; // checks for minRow already\n    // check for css min height\n    // Note: we don't handle %,rem correctly so comment out, beside we don't need need to create un-necessary\n    // rows as the CSS will make us bigger than our set height if needed... not sure why we had this.\n    // let cssMinHeight = parseInt(getComputedStyle(this.el)['min-height']);\n    // if (cssMinHeight > 0) {\n    //   let minRow = Math.round(cssMinHeight / this.getCellHeight(true));\n    //   if (row < minRow) {\n    //     row = minRow;\n    //   }\n    // }\n    this.el.setAttribute('gs-current-row', String(row));\n    if (row === 0) {\n      this.el.style.removeProperty('min-height');\n      return this;\n    }\n    let cellHeight = this.opts.cellHeight;\n    let unit = this.opts.cellHeightUnit;\n    if (!cellHeight) return this;\n    this.el.style.minHeight = row * cellHeight + unit;\n    return this;\n  }\n  /** @internal */\n  _prepareElement(el, triggerAddEvent = false, node) {\n    el.classList.add(this.opts.itemClass);\n    node = node || this._readAttr(el);\n    el.gridstackNode = node;\n    node.el = el;\n    node.grid = this;\n    let copy = {\n      ...node\n    };\n    node = this.engine.addNode(node, triggerAddEvent);\n    // write node attr back in case there was collision or we have to fix bad values during addNode()\n    if (!_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.same(node, copy)) {\n      this._writeAttr(el, node);\n    }\n    this._prepareDragDropByNode(node);\n    return this;\n  }\n  /** @internal call to write position x,y,w,h attributes back to element */\n  _writePosAttr(el, n) {\n    if (n.x !== undefined && n.x !== null) {\n      el.setAttribute('gs-x', String(n.x));\n    }\n    if (n.y !== undefined && n.y !== null) {\n      el.setAttribute('gs-y', String(n.y));\n    }\n    n.w > 1 ? el.setAttribute('gs-w', String(n.w)) : el.removeAttribute('gs-w');\n    n.h > 1 ? el.setAttribute('gs-h', String(n.h)) : el.removeAttribute('gs-h');\n    return this;\n  }\n  /** @internal call to write any default attributes back to element */\n  _writeAttr(el, node) {\n    if (!node) return this;\n    this._writePosAttr(el, node);\n    let attrs /*: GridStackWidget but strings */ = {\n      autoPosition: 'gs-auto-position',\n      noResize: 'gs-no-resize',\n      noMove: 'gs-no-move',\n      locked: 'gs-locked',\n      id: 'gs-id'\n    };\n    for (const key in attrs) {\n      if (node[key]) {\n        // 0 is valid for x,y only but done above already and not in list anyway\n        el.setAttribute(attrs[key], String(node[key]));\n      } else {\n        el.removeAttribute(attrs[key]);\n      }\n    }\n    return this;\n  }\n  /** @internal call to read any default attributes from element */\n  _readAttr(el, clearDefaultAttr = true) {\n    let n = {};\n    n.x = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-x'));\n    n.y = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-y'));\n    n.w = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-w'));\n    n.h = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-h'));\n    n.autoPosition = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-auto-position'));\n    n.noResize = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-no-resize'));\n    n.noMove = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-no-move'));\n    n.locked = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-locked'));\n    n.id = el.getAttribute('gs-id');\n    // read but never written out\n    n.maxW = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-max-w'));\n    n.minW = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-min-w'));\n    n.maxH = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-max-h'));\n    n.minH = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-min-h'));\n    // v8.x optimization to reduce un-needed attr that don't render or are default CSS\n    if (clearDefaultAttr) {\n      if (n.w === 1) el.removeAttribute('gs-w');\n      if (n.h === 1) el.removeAttribute('gs-h');\n      if (n.maxW) el.removeAttribute('gs-max-w');\n      if (n.minW) el.removeAttribute('gs-min-w');\n      if (n.maxH) el.removeAttribute('gs-max-h');\n      if (n.minH) el.removeAttribute('gs-min-h');\n    }\n    // remove any key not found (null or false which is default)\n    for (const key in n) {\n      if (!n.hasOwnProperty(key)) return;\n      if (!n[key] && n[key] !== 0) {\n        // 0 can be valid value (x,y only really)\n        delete n[key];\n      }\n    }\n    return n;\n  }\n  /** @internal */\n  _setStaticClass() {\n    let classes = ['grid-stack-static'];\n    if (this.opts.staticGrid) {\n      this.el.classList.add(...classes);\n      this.el.setAttribute('gs-static', 'true');\n    } else {\n      this.el.classList.remove(...classes);\n      this.el.removeAttribute('gs-static');\n    }\n    return this;\n  }\n  /**\n   * called when we are being resized by the window - check if the one Column Mode needs to be turned on/off\n   * and remember the prev columns we used, or get our count from parent, as well as check for auto cell height (square)\n   */\n  onParentResize() {\n    if (!this.el || !this.el.clientWidth) return; // return if we're gone or no size yet (will get called again)\n    let changedColumn = false;\n    // see if we're nested and take our column count from our parent....\n    if (this._autoColumn && this.parentGridItem) {\n      if (this.opts.column !== this.parentGridItem.w) {\n        changedColumn = true;\n        this.column(this.parentGridItem.w, 'none');\n      }\n    } else {\n      // else check for 1 column in/out behavior\n      let oneColumn = !this.opts.disableOneColumnMode && this.el.clientWidth <= this.opts.oneColumnSize;\n      if (this.opts.column === 1 !== oneColumn) {\n        changedColumn = true;\n        if (this.opts.animate) {\n          this.setAnimation(false);\n        } // 1 <-> 12 is too radical, turn off animation\n        this.column(oneColumn ? 1 : this._prevColumn);\n        if (this.opts.animate) {\n          this.setAnimation(true);\n        }\n      }\n    }\n    // make the cells content square again\n    if (this._isAutoCellHeight) {\n      if (!changedColumn && this.opts.cellHeightThrottle) {\n        if (!this._cellHeightThrottle) {\n          this._cellHeightThrottle = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.throttle(() => this.cellHeight(), this.opts.cellHeightThrottle);\n        }\n        this._cellHeightThrottle();\n      } else {\n        // immediate update if we've changed column count or have no threshold\n        this.cellHeight();\n      }\n    }\n    // finally update any nested grids\n    this.engine.nodes.forEach(n => {\n      if (n.subGrid) n.subGrid.onParentResize();\n    });\n    return this;\n  }\n  /** add or remove the window size event handler */\n  _updateWindowResizeEvent(forceRemove = false) {\n    // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting oneColumn (i.e. doing work)\n    const workTodo = (this._isAutoCellHeight || !this.opts.disableOneColumnMode) && !this.parentGridItem;\n    if (!forceRemove && workTodo && !this._windowResizeBind) {\n      this._windowResizeBind = this.onParentResize.bind(this); // so we can properly remove later\n      window.addEventListener('resize', this._windowResizeBind);\n    } else if ((forceRemove || !workTodo) && this._windowResizeBind) {\n      window.removeEventListener('resize', this._windowResizeBind);\n      delete this._windowResizeBind; // remove link to us so we can free\n    }\n\n    return this;\n  }\n  /** @internal convert a potential selector into actual element */\n  static getElement(els = '.grid-stack-item') {\n    return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElement(els);\n  }\n  /** @internal */\n  static getElements(els = '.grid-stack-item') {\n    return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(els);\n  }\n  /** @internal */\n  static getGridElement(els) {\n    return GridStack.getElement(els);\n  }\n  /** @internal */\n  static getGridElements(els) {\n    return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(els);\n  }\n  /** @internal initialize margin top/bottom/left/right and units */\n  _initMargin() {\n    let data;\n    let margin = 0;\n    // support passing multiple values like CSS (ex: '5px 10px 0 20px')\n    let margins = [];\n    if (typeof this.opts.margin === 'string') {\n      margins = this.opts.margin.split(' ');\n    }\n    if (margins.length === 2) {\n      // top/bot, left/right like CSS\n      this.opts.marginTop = this.opts.marginBottom = margins[0];\n      this.opts.marginLeft = this.opts.marginRight = margins[1];\n    } else if (margins.length === 4) {\n      // Clockwise like CSS\n      this.opts.marginTop = margins[0];\n      this.opts.marginRight = margins[1];\n      this.opts.marginBottom = margins[2];\n      this.opts.marginLeft = margins[3];\n    } else {\n      data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.margin);\n      this.opts.marginUnit = data.unit;\n      margin = this.opts.margin = data.h;\n    }\n    // see if top/bottom/left/right need to be set as well\n    if (this.opts.marginTop === undefined) {\n      this.opts.marginTop = margin;\n    } else {\n      data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginTop);\n      this.opts.marginTop = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginBottom === undefined) {\n      this.opts.marginBottom = margin;\n    } else {\n      data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginBottom);\n      this.opts.marginBottom = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginRight === undefined) {\n      this.opts.marginRight = margin;\n    } else {\n      data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginRight);\n      this.opts.marginRight = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginLeft === undefined) {\n      this.opts.marginLeft = margin;\n    } else {\n      data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginLeft);\n      this.opts.marginLeft = data.h;\n      delete this.opts.margin;\n    }\n    this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...\n    if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {\n      this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()\n    }\n\n    return this;\n  }\n  /* ===========================================================================================\n   * drag&drop methods that used to be stubbed out and implemented in dd-gridstack.ts\n   * but caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\n   * ===========================================================================================\n   */\n  /** get the global (but static to this code) DD implementation */\n  static getDD() {\n    return dd;\n  }\n  /**\n   * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\n   * Called during GridStack.init() as options, but can also be called directly (last param are used) in case the toolbar\n   * is dynamically create and needs to be set later.\n   * @param dragIn string selector (ex: '.sidebar .grid-stack-item') or list of dom elements\n   * @param dragInOptions options - see DDDragInOpt. (default: {handle: '.grid-stack-item-content', appendTo: 'body'}\n   * @param root optional root which defaults to document (for shadow dom pas the parent HTMLDocument)\n   **/\n  static setupDragIn(dragIn, dragInOptions, root = document) {\n    if (dragInOptions?.pause !== undefined) {\n      _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = dragInOptions.pause;\n    }\n    dragInOptions = {\n      ..._types__WEBPACK_IMPORTED_MODULE_2__.dragInDefaultOptions,\n      ...(dragInOptions || {})\n    };\n    let els = typeof dragIn === 'string' ? _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(dragIn, root) : dragIn;\n    if (els.length) els?.forEach(el => {\n      if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\n    });\n  }\n  /**\n   * Enables/Disables dragging by the user of specific grid element. If you want all items, and have it affect future items, use enableMove() instead. No-op for static grids.\n   * IF you are looking to prevent an item from moving (due to being pushed around by another during collision) use locked property instead.\n   * @param els widget or selector to modify.\n   * @param val if true widget will be draggable, assuming the parent grid isn't noMove or static.\n   */\n  movable(els, val) {\n    if (this.opts.staticGrid) return this; // can't move a static grid!\n    GridStack.getElements(els).forEach(el => {\n      let n = el.gridstackNode;\n      if (!n) return;\n      val ? delete n.noMove : n.noMove = true;\n      this._prepareDragDropByNode(n); // init DD if need be, and adjust\n    });\n\n    return this;\n  }\n  /**\n   * Enables/Disables user resizing of specific grid element. If you want all items, and have it affect future items, use enableResize() instead. No-op for static grids.\n   * @param els  widget or selector to modify\n   * @param val  if true widget will be resizable, assuming the parent grid isn't noResize or static.\n   */\n  resizable(els, val) {\n    if (this.opts.staticGrid) return this; // can't resize a static grid!\n    GridStack.getElements(els).forEach(el => {\n      let n = el.gridstackNode;\n      if (!n) return;\n      val ? delete n.noResize : n.noResize = true;\n      this._prepareDragDropByNode(n); // init DD if need be, and adjust\n    });\n\n    return this;\n  }\n  /**\n   * Temporarily disables widgets moving/resizing.\n   * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\n   * Note: no-op for static grid\n   * This is a shortcut for:\n   * @example\n   *  grid.enableMove(false);\n   *  grid.enableResize(false);\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  disable(recurse = true) {\n    if (this.opts.staticGrid) return;\n    this.enableMove(false, recurse);\n    this.enableResize(false, recurse);\n    this._triggerEvent('disable');\n    return this;\n  }\n  /**\n   * Re-enables widgets moving/resizing - see disable().\n   * Note: no-op for static grid.\n   * This is a shortcut for:\n   * @example\n   *  grid.enableMove(true);\n   *  grid.enableResize(true);\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  enable(recurse = true) {\n    if (this.opts.staticGrid) return;\n    this.enableMove(true, recurse);\n    this.enableResize(true, recurse);\n    this._triggerEvent('enable');\n    return this;\n  }\n  /**\n   * Enables/disables widget moving. No-op for static grids, and locally defined items still overrule\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  enableMove(doEnable, recurse = true) {\n    if (this.opts.staticGrid) return this; // can't move a static grid!\n    doEnable ? delete this.opts.disableDrag : this.opts.disableDrag = true; // FIRST before we update children as grid overrides #1658\n    this.engine.nodes.forEach(n => {\n      this._prepareDragDropByNode(n);\n      if (n.subGrid && recurse) n.subGrid.enableMove(doEnable, recurse);\n    });\n    return this;\n  }\n  /**\n   * Enables/disables widget resizing. No-op for static grids.\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  enableResize(doEnable, recurse = true) {\n    if (this.opts.staticGrid) return this; // can't size a static grid!\n    doEnable ? delete this.opts.disableResize : this.opts.disableResize = true; // FIRST before we update children as grid overrides #1658\n    this.engine.nodes.forEach(n => {\n      this._prepareDragDropByNode(n);\n      if (n.subGrid && recurse) n.subGrid.enableResize(doEnable, recurse);\n    });\n    return this;\n  }\n  /** @internal removes any drag&drop present (called during destroy) */\n  _removeDD(el) {\n    dd.draggable(el, 'destroy').resizable(el, 'destroy');\n    if (el.gridstackNode) {\n      delete el.gridstackNode._initDD; // reset our DD init flag\n    }\n\n    delete el.ddElement;\n    return this;\n  }\n  /** @internal called to add drag over to support widgets being added externally */\n  _setupAcceptWidget() {\n    // check if we need to disable things\n    if (this.opts.staticGrid || !this.opts.acceptWidgets && !this.opts.removable) {\n      dd.droppable(this.el, 'destroy');\n      return this;\n    }\n    // vars shared across all methods\n    let cellHeight, cellWidth;\n    let onDrag = (event, el, helper) => {\n      let node = el.gridstackNode;\n      if (!node) return;\n      helper = helper || el;\n      let parent = this.el.getBoundingClientRect();\n      let {\n        top,\n        left\n      } = helper.getBoundingClientRect();\n      left -= parent.left;\n      top -= parent.top;\n      let ui = {\n        position: {\n          top,\n          left\n        }\n      };\n      if (node._temporaryRemoved) {\n        node.x = Math.max(0, Math.round(left / cellWidth));\n        node.y = Math.max(0, Math.round(top / cellHeight));\n        delete node.autoPosition;\n        this.engine.nodeBoundFix(node);\n        // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\n        if (!this.engine.willItFit(node)) {\n          node.autoPosition = true; // ignore x,y and try for any slot...\n          if (!this.engine.willItFit(node)) {\n            dd.off(el, 'drag'); // stop calling us\n            return; // full grid or can't grow\n          }\n\n          if (node._willFitPos) {\n            // use the auto position instead #1687\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, node._willFitPos);\n            delete node._willFitPos;\n          }\n        }\n        // re-use the existing node dragging method\n        this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\n      } else {\n        // re-use the existing node dragging that does so much of the collision detection\n        this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\n      }\n    };\n    dd.droppable(this.el, {\n      accept: el => {\n        let node = el.gridstackNode;\n        // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\n        if (node?.grid === this) return true;\n        if (!this.opts.acceptWidgets) return false;\n        // check for accept method or class matching\n        let canAccept = true;\n        if (typeof this.opts.acceptWidgets === 'function') {\n          canAccept = this.opts.acceptWidgets(el);\n        } else {\n          let selector = this.opts.acceptWidgets === true ? '.grid-stack-item' : this.opts.acceptWidgets;\n          canAccept = el.matches(selector);\n        }\n        // finally check to make sure we actually have space left #1571\n        if (canAccept && node && this.opts.maxRow) {\n          let n = {\n            w: node.w,\n            h: node.h,\n            minW: node.minW,\n            minH: node.minH\n          }; // only width/height matters and autoPosition\n          canAccept = this.engine.willItFit(n);\n        }\n        return canAccept;\n      }\n    })\n    /**\n     * entering our grid area\n     */.on(this.el, 'dropover', (event, el, helper) => {\n      // console.log(`over ${this.el.gridstack.opts.id} ${count++}`); // TEST\n      let node = el.gridstackNode;\n      // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\n      if (node?.grid === this && !node._temporaryRemoved) {\n        // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\n        return false; // prevent parent from receiving msg (which may be a grid as well)\n      }\n      // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\n      if (node?.grid && node.grid !== this && !node._temporaryRemoved) {\n        // console.log('dropover without leave'); // TEST\n        let otherGrid = node.grid;\n        otherGrid._leave(el, helper);\n      }\n      // cache cell dimensions (which don't change), position can animate if we removed an item in otherGrid that affects us...\n      cellWidth = this.cellWidth();\n      cellHeight = this.getCellHeight(true);\n      // load any element attributes if we don't have a node\n      if (!node) {\n        node = this._readAttr(el, false); // don't wipe external (e.g. drag toolbar) attr #2354\n      }\n\n      if (!node.grid) {\n        node._isExternal = true;\n        el.gridstackNode = node;\n      }\n      // calculate the grid size based on element outer size\n      helper = helper || el;\n      let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\n      let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;\n      // if the item came from another grid, make a copy and save the original info in case we go back there\n      if (node.grid && node.grid !== this) {\n        // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\n        // console.log('dropover cloning node'); // TEST\n        if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\n        el.gridstackNode = node = {\n          ...node,\n          w,\n          h,\n          grid: this\n        };\n        this.engine.cleanupNode(node).nodeBoundFix(node);\n        // restore some internal fields we need after clearing them all\n        node._initDD = node._isExternal =\n        // DOM needs to be re-parented on a drop\n        node._temporaryRemoved = true; // so it can be inserted onDrag below\n      } else {\n        node.w = w;\n        node.h = h;\n        node._temporaryRemoved = true; // so we can insert it\n      }\n      // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\n      this._itemRemoving(node.el, false);\n      dd.on(el, 'drag', onDrag);\n      // make sure this is called at least once when going fast #1578\n      onDrag(event, el, helper);\n      return false; // prevent parent from receiving msg (which may be a grid as well)\n    })\n    /**\n     * Leaving our grid area...\n     */.on(this.el, 'dropout', (event, el, helper) => {\n      // console.log(`out ${this.el.gridstack.opts.id} ${count++}`); // TEST\n      let node = el.gridstackNode;\n      if (!node) return false;\n      // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\n      // so skip this one if we're not the active grid really..\n      if (!node.grid || node.grid === this) {\n        this._leave(el, helper);\n        // if we were created as temporary nested grid, go back to before state\n        if (this._isTemp) {\n          this.removeAsSubGrid(node);\n        }\n      }\n      return false; // prevent parent from receiving msg (which may be grid as well)\n    })\n    /**\n     * end - releasing the mouse\n     */.on(this.el, 'drop', (event, el, helper) => {\n      let node = el.gridstackNode;\n      // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\n      if (node?.grid === this && !node._isExternal) return false;\n      let wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\n      this.placeholder.remove();\n      // notify previous grid of removal\n      // console.log('drop delete _gridstackNodeOrig') // TEST\n      let origNode = el._gridstackNodeOrig;\n      delete el._gridstackNodeOrig;\n      if (wasAdded && origNode?.grid && origNode.grid !== this) {\n        let oGrid = origNode.grid;\n        oGrid.engine.removedNodes.push(origNode);\n        oGrid._triggerRemoveEvent()._triggerChangeEvent();\n        // if it's an empty sub-grid that got auto-created, nuke it\n        if (oGrid.parentGridItem && !oGrid.engine.nodes.length && oGrid.opts.subGridDynamic) {\n          oGrid.removeAsSubGrid();\n        }\n      }\n      if (!node) return false;\n      // use existing placeholder node as it's already in our list with drop location\n      if (wasAdded) {\n        this.engine.cleanupNode(node); // removes all internal _xyz values\n        node.grid = this;\n      }\n      dd.off(el, 'drag');\n      // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)\n      // as the helper will be nuked by jquery-ui otherwise. TODO: update old code path\n      if (helper !== el) {\n        helper.remove();\n        el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info\n        if (wasAdded) {\n          el = el.cloneNode(true);\n        }\n      } else {\n        el.remove(); // reduce flicker as we change depth here, and size further down\n        this._removeDD(el);\n      }\n      if (!wasAdded) return false;\n      el.gridstackNode = node;\n      node.el = el;\n      let subGrid = node.subGrid?.el?.gridstack; // set when actual sub-grid present\n      // @ts-ignore\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removePositioningStyles(el); // @ts-ignore\n      this._writeAttr(el, node);\n      el.classList.add(_types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass, this.opts.itemClass);\n      this.el.appendChild(el); // @ts-ignore // TODO: now would be ideal time to _removeHelperStyle() overriding floating styles (native only)\n      if (subGrid) {\n        subGrid.parentGridItem = node;\n        if (!subGrid.opts.styleInHead) subGrid._updateStyles(true); // re-create sub-grid styles now that we've moved\n      }\n\n      this._updateContainerHeight();\n      this.engine.addedNodes.push(node); // @ts-ignore\n      this._triggerAddEvent(); // @ts-ignore\n      this._triggerChangeEvent();\n      this.engine.endUpdate();\n      if (this._gsEventHandler['dropped']) {\n        this._gsEventHandler['dropped']({\n          ...event,\n          type: 'dropped'\n        }, origNode && origNode.grid ? origNode : undefined, node);\n      }\n      // wait till we return out of the drag callback to set the new drag&resize handler or they may get messed up\n      window.setTimeout(() => {\n        // IFF we are still there (some application will use as placeholder and insert their real widget instead and better call makeWidget())\n        if (node.el && node.el.parentElement) {\n          this._prepareDragDropByNode(node);\n        } else {\n          this.engine.removeNode(node);\n        }\n        delete node.grid._isTemp;\n      });\n      return false; // prevent parent from receiving msg (which may be grid as well)\n    });\n\n    return this;\n  }\n  /** @internal mark item for removal */\n  _itemRemoving(el, remove) {\n    let node = el ? el.gridstackNode : undefined;\n    if (!node || !node.grid || el.classList.contains(this.opts.removableOptions.decline)) return;\n    remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\n    remove ? el.classList.add('grid-stack-item-removing') : el.classList.remove('grid-stack-item-removing');\n  }\n  /** @internal called to setup a trash drop zone if the user specifies it */\n  _setupRemoveDrop() {\n    if (!this.opts.staticGrid && typeof this.opts.removable === 'string') {\n      let trashEl = document.querySelector(this.opts.removable);\n      if (!trashEl) return this;\n      // only register ONE drop-over/dropout callback for the 'trash', and it will\n      // update the passed in item and parent grid because the 'trash' is a shared resource anyway,\n      // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\n      if (!dd.isDroppable(trashEl)) {\n        dd.droppable(trashEl, this.opts.removableOptions).on(trashEl, 'dropover', (event, el) => this._itemRemoving(el, true)).on(trashEl, 'dropout', (event, el) => this._itemRemoving(el, false));\n      }\n    }\n    return this;\n  }\n  /** @internal prepares the element for drag&drop **/\n  _prepareDragDropByNode(node) {\n    let el = node.el;\n    const noMove = node.noMove || this.opts.disableDrag;\n    const noResize = node.noResize || this.opts.disableResize;\n    // check for disabled grid first\n    if (this.opts.staticGrid || noMove && noResize) {\n      if (node._initDD) {\n        this._removeDD(el); // nukes everything instead of just disable, will add some styles back next\n        delete node._initDD;\n      }\n      el.classList.add('ui-draggable-disabled', 'ui-resizable-disabled'); // add styles one might depend on #1435\n      return this;\n    }\n    if (!node._initDD) {\n      // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\n      let cellWidth;\n      let cellHeight;\n      /** called when item starts moving/resizing */\n      let onStartMoving = (event, ui) => {\n        // trigger any 'dragstart' / 'resizestart' manually\n        if (this._gsEventHandler[event.type]) {\n          this._gsEventHandler[event.type](event, event.target);\n        }\n        cellWidth = this.cellWidth();\n        cellHeight = this.getCellHeight(true); // force pixels for calculations\n        this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\n      };\n      /** called when item is being dragged/resized */\n      let dragOrResize = (event, ui) => {\n        this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\n      };\n      /** called when the item stops moving/resizing */\n      let onEndMoving = event => {\n        this.placeholder.remove();\n        delete node._moving;\n        delete node._event;\n        delete node._lastTried;\n        // if the item has moved to another grid, we're done here\n        let target = event.target;\n        if (!target.gridstackNode || target.gridstackNode.grid !== this) return;\n        node.el = target;\n        if (node._isAboutToRemove) {\n          let grid = el.gridstackNode.grid;\n          if (grid._gsEventHandler[event.type]) {\n            grid._gsEventHandler[event.type](event, target);\n          }\n          grid.engine.nodes.push(node); // temp add it back so we can proper remove it next\n          grid.removeWidget(el, true, true);\n        } else {\n          _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removePositioningStyles(target);\n          if (node._temporaryRemoved) {\n            // got removed - restore item back to before dragging position\n            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, node._orig); // @ts-ignore\n            this._writePosAttr(target, node);\n            this.engine.addNode(node);\n          } else {\n            // move to new placeholder location\n            this._writePosAttr(target, node);\n          }\n          if (this._gsEventHandler[event.type]) {\n            this._gsEventHandler[event.type](event, target);\n          }\n        }\n        // @ts-ignore\n        this._extraDragRow = 0; // @ts-ignore\n        this._updateContainerHeight(); // @ts-ignore\n        this._triggerChangeEvent();\n        this.engine.endUpdate();\n      };\n      dd.draggable(el, {\n        start: onStartMoving,\n        stop: onEndMoving,\n        drag: dragOrResize\n      }).resizable(el, {\n        start: onStartMoving,\n        stop: onEndMoving,\n        resize: dragOrResize\n      });\n      node._initDD = true; // we've set DD support now\n    }\n    // finally fine tune move vs resize by disabling any part...\n    dd.draggable(el, noMove ? 'disable' : 'enable').resizable(el, noResize ? 'disable' : 'enable');\n    return this;\n  }\n  /** @internal handles actual drag/resize start **/\n  _onStartMoving(el, event, ui, node, cellWidth, cellHeight) {\n    this.engine.cleanNodes().beginUpdate(node);\n    // @ts-ignore\n    this._writePosAttr(this.placeholder, node);\n    this.el.appendChild(this.placeholder);\n    // console.log('_onStartMoving placeholder') // TEST\n    node.el = this.placeholder;\n    node._lastUiPosition = ui.position;\n    node._prevYPix = ui.position.top;\n    node._moving = event.type === 'dragstart'; // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\n    delete node._lastTried;\n    if (event.type === 'dropover' && node._temporaryRemoved) {\n      // console.log('engine.addNode x=' + node.x); // TEST\n      this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\n      node._moving = true; // AFTER, mark as moving object (wanted fix location before)\n    }\n    // set the min/max resize info\n    this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop, this.opts.marginRight, this.opts.marginBottom, this.opts.marginLeft);\n    if (event.type === 'resizestart') {\n      dd.resizable(el, 'option', 'minWidth', cellWidth * (node.minW || 1)).resizable(el, 'option', 'minHeight', cellHeight * (node.minH || 1));\n      if (node.maxW) {\n        dd.resizable(el, 'option', 'maxWidth', cellWidth * node.maxW);\n      }\n      if (node.maxH) {\n        dd.resizable(el, 'option', 'maxHeight', cellHeight * node.maxH);\n      }\n    }\n  }\n  /** @internal handles actual drag/resize **/\n  _dragOrResize(el, event, ui, node, cellWidth, cellHeight) {\n    let p = {\n      ...node._orig\n    }; // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\n    let resizing;\n    let mLeft = this.opts.marginLeft,\n      mRight = this.opts.marginRight,\n      mTop = this.opts.marginTop,\n      mBottom = this.opts.marginBottom;\n    // if margins (which are used to pass mid point by) are large relative to cell height/width, reduce them down #1855\n    let mHeight = Math.round(cellHeight * 0.1),\n      mWidth = Math.round(cellWidth * 0.1);\n    mLeft = Math.min(mLeft, mWidth);\n    mRight = Math.min(mRight, mWidth);\n    mTop = Math.min(mTop, mHeight);\n    mBottom = Math.min(mBottom, mHeight);\n    if (event.type === 'drag') {\n      if (node._temporaryRemoved) return; // handled by dropover\n      let distance = ui.position.top - node._prevYPix;\n      node._prevYPix = ui.position.top;\n      if (this.opts.draggable.scroll !== false) {\n        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.updateScrollPosition(el, ui.position, distance);\n      }\n      // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\n      let left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);\n      let top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);\n      p.x = Math.round(left / cellWidth);\n      p.y = Math.round(top / cellHeight);\n      // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\n      let prev = this._extraDragRow;\n      if (this.engine.collide(node, p)) {\n        let row = this.getRow();\n        let extra = Math.max(0, p.y + node.h - row);\n        if (this.opts.maxRow && row + extra > this.opts.maxRow) {\n          extra = Math.max(0, this.opts.maxRow - row);\n        } // @ts-ignore\n        this._extraDragRow = extra; // @ts-ignore\n      } else this._extraDragRow = 0; // @ts-ignore\n      if (this._extraDragRow !== prev) this._updateContainerHeight();\n      if (node.x === p.x && node.y === p.y) return; // skip same\n      // DON'T skip one we tried as we might have failed because of coverage <50% before\n      // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\n    } else if (event.type === 'resize') {\n      if (p.x < 0) return;\n      // Scrolling page if needed\n      _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.updateScrollResize(event, el, cellHeight);\n      // get new size\n      p.w = Math.round((ui.size.width - mLeft) / cellWidth);\n      p.h = Math.round((ui.size.height - mTop) / cellHeight);\n      if (node.w === p.w && node.h === p.h) return;\n      if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\n      // if we size on left/top side this might move us, so get possible new position as well\n      let left = ui.position.left + mLeft;\n      let top = ui.position.top + mTop;\n      p.x = Math.round(left / cellWidth);\n      p.y = Math.round(top / cellHeight);\n      resizing = true;\n    }\n    node._event = event;\n    node._lastTried = p; // set as last tried (will nuke if we go there)\n    let rect = {\n      x: ui.position.left + mLeft,\n      y: ui.position.top + mTop,\n      w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\n      h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\n    };\n    if (this.engine.moveNodeCheck(node, {\n      ...p,\n      cellWidth,\n      cellHeight,\n      rect,\n      resizing\n    })) {\n      node._lastUiPosition = ui.position;\n      this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\n      delete node._skipDown;\n      if (resizing && node.subGrid) node.subGrid.onParentResize();\n      this._extraDragRow = 0; // @ts-ignore\n      this._updateContainerHeight();\n      let target = event.target; // @ts-ignore\n      this._writePosAttr(target, node);\n      if (this._gsEventHandler[event.type]) {\n        this._gsEventHandler[event.type](event, target);\n      }\n    }\n  }\n  /** @internal called when item leaving our area by either cursor dropout event\n   * or shape is outside our boundaries. remove it from us, and mark temporary if this was\n   * our item to start with else restore prev node values from prev grid it came from.\n   **/\n  _leave(el, helper) {\n    let node = el.gridstackNode;\n    if (!node) return;\n    dd.off(el, 'drag'); // no need to track while being outside\n    // this gets called when cursor leaves and shape is outside, so only do this once\n    if (node._temporaryRemoved) return;\n    node._temporaryRemoved = true;\n    this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\n    node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\n    if (this.opts.removable === true) {\n      // boolean vs a class string\n      // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\n      this._itemRemoving(el, true);\n    }\n    // finally if item originally came from another grid, but left us, restore things back to prev info\n    if (el._gridstackNodeOrig) {\n      // console.log('leave delete _gridstackNodeOrig') // TEST\n      el.gridstackNode = el._gridstackNodeOrig;\n      delete el._gridstackNodeOrig;\n    } else if (node._isExternal) {\n      // item came from outside (like a toolbar) so nuke any node info\n      delete node.el;\n      delete el.gridstackNode;\n      // and restore all nodes back to original\n      this.engine.restoreInitial();\n    }\n  }\n  // legacy method removed\n  commit() {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.obsolete)(this, this.batchUpdate(false), 'commit', 'batchUpdate', '5.2');\n    return this;\n  }\n}\n/** scoping so users can call GridStack.Utils.sort() for example */\nGridStack.Utils = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils;\n/** scoping so users can call new GridStack.Engine(12) for example */\nGridStack.Engine = _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine;\nGridStack.GDRev = '8.4.0';\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/gridstack.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/types.js":
/*!**********************************************!*\
  !*** ./node_modules/gridstack/dist/types.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dragInDefaultOptions: () => (/* binding */ dragInDefaultOptions),\n/* harmony export */   gridDefaults: () => (/* binding */ gridDefaults)\n/* harmony export */ });\n/**\n * types.ts 8.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */\n// default values for grid options - used during init and when saving out\nconst gridDefaults = {\n  alwaysShowResizeHandle: 'mobile',\n  animate: true,\n  auto: true,\n  cellHeight: 'auto',\n  cellHeightThrottle: 100,\n  cellHeightUnit: 'px',\n  column: 12,\n  draggable: {\n    handle: '.grid-stack-item-content',\n    appendTo: 'body',\n    scroll: true\n  },\n  handle: '.grid-stack-item-content',\n  itemClass: 'grid-stack-item',\n  margin: 10,\n  marginUnit: 'px',\n  maxRow: 0,\n  minRow: 0,\n  oneColumnSize: 768,\n  placeholderClass: 'grid-stack-placeholder',\n  placeholderText: '',\n  removableOptions: {\n    accept: 'grid-stack-item',\n    decline: 'grid-stack-non-removable'\n  },\n  resizable: {\n    handles: 'se'\n  },\n  rtl: 'auto'\n  // **** same as not being set ****\n  // disableDrag: false,\n  // disableOneColumnMode: false,\n  // disableResize: false,\n  // float: false,\n  // handleClass: null,\n  // oneColumnModeDomSort: false,\n  // removable: false,\n  // staticGrid: false,\n  // styleInHead: false,\n  //removable\n};\n/** default dragIn options */\nconst dragInDefaultOptions = {\n  handle: '.grid-stack-item-content',\n  appendTo: 'body'\n  // revert: 'invalid',\n  // scroll: false,\n};\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/types.js?");

/***/ }),

/***/ "./node_modules/gridstack/dist/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/gridstack/dist/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utils: () => (/* binding */ Utils),\n/* harmony export */   obsolete: () => (/* binding */ obsolete),\n/* harmony export */   obsoleteAttr: () => (/* binding */ obsoleteAttr),\n/* harmony export */   obsoleteOpts: () => (/* binding */ obsoleteOpts),\n/* harmony export */   obsoleteOptsDel: () => (/* binding */ obsoleteOptsDel)\n/* harmony export */ });\n/**\n * utils.ts 8.4.0\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */\n/** checks for obsolete method names */\n// eslint-disable-next-line\nfunction obsolete(self, f, oldName, newName, rev) {\n  let wrapper = (...args) => {\n    console.warn('gridstack.js: Function `' + oldName + '` is deprecated in ' + rev + ' and has been replaced ' + 'with `' + newName + '`. It will be **removed** in a future release');\n    return f.apply(self, args);\n  };\n  wrapper.prototype = f.prototype;\n  return wrapper;\n}\n/** checks for obsolete grid options (can be used for any fields, but msg is about options) */\nfunction obsoleteOpts(opts, oldName, newName, rev) {\n  if (opts[oldName] !== undefined) {\n    opts[newName] = opts[oldName];\n    console.warn('gridstack.js: Option `' + oldName + '` is deprecated in ' + rev + ' and has been replaced with `' + newName + '`. It will be **removed** in a future release');\n  }\n}\n/** checks for obsolete grid options which are gone */\nfunction obsoleteOptsDel(opts, oldName, rev, info) {\n  if (opts[oldName] !== undefined) {\n    console.warn('gridstack.js: Option `' + oldName + '` is deprecated in ' + rev + info);\n  }\n}\n/** checks for obsolete Jquery element attributes */\nfunction obsoleteAttr(el, oldName, newName, rev) {\n  let oldAttr = el.getAttribute(oldName);\n  if (oldAttr !== null) {\n    el.setAttribute(newName, oldAttr);\n    console.warn('gridstack.js: attribute `' + oldName + '`=' + oldAttr + ' is deprecated on this object in ' + rev + ' and has been replaced with `' + newName + '`. It will be **removed** in a future release');\n  }\n}\n/**\n * Utility methods\n */\nclass Utils {\n  /** convert a potential selector into actual list of html elements. optional root which defaults to document (for shadow dom) */\n  static getElements(els, root = document) {\n    if (typeof els === 'string') {\n      const doc = 'getElementById' in root ? root : undefined;\n      // Note: very common for people use to id='1,2,3' which is only legal as HTML5 id, but not CSS selectors\n      // so if we start with a number, assume it's an id and just return that one item...\n      // see https://github.com/gridstack/gridstack.js/issues/2234#issuecomment-1523796562\n      if (doc && !isNaN(+els[0])) {\n        // start with digit\n        const el = doc.getElementById(els);\n        return el ? [el] : [];\n      }\n      let list = root.querySelectorAll(els);\n      if (!list.length && els[0] !== '.' && els[0] !== '#') {\n        list = root.querySelectorAll('.' + els);\n        if (!list.length) {\n          list = root.querySelectorAll('#' + els);\n        }\n      }\n      return Array.from(list);\n    }\n    return [els];\n  }\n  /** convert a potential selector into actual single element. optional root which defaults to document (for shadow dom) */\n  static getElement(els, root = document) {\n    if (typeof els === 'string') {\n      const doc = 'getElementById' in root ? root : undefined;\n      if (!els.length) return null;\n      if (doc && els[0] === '#') {\n        return doc.getElementById(els.substring(1));\n      }\n      if (els[0] === '#' || els[0] === '.' || els[0] === '[') {\n        return root.querySelector(els);\n      }\n      // if we start with a digit, assume it's an id (error calling querySelector('#1')) as class are not valid CSS\n      if (doc && !isNaN(+els[0])) {\n        // start with digit\n        return doc.getElementById(els);\n      }\n      // finally try string, then id, then class\n      let el = root.querySelector(els);\n      if (doc && !el) {\n        el = doc.getElementById(els);\n      }\n      if (!el) {\n        el = root.querySelector('.' + els);\n      }\n      return el;\n    }\n    return els;\n  }\n  /** returns true if a and b overlap */\n  static isIntercepted(a, b) {\n    return !(a.y >= b.y + b.h || a.y + a.h <= b.y || a.x + a.w <= b.x || a.x >= b.x + b.w);\n  }\n  /** returns true if a and b touch edges or corners */\n  static isTouching(a, b) {\n    return Utils.isIntercepted(a, {\n      x: b.x - 0.5,\n      y: b.y - 0.5,\n      w: b.w + 1,\n      h: b.h + 1\n    });\n  }\n  /** returns the area a and b overlap */\n  static areaIntercept(a, b) {\n    let x0 = a.x > b.x ? a.x : b.x;\n    let x1 = a.x + a.w < b.x + b.w ? a.x + a.w : b.x + b.w;\n    if (x1 <= x0) return 0; // no overlap\n    let y0 = a.y > b.y ? a.y : b.y;\n    let y1 = a.y + a.h < b.y + b.h ? a.y + a.h : b.y + b.h;\n    if (y1 <= y0) return 0; // no overlap\n    return (x1 - x0) * (y1 - y0);\n  }\n  /** returns the area */\n  static area(a) {\n    return a.w * a.h;\n  }\n  /**\n   * Sorts array of nodes\n   * @param nodes array to sort\n   * @param dir 1 for asc, -1 for desc (optional)\n   * @param width width of the grid. If undefined the width will be calculated automatically (optional).\n   **/\n  static sort(nodes, dir = 1, column) {\n    column = column || nodes.reduce((col, n) => Math.max(n.x + n.w, col), 0) || 12;\n    if (dir === -1) return nodes.sort((a, b) => (b.x ?? 1000) + (b.y ?? 1000) * column - ((a.x ?? 1000) + (a.y ?? 1000) * column));else return nodes.sort((b, a) => (b.x ?? 1000) + (b.y ?? 1000) * column - ((a.x ?? 1000) + (a.y ?? 1000) * column));\n  }\n  /**\n   * creates a style sheet with style id under given parent\n   * @param id will set the 'gs-style-id' attribute to that id\n   * @param parent to insert the stylesheet as first child,\n   * if none supplied it will be appended to the document head instead.\n   */\n  static createStylesheet(id, parent, options) {\n    let style = document.createElement('style');\n    const nonce = options?.nonce;\n    if (nonce) style.nonce = nonce;\n    style.setAttribute('type', 'text/css');\n    style.setAttribute('gs-style-id', id);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (style.styleSheet) {\n      // TODO: only CSSImportRule have that and different beast ??\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      style.styleSheet.cssText = '';\n    } else {\n      style.appendChild(document.createTextNode('')); // WebKit hack\n    }\n\n    if (!parent) {\n      // default to head\n      parent = document.getElementsByTagName('head')[0];\n      parent.appendChild(style);\n    } else {\n      parent.insertBefore(style, parent.firstChild);\n    }\n    return style.sheet;\n  }\n  /** removed the given stylesheet id */\n  static removeStylesheet(id) {\n    let el = document.querySelector('STYLE[gs-style-id=' + id + ']');\n    if (el && el.parentNode) el.remove();\n  }\n  /** inserts a CSS rule */\n  static addCSSRule(sheet, selector, rules) {\n    if (typeof sheet.addRule === 'function') {\n      sheet.addRule(selector, rules);\n    } else if (typeof sheet.insertRule === 'function') {\n      sheet.insertRule(`${selector}{${rules}}`);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static toBool(v) {\n    if (typeof v === 'boolean') {\n      return v;\n    }\n    if (typeof v === 'string') {\n      v = v.toLowerCase();\n      return !(v === '' || v === 'no' || v === 'false' || v === '0');\n    }\n    return Boolean(v);\n  }\n  static toNumber(value) {\n    return value === null || value.length === 0 ? undefined : Number(value);\n  }\n  static parseHeight(val) {\n    let h;\n    let unit = 'px';\n    if (typeof val === 'string') {\n      let match = val.match(/^(-[0-9]+\\.[0-9]+|[0-9]*\\.[0-9]+|-[0-9]+|[0-9]+)(px|em|rem|vh|vw|%)?$/);\n      if (!match) {\n        throw new Error('Invalid height');\n      }\n      unit = match[2] || 'px';\n      h = parseFloat(match[1]);\n    } else {\n      h = val;\n    }\n    return {\n      h,\n      unit\n    };\n  }\n  /** copies unset fields in target to use the given default sources values */\n  // eslint-disable-next-line\n  static defaults(target, ...sources) {\n    sources.forEach(source => {\n      for (const key in source) {\n        if (!source.hasOwnProperty(key)) return;\n        if (target[key] === null || target[key] === undefined) {\n          target[key] = source[key];\n        } else if (typeof source[key] === 'object' && typeof target[key] === 'object') {\n          // property is an object, recursively add it's field over... #1373\n          this.defaults(target[key], source[key]);\n        }\n      }\n    });\n    return target;\n  }\n  /** given 2 objects return true if they have the same values. Checks for Object {} having same fields and values (just 1 level down) */\n  static same(a, b) {\n    if (typeof a !== 'object') return a == b;\n    if (typeof a !== typeof b) return false;\n    // else we have object, check just 1 level deep for being same things...\n    if (Object.keys(a).length !== Object.keys(b).length) return false;\n    for (const key in a) {\n      if (a[key] !== b[key]) return false;\n    }\n    return true;\n  }\n  /** copies over b size & position (GridStackPosition), and optionally min/max as well */\n  static copyPos(a, b, doMinMax = false) {\n    if (b.x !== undefined) a.x = b.x;\n    if (b.y !== undefined) a.y = b.y;\n    if (b.w !== undefined) a.w = b.w;\n    if (b.h !== undefined) a.h = b.h;\n    if (doMinMax) {\n      if (b.minW) a.minW = b.minW;\n      if (b.minH) a.minH = b.minH;\n      if (b.maxW) a.maxW = b.maxW;\n      if (b.maxH) a.maxH = b.maxH;\n    }\n    return a;\n  }\n  /** true if a and b has same size & position */\n  static samePos(a, b) {\n    return a && b && a.x === b.x && a.y === b.y && a.w === b.w && a.h === b.h;\n  }\n  /** given a node, makes sure it's min/max are valid */\n  static sanitizeMinMax(node) {\n    // remove 0, undefine, null\n    if (!node.minW) {\n      delete node.minW;\n    }\n    if (!node.minH) {\n      delete node.minH;\n    }\n    if (!node.maxW) {\n      delete node.maxW;\n    }\n    if (!node.maxH) {\n      delete node.maxH;\n    }\n  }\n  /** removes field from the first object if same as the second objects (like diffing) and internal '_' for saving */\n  static removeInternalAndSame(a, b) {\n    if (typeof a !== 'object' || typeof b !== 'object') return;\n    for (let key in a) {\n      let val = a[key];\n      if (key[0] === '_' || val === b[key]) {\n        delete a[key];\n      } else if (val && typeof val === 'object' && b[key] !== undefined) {\n        for (let i in val) {\n          if (val[i] === b[key][i] || i[0] === '_') {\n            delete val[i];\n          }\n        }\n        if (!Object.keys(val).length) {\n          delete a[key];\n        }\n      }\n    }\n  }\n  /** removes internal fields '_' and default values for saving */\n  static removeInternalForSave(n, removeEl = true) {\n    for (let key in n) {\n      if (key[0] === '_' || n[key] === null || n[key] === undefined) delete n[key];\n    }\n    delete n.grid;\n    if (removeEl) delete n.el;\n    // delete default values (will be re-created on read)\n    if (!n.autoPosition) delete n.autoPosition;\n    if (!n.noResize) delete n.noResize;\n    if (!n.noMove) delete n.noMove;\n    if (!n.locked) delete n.locked;\n    if (n.w === 1 || n.w === n.minW) delete n.w;\n    if (n.h === 1 || n.h === n.minH) delete n.h;\n  }\n  /** return the closest parent (or itself) matching the given class */\n  static closestUpByClass(el, name) {\n    while (el) {\n      if (el.classList.contains(name)) return el;\n      el = el.parentElement;\n    }\n    return null;\n  }\n  /** delay calling the given function for given delay, preventing new calls from happening while waiting */\n  static throttle(func, delay) {\n    let isWaiting = false;\n    return (...args) => {\n      if (!isWaiting) {\n        isWaiting = true;\n        setTimeout(() => {\n          func(...args);\n          isWaiting = false;\n        }, delay);\n      }\n    };\n  }\n  static removePositioningStyles(el) {\n    let style = el.style;\n    if (style.position) {\n      style.removeProperty('position');\n    }\n    if (style.left) {\n      style.removeProperty('left');\n    }\n    if (style.top) {\n      style.removeProperty('top');\n    }\n    if (style.width) {\n      style.removeProperty('width');\n    }\n    if (style.height) {\n      style.removeProperty('height');\n    }\n  }\n  /** @internal returns the passed element if scrollable, else the closest parent that will, up to the entire document scrolling element */\n  static getScrollElement(el) {\n    if (!el) return document.scrollingElement || document.documentElement; // IE support\n    const style = getComputedStyle(el);\n    const overflowRegex = /(auto|scroll)/;\n    if (overflowRegex.test(style.overflow + style.overflowY)) {\n      return el;\n    } else {\n      return this.getScrollElement(el.parentElement);\n    }\n  }\n  /** @internal */\n  static updateScrollPosition(el, position, distance) {\n    // is widget in view?\n    let rect = el.getBoundingClientRect();\n    let innerHeightOrClientHeight = window.innerHeight || document.documentElement.clientHeight;\n    if (rect.top < 0 || rect.bottom > innerHeightOrClientHeight) {\n      // set scrollTop of first parent that scrolls\n      // if parent is larger than el, set as low as possible\n      // to get entire widget on screen\n      let offsetDiffDown = rect.bottom - innerHeightOrClientHeight;\n      let offsetDiffUp = rect.top;\n      let scrollEl = this.getScrollElement(el);\n      if (scrollEl !== null) {\n        let prevScroll = scrollEl.scrollTop;\n        if (rect.top < 0 && distance < 0) {\n          // moving up\n          if (el.offsetHeight > innerHeightOrClientHeight) {\n            scrollEl.scrollTop += distance;\n          } else {\n            scrollEl.scrollTop += Math.abs(offsetDiffUp) > Math.abs(distance) ? distance : offsetDiffUp;\n          }\n        } else if (distance > 0) {\n          // moving down\n          if (el.offsetHeight > innerHeightOrClientHeight) {\n            scrollEl.scrollTop += distance;\n          } else {\n            scrollEl.scrollTop += offsetDiffDown > distance ? distance : offsetDiffDown;\n          }\n        }\n        // move widget y by amount scrolled\n        position.top += scrollEl.scrollTop - prevScroll;\n      }\n    }\n  }\n  /**\n   * @internal Function used to scroll the page.\n   *\n   * @param event `MouseEvent` that triggers the resize\n   * @param el `HTMLElement` that's being resized\n   * @param distance Distance from the V edges to start scrolling\n   */\n  static updateScrollResize(event, el, distance) {\n    const scrollEl = this.getScrollElement(el);\n    const height = scrollEl.clientHeight;\n    // #1727 event.clientY is relative to viewport, so must compare this against position of scrollEl getBoundingClientRect().top\n    // #1745 Special situation if scrollEl is document 'html': here browser spec states that\n    // clientHeight is height of viewport, but getBoundingClientRect() is rectangle of html element;\n    // this discrepancy arises because in reality scrollbar is attached to viewport, not html element itself.\n    const offsetTop = scrollEl === this.getScrollElement() ? 0 : scrollEl.getBoundingClientRect().top;\n    const pointerPosY = event.clientY - offsetTop;\n    const top = pointerPosY < distance;\n    const bottom = pointerPosY > height - distance;\n    if (top) {\n      // This also can be done with a timeout to keep scrolling while the mouse is\n      // in the scrolling zone. (will have smoother behavior)\n      scrollEl.scrollBy({\n        behavior: 'smooth',\n        top: pointerPosY - distance\n      });\n    } else if (bottom) {\n      scrollEl.scrollBy({\n        behavior: 'smooth',\n        top: distance - (height - pointerPosY)\n      });\n    }\n  }\n  /** single level clone, returning a new object with same top fields. This will share sub objects and arrays */\n  static clone(obj) {\n    if (obj === null || obj === undefined || typeof obj !== 'object') {\n      return obj;\n    }\n    // return Object.assign({}, obj);\n    if (obj instanceof Array) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return [...obj];\n    }\n    return {\n      ...obj\n    };\n  }\n  /**\n   * Recursive clone version that returns a full copy, checking for nested objects and arrays ONLY.\n   * Note: this will use as-is any key starting with double __ (and not copy inside) some lib have circular dependencies.\n   */\n  static cloneDeep(obj) {\n    // list of fields we will skip during cloneDeep (nested objects, other internal)\n    const skipFields = ['parentGrid', 'el', 'grid', 'subGrid', 'engine'];\n    // return JSON.parse(JSON.stringify(obj)); // doesn't work with date format ?\n    const ret = Utils.clone(obj);\n    for (const key in ret) {\n      // NOTE: we don't support function/circular dependencies so skip those properties for now...\n      if (ret.hasOwnProperty(key) && typeof ret[key] === 'object' && key.substring(0, 2) !== '__' && !skipFields.find(k => k === key)) {\n        ret[key] = Utils.cloneDeep(obj[key]);\n      }\n    }\n    return ret;\n  }\n  /** deep clone the given HTML node, removing teh unique id field */\n  static cloneNode(el) {\n    const node = el.cloneNode(true);\n    node.removeAttribute('id');\n    return node;\n  }\n  static appendTo(el, parent) {\n    let parentNode;\n    if (typeof parent === 'string') {\n      parentNode = Utils.getElement(parent);\n    } else {\n      parentNode = parent;\n    }\n    if (parentNode) {\n      parentNode.appendChild(el);\n    }\n  }\n  // public static setPositionRelative(el: HTMLElement): void {\n  //   if (!(/^(?:r|a|f)/).test(window.getComputedStyle(el).position)) {\n  //     el.style.position = \"relative\";\n  //   }\n  // }\n  static addElStyles(el, styles) {\n    if (styles instanceof Object) {\n      for (const s in styles) {\n        if (styles.hasOwnProperty(s)) {\n          if (Array.isArray(styles[s])) {\n            // support fallback value\n            styles[s].forEach(val => {\n              el.style[s] = val;\n            });\n          } else {\n            el.style[s] = styles[s];\n          }\n        }\n      }\n    }\n  }\n  static initEvent(e, info) {\n    const evt = {\n      type: info.type\n    };\n    const obj = {\n      button: 0,\n      which: 0,\n      buttons: 1,\n      bubbles: true,\n      cancelable: true,\n      target: info.target ? info.target : e.target\n    };\n    // don't check for `instanceof DragEvent` as Safari use MouseEvent #1540\n    if (e.dataTransfer) {\n      evt['dataTransfer'] = e.dataTransfer; // workaround 'readonly' field.\n    }\n\n    ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].forEach(p => evt[p] = e[p]); // keys\n    ['pageX', 'pageY', 'clientX', 'clientY', 'screenX', 'screenY'].forEach(p => evt[p] = e[p]); // point info\n    return {\n      ...evt,\n      ...obj\n    };\n  }\n  /** copies the MouseEvent properties and sends it as another event to the given target */\n  static simulateMouseEvent(e, simulatedType, target) {\n    const simulatedEvent = document.createEvent('MouseEvents');\n    simulatedEvent.initMouseEvent(simulatedType,\n    // type\n    true,\n    // bubbles\n    true,\n    // cancelable\n    window,\n    // view\n    1,\n    // detail\n    e.screenX,\n    // screenX\n    e.screenY,\n    // screenY\n    e.clientX,\n    // clientX\n    e.clientY,\n    // clientY\n    e.ctrlKey,\n    // ctrlKey\n    e.altKey,\n    // altKey\n    e.shiftKey,\n    // shiftKey\n    e.metaKey,\n    // metaKey\n    0,\n    // button\n    e.target // relatedTarget\n    );\n\n    (target || e.target).dispatchEvent(simulatedEvent);\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/gridstack/dist/utils.js?");

/***/ }),

/***/ "./node_modules/highcharts/highcharts.js":
/*!***********************************************!*\
  !*** ./node_modules/highcharts/highcharts.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n Highcharts JS v11.1.0 (2023-06-05)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n\n\n(function (U, M) {\n   true && module.exports ? (M[\"default\"] = M, module.exports = U.document ? M(U) : M) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return M(U);\n  }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(\"undefined\" !== typeof window ? window : this, function (U) {\n  function M(a, y, I, L) {\n    a.hasOwnProperty(y) || (a[y] = L.apply(null, I), \"function\" === typeof CustomEvent && U.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: y,\n        module: a[y]\n      }\n    })));\n  }\n  var a = {};\n  M(a, \"Core/Globals.js\", [], function () {\n    var a;\n    (function (a) {\n      a.SVG_NS = \"http://www.w3.org/2000/svg\";\n      a.product = \"Highcharts\";\n      a.version = \"11.1.0\";\n      a.win = \"undefined\" !== typeof U ? U : {};\n      a.doc = a.win.document;\n      a.svg = a.doc && a.doc.createElementNS && !!a.doc.createElementNS(a.SVG_NS, \"svg\").createSVGRect;\n      a.userAgent = a.win.navigator && a.win.navigator.userAgent || \"\";\n      a.isChrome = -1 !== a.userAgent.indexOf(\"Chrome\");\n      a.isFirefox = -1 !== a.userAgent.indexOf(\"Firefox\");\n      a.isMS = /(edge|msie|trident)/i.test(a.userAgent) && !a.win.opera;\n      a.isSafari = !a.isChrome && -1 !== a.userAgent.indexOf(\"Safari\");\n      a.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a.userAgent);\n      a.isWebKit = -1 !== a.userAgent.indexOf(\"AppleWebKit\");\n      a.deg2rad = 2 * Math.PI / 360;\n      a.hasBidiBug = a.isFirefox && 4 > parseInt(a.userAgent.split(\"Firefox/\")[1], 10);\n      a.hasTouch = !!a.win.TouchEvent;\n      a.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"];\n      a.noop = function () {};\n      a.supportsPassiveEvents = function () {\n        let x = !1;\n        if (!a.isMS) {\n          const y = Object.defineProperty({}, \"passive\", {\n            get: function () {\n              x = !0;\n            }\n          });\n          a.win.addEventListener && a.win.removeEventListener && (a.win.addEventListener(\"testPassive\", a.noop, y), a.win.removeEventListener(\"testPassive\", a.noop, y));\n        }\n        return x;\n      }();\n      a.charts = [];\n      a.dateFormats = {};\n      a.seriesTypes = {};\n      a.symbolSizes = {};\n      a.chartCount = 0;\n    })(a || (a = {}));\n    \"\";\n    return a;\n  });\n  M(a, \"Core/Utilities.js\", [a[\"Core/Globals.js\"]], function (a) {\n    function x(c, b, f, k) {\n      const n = b ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === c && (c = `${n}: Deprecated member`);\n      const r = u(c);\n      let e = r ? `${n} #${c}: www.highcharts.com/errors/${c}/` : c.toString();\n      if (\"undefined\" !== typeof k) {\n        let c = \"\";\n        r && (e += \"?\");\n        E(k, function (b, n) {\n          c += `\\n - ${n}: ${b}`;\n          r && (e += encodeURI(n) + \"=\" + encodeURI(b));\n        });\n        e += c;\n      }\n      d(a, \"displayError\", {\n        chart: f,\n        code: c,\n        message: e,\n        params: k\n      }, function () {\n        if (b) throw Error(e);\n        q.console && -1 === x.messages.indexOf(e) && console.warn(e);\n      });\n      x.messages.push(e);\n    }\n    function I(c, b) {\n      return parseInt(c, b || 10);\n    }\n    function L(c) {\n      return \"string\" === typeof c;\n    }\n    function C(c) {\n      c = Object.prototype.toString.call(c);\n      return \"[object Array]\" === c || \"[object Array Iterator]\" === c;\n    }\n    function z(c, b) {\n      return !!c && \"object\" === typeof c && (!b || !C(c));\n    }\n    function H(c) {\n      return z(c) && \"number\" === typeof c.nodeType;\n    }\n    function B(c) {\n      const b = c && c.constructor;\n      return !(!z(c, !0) || H(c) || !b || !b.name || \"Object\" === b.name);\n    }\n    function u(c) {\n      return \"number\" === typeof c && !isNaN(c) && Infinity > c && -Infinity < c;\n    }\n    function v(c) {\n      return \"undefined\" !== typeof c && null !== c;\n    }\n    function l(c, b, f) {\n      const n = L(b) && !v(f);\n      let d;\n      const k = (b, f) => {\n        v(b) ? c.setAttribute(f, b) : n ? (d = c.getAttribute(f)) || \"class\" !== f || (d = c.getAttribute(f + \"Name\")) : c.removeAttribute(f);\n      };\n      L(b) ? k(f, b) : E(b, k);\n      return d;\n    }\n    function p(c) {\n      return C(c) ? c : [c];\n    }\n    function t(c, b) {\n      let n;\n      c || (c = {});\n      for (n in b) c[n] = b[n];\n      return c;\n    }\n    function m() {\n      const c = arguments,\n        b = c.length;\n      for (let n = 0; n < b; n++) {\n        const b = c[n];\n        if (\"undefined\" !== typeof b && null !== b) return b;\n      }\n    }\n    function h(c, b) {\n      a.isMS && !a.svg && b && v(b.opacity) && (b.filter = `alpha(opacity=${100 * b.opacity})`);\n      t(c.style, b);\n    }\n    function g(c) {\n      return Math.pow(10, Math.floor(Math.log(c) / Math.LN10));\n    }\n    function e(c, b) {\n      return 1E14 < c ? c : parseFloat(c.toPrecision(b || 14));\n    }\n    function w(c, b, f) {\n      let n;\n      if (\"width\" === b) return b = Math.min(c.offsetWidth, c.scrollWidth), f = c.getBoundingClientRect && c.getBoundingClientRect().width, f < b && f >= b - 1 && (b = Math.floor(f)), Math.max(0, b - (w(c, \"padding-left\", !0) || 0) - (w(c, \"padding-right\", !0) || 0));\n      if (\"height\" === b) return Math.max(0, Math.min(c.offsetHeight, c.scrollHeight) - (w(c, \"padding-top\", !0) || 0) - (w(c, \"padding-bottom\", !0) || 0));\n      if (c = q.getComputedStyle(c, void 0)) n = c.getPropertyValue(b), m(f, \"opacity\" !== b) && (n = I(n));\n      return n;\n    }\n    function E(c, b, f) {\n      for (const n in c) Object.hasOwnProperty.call(c, n) && b.call(f || c[n], c[n], n, c);\n    }\n    function F(c, b, f) {\n      function n(b, n) {\n        const f = c.removeEventListener;\n        f && f.call(c, b, n, !1);\n      }\n      function d(f) {\n        let d, K;\n        c.nodeName && (b ? (d = {}, d[b] = !0) : d = f, E(d, function (c, b) {\n          if (f[b]) for (K = f[b].length; K--;) n(b, f[b][K].fn);\n        }));\n      }\n      var k = \"function\" === typeof c && c.prototype || c;\n      if (Object.hasOwnProperty.call(k, \"hcEvents\")) {\n        const c = k.hcEvents;\n        b ? (k = c[b] || [], f ? (c[b] = k.filter(function (c) {\n          return f !== c.fn;\n        }), n(b, f)) : (d(c), c[b] = [])) : (d(c), delete k.hcEvents);\n      }\n    }\n    function d(c, b, f, d) {\n      f = f || {};\n      if (r.createEvent && (c.dispatchEvent || c.fireEvent && c !== a)) {\n        var n = r.createEvent(\"Events\");\n        n.initEvent(b, !0, !0);\n        f = t(n, f);\n        c.dispatchEvent ? c.dispatchEvent(f) : c.fireEvent(b, f);\n      } else if (c.hcEvents) {\n        f.target || t(f, {\n          preventDefault: function () {\n            f.defaultPrevented = !0;\n          },\n          target: c,\n          type: b\n        });\n        n = [];\n        let d = c,\n          K = !1;\n        for (; d.hcEvents;) Object.hasOwnProperty.call(d, \"hcEvents\") && d.hcEvents[b] && (n.length && (K = !0), n.unshift.apply(n, d.hcEvents[b])), d = Object.getPrototypeOf(d);\n        K && n.sort((c, b) => c.order - b.order);\n        n.forEach(b => {\n          !1 === b.fn.call(c, f) && f.preventDefault();\n        });\n      }\n      d && !f.defaultPrevented && d.call(c, f);\n    }\n    const {\n      charts: k,\n      doc: r,\n      win: q\n    } = a;\n    (x || (x = {})).messages = [];\n    Math.easeInOutSine = function (c) {\n      return -.5 * (Math.cos(Math.PI * c) - 1);\n    };\n    var G = Array.prototype.find ? function (c, b) {\n      return c.find(b);\n    } : function (c, b) {\n      let f;\n      const n = c.length;\n      for (f = 0; f < n; f++) if (b(c[f], f)) return c[f];\n    };\n    E({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (c, b) {\n      a[b] = function (f) {\n        x(32, !1, void 0, {\n          [`Highcharts.${b}`]: `use Array.${c}`\n        });\n        return Array.prototype[c].apply(f, [].slice.call(arguments, 1));\n      };\n    });\n    let b;\n    const f = function () {\n      const c = Math.random().toString(36).substring(2, 9) + \"-\";\n      let f = 0;\n      return function () {\n        return \"highcharts-\" + (b ? \"\" : c) + f++;\n      };\n    }();\n    q.jQuery && (q.jQuery.fn.highcharts = function () {\n      const c = [].slice.call(arguments);\n      if (this[0]) return c[0] ? (new a[L(c[0]) ? c.shift() : \"Chart\"](this[0], c[0], c[1]), this) : k[l(this[0], \"data-highcharts-chart\")];\n    });\n    G = {\n      addEvent: function (c, b, f, d = {}) {\n        var n = \"function\" === typeof c && c.prototype || c;\n        Object.hasOwnProperty.call(n, \"hcEvents\") || (n.hcEvents = {});\n        n = n.hcEvents;\n        a.Point && c instanceof a.Point && c.series && c.series.chart && (c.series.chart.runTrackerClick = !0);\n        const k = c.addEventListener;\n        k && k.call(c, b, f, a.supportsPassiveEvents ? {\n          passive: void 0 === d.passive ? -1 !== b.indexOf(\"touch\") : d.passive,\n          capture: !1\n        } : !1);\n        n[b] || (n[b] = []);\n        n[b].push({\n          fn: f,\n          order: \"number\" === typeof d.order ? d.order : Infinity\n        });\n        n[b].sort((c, b) => c.order - b.order);\n        return function () {\n          F(c, b, f);\n        };\n      },\n      arrayMax: function (c) {\n        let b = c.length,\n          f = c[0];\n        for (; b--;) c[b] > f && (f = c[b]);\n        return f;\n      },\n      arrayMin: function (c) {\n        let b = c.length,\n          f = c[0];\n        for (; b--;) c[b] < f && (f = c[b]);\n        return f;\n      },\n      attr: l,\n      clamp: function (c, b, f) {\n        return c > b ? c < f ? c : f : b;\n      },\n      clearTimeout: function (c) {\n        v(c) && clearTimeout(c);\n      },\n      correctFloat: e,\n      createElement: function (c, b, f, d, K) {\n        c = r.createElement(c);\n        b && t(c, b);\n        K && h(c, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        });\n        f && h(c, f);\n        d && d.appendChild(c);\n        return c;\n      },\n      css: h,\n      defined: v,\n      destroyObjectProperties: function (c, b) {\n        E(c, function (f, n) {\n          f && f !== b && f.destroy && f.destroy();\n          delete c[n];\n        });\n      },\n      diffObjects: function (c, b, f, d) {\n        function n(b, c, K, k) {\n          const A = f ? c : b;\n          E(b, function (f, q) {\n            if (!k && d && -1 < d.indexOf(q) && c[q]) {\n              f = p(f);\n              K[q] = [];\n              for (let b = 0; b < Math.max(f.length, c[q].length); b++) c[q][b] && (void 0 === f[b] ? K[q][b] = c[q][b] : (K[q][b] = {}, n(f[b], c[q][b], K[q][b], k + 1)));\n            } else if (z(f, !0) && !f.nodeType) K[q] = C(f) ? [] : {}, n(f, c[q] || {}, K[q], k + 1), 0 !== Object.keys(K[q]).length || \"colorAxis\" === q && 0 === k || delete K[q];else if (b[q] !== c[q] || q in b && !(q in c)) K[q] = A[q];\n          });\n        }\n        const k = {};\n        n(c, b, k, 0);\n        return k;\n      },\n      discardElement: function (b) {\n        b && b.parentElement && b.parentElement.removeChild(b);\n      },\n      erase: function (b, f) {\n        let c = b.length;\n        for (; c--;) if (b[c] === f) {\n          b.splice(c, 1);\n          break;\n        }\n      },\n      error: x,\n      extend: t,\n      extendClass: function (b, f) {\n        const c = function () {};\n        c.prototype = new b();\n        t(c.prototype, f);\n        return c;\n      },\n      find: G,\n      fireEvent: d,\n      getClosestDistance: function (b, f) {\n        const c = !f;\n        let d, n, k, q;\n        b.forEach(b => {\n          if (1 < b.length) for (q = n = b.length - 1; 0 < q; q--) k = b[q] - b[q - 1], 0 > k && !c ? (null === f || void 0 === f ? void 0 : f(), f = void 0) : k && (\"undefined\" === typeof d || k < d) && (d = k);\n        });\n        return d;\n      },\n      getMagnitude: g,\n      getNestedProperty: function (b, f) {\n        for (b = b.split(\".\"); b.length && v(f);) {\n          const c = b.shift();\n          if (\"undefined\" === typeof c || \"__proto__\" === c) return;\n          if (\"this\" === c) {\n            let b;\n            z(f) && (b = f[\"@this\"]);\n            return null !== b && void 0 !== b ? b : f;\n          }\n          f = f[c];\n          if (!v(f) || \"function\" === typeof f || \"number\" === typeof f.nodeType || f === q) return;\n        }\n        return f;\n      },\n      getStyle: w,\n      inArray: function (b, f, d) {\n        x(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        });\n        return f.indexOf(b, d);\n      },\n      insertItem: function (b, f) {\n        const c = b.options.index,\n          d = f.length;\n        let n;\n        for (n = b.options.isInternal ? d : 0; n < d + 1; n++) if (!f[n] || u(c) && c < m(f[n].options.index, f[n]._i) || f[n].options.isInternal) {\n          f.splice(n, 0, b);\n          break;\n        }\n        return n;\n      },\n      isArray: C,\n      isClass: B,\n      isDOMElement: H,\n      isFunction: function (b) {\n        return \"function\" === typeof b;\n      },\n      isNumber: u,\n      isObject: z,\n      isString: L,\n      keys: function (b) {\n        x(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        });\n        return Object.keys(b);\n      },\n      merge: function () {\n        let b,\n          f = arguments,\n          d = {};\n        const k = function (b, c) {\n          \"object\" !== typeof b && (b = {});\n          E(c, function (f, d) {\n            \"__proto__\" !== d && \"constructor\" !== d && (!z(f, !0) || B(f) || H(f) ? b[d] = c[d] : b[d] = k(b[d] || {}, f));\n          });\n          return b;\n        };\n        !0 === f[0] && (d = f[1], f = Array.prototype.slice.call(f, 2));\n        const K = f.length;\n        for (b = 0; b < K; b++) d = k(d, f[b]);\n        return d;\n      },\n      normalizeTickInterval: function (b, f, d, k, K) {\n        let c = b;\n        d = m(d, g(b));\n        const n = b / d;\n        f || (f = K ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === k && (1 === d ? f = f.filter(function (b) {\n          return 0 === b % 1;\n        }) : .1 >= d && (f = [1 / d])));\n        for (k = 0; k < f.length && !(c = f[k], K && c * d >= b || !K && n <= (f[k] + (f[k + 1] || f[k])) / 2); k++);\n        return c = e(c * d, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: E,\n      offset: function (b) {\n        const c = r.documentElement;\n        b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0\n        };\n        return {\n          top: b.top + (q.pageYOffset || c.scrollTop) - (c.clientTop || 0),\n          left: b.left + (q.pageXOffset || c.scrollLeft) - (c.clientLeft || 0),\n          width: b.width,\n          height: b.height\n        };\n      },\n      pad: function (b, f, d) {\n        return Array((f || 2) + 1 - String(b).replace(\"-\", \"\").length).join(d || \"0\") + b;\n      },\n      pick: m,\n      pInt: I,\n      pushUnique: function (b, f) {\n        return 0 > b.indexOf(f) && !!b.push(f);\n      },\n      relativeLength: function (b, f, d) {\n        return /%$/.test(b) ? f * parseFloat(b) / 100 + (d || 0) : parseFloat(b);\n      },\n      removeEvent: F,\n      splat: p,\n      stableSort: function (b, f) {\n        const c = b.length;\n        let d, k;\n        for (k = 0; k < c; k++) b[k].safeI = k;\n        b.sort(function (b, c) {\n          d = f(b, c);\n          return 0 === d ? b.safeI - c.safeI : d;\n        });\n        for (k = 0; k < c; k++) delete b[k].safeI;\n      },\n      syncTimeout: function (b, f, d) {\n        if (0 < f) return setTimeout(b, f, d);\n        b.call(0, d);\n        return -1;\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1E3,\n        minute: 6E4,\n        hour: 36E5,\n        day: 864E5,\n        week: 6048E5,\n        month: 24192E5,\n        year: 314496E5\n      },\n      uniqueKey: f,\n      useSerialIds: function (c) {\n        return b = m(c, b);\n      },\n      wrap: function (b, f, d) {\n        const c = b[f];\n        b[f] = function () {\n          const b = arguments,\n            f = this;\n          return d.apply(this, [function () {\n            return c.apply(f, arguments.length ? arguments : b);\n          }].concat([].slice.call(arguments)));\n        };\n      }\n    };\n    \"\";\n    return G;\n  });\n  M(a, \"Core/Chart/ChartDefaults.js\", [], function () {\n    return {\n      alignThresholds: !1,\n      panning: {\n        enabled: !1,\n        type: \"x\"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      allowMutatingData: !0,\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {\n          zIndex: 6\n        },\n        position: {\n          align: \"right\",\n          x: -10,\n          y: 10\n        }\n      },\n      reflow: !0,\n      type: \"line\",\n      zooming: {\n        singleTouch: !1,\n        resetButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        }\n      },\n      width: null,\n      height: null,\n      borderColor: \"#334eff\",\n      backgroundColor: \"#ffffff\",\n      plotBorderColor: \"#cccccc\"\n    };\n  });\n  M(a, \"Core/Color/Color.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n      isNumber: x,\n      merge: L,\n      pInt: C\n    } = y;\n    class z {\n      static parse(a) {\n        return a ? new z(a) : z.None;\n      }\n      constructor(x) {\n        this.rgba = [NaN, NaN, NaN, NaN];\n        this.input = x;\n        const B = a.Color;\n        if (B && B !== z) return new B(x);\n        this.init(x);\n      }\n      init(a) {\n        let B;\n        let u;\n        if (\"object\" === typeof a && \"undefined\" !== typeof a.stops) this.stops = a.stops.map(l => new z(l[1]));else if (\"string\" === typeof a) {\n          this.input = a = z.names[a.toLowerCase()] || a;\n          if (\"#\" === a.charAt(0)) {\n            var v = a.length;\n            var l = parseInt(a.substr(1), 16);\n            7 === v ? B = [(l & 16711680) >> 16, (l & 65280) >> 8, l & 255, 1] : 4 === v && (B = [(l & 3840) >> 4 | (l & 3840) >> 8, (l & 240) >> 4 | l & 240, (l & 15) << 4 | l & 15, 1]);\n          }\n          if (!B) for (l = z.parsers.length; l-- && !B;) u = z.parsers[l], (v = u.regex.exec(a)) && (B = u.parse(v));\n        }\n        B && (this.rgba = B);\n      }\n      get(a) {\n        const B = this.input,\n          u = this.rgba;\n        if (\"object\" === typeof B && \"undefined\" !== typeof this.stops) {\n          const v = L(B);\n          v.stops = [].slice.call(v.stops);\n          this.stops.forEach((l, p) => {\n            v.stops[p] = [v.stops[p][0], l.get(a)];\n          });\n          return v;\n        }\n        return u && x(u[0]) ? \"rgb\" === a || !a && 1 === u[3] ? \"rgb(\" + u[0] + \",\" + u[1] + \",\" + u[2] + \")\" : \"a\" === a ? `${u[3]}` : \"rgba(\" + u.join(\",\") + \")\" : B;\n      }\n      brighten(a) {\n        const B = this.rgba;\n        if (this.stops) this.stops.forEach(function (u) {\n          u.brighten(a);\n        });else if (x(a) && 0 !== a) for (let u = 0; 3 > u; u++) B[u] += C(255 * a), 0 > B[u] && (B[u] = 0), 255 < B[u] && (B[u] = 255);\n        return this;\n      }\n      setOpacity(a) {\n        this.rgba[3] = a;\n        return this;\n      }\n      tweenTo(a, B) {\n        const u = this.rgba,\n          v = a.rgba;\n        if (!x(u[0]) || !x(v[0])) return a.input || \"none\";\n        a = 1 !== v[3] || 1 !== u[3];\n        return (a ? \"rgba(\" : \"rgb(\") + Math.round(v[0] + (u[0] - v[0]) * (1 - B)) + \",\" + Math.round(v[1] + (u[1] - v[1]) * (1 - B)) + \",\" + Math.round(v[2] + (u[2] - v[2]) * (1 - B)) + (a ? \",\" + (v[3] + (u[3] - v[3]) * (1 - B)) : \"\") + \")\";\n      }\n    }\n    z.names = {\n      white: \"#ffffff\",\n      black: \"#000000\"\n    };\n    z.parsers = [{\n      regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n      parse: function (a) {\n        return [C(a[1]), C(a[2]), C(a[3]), parseFloat(a[4], 10)];\n      }\n    }, {\n      regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n      parse: function (a) {\n        return [C(a[1]), C(a[2]), C(a[3]), 1];\n      }\n    }];\n    z.None = new z(\"\");\n    \"\";\n    return z;\n  });\n  M(a, \"Core/Color/Palettes.js\", [], function () {\n    return {\n      colors: \"#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1\".split(\" \")\n    };\n  });\n  M(a, \"Core/Time.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n        win: x\n      } = a,\n      {\n        defined: L,\n        error: C,\n        extend: z,\n        isObject: H,\n        merge: B,\n        objectEach: u,\n        pad: v,\n        pick: l,\n        splat: p,\n        timeUnits: t\n      } = y,\n      m = a.isSafari && x.Intl && x.Intl.DateTimeFormat.prototype.formatRange,\n      h = a.isSafari && x.Intl && !x.Intl.DateTimeFormat.prototype.formatRange;\n    class g {\n      constructor(e) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = x.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(e);\n      }\n      get(e, g) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          const h = g.getTime(),\n            m = h - this.getTimezoneOffset(g);\n          g.setTime(m);\n          e = g[\"getUTC\" + e]();\n          g.setTime(h);\n          return e;\n        }\n        return this.useUTC ? g[\"getUTC\" + e]() : g[\"get\" + e]();\n      }\n      set(e, g, h) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === e || \"Seconds\" === e || \"Minutes\" === e && 0 === this.getTimezoneOffset(g) % 36E5) return g[\"setUTC\" + e](h);\n          var w = this.getTimezoneOffset(g);\n          w = g.getTime() - w;\n          g.setTime(w);\n          g[\"setUTC\" + e](h);\n          e = this.getTimezoneOffset(g);\n          w = g.getTime() + e;\n          return g.setTime(w);\n        }\n        return this.useUTC || m && \"FullYear\" === e ? g[\"setUTC\" + e](h) : g[\"set\" + e](h);\n      }\n      update(e = {}) {\n        const g = l(e.useUTC, !0);\n        this.options = e = B(!0, this.options, e);\n        this.Date = e.Date || x.Date || Date;\n        this.timezoneOffset = (this.useUTC = g) && e.timezoneOffset || void 0;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = g && !(!e.getTimezoneOffset && !e.timezone);\n      }\n      makeTime(e, g, m, p, d, k) {\n        let r, q, w;\n        this.useUTC ? (r = this.Date.UTC.apply(0, arguments), q = this.getTimezoneOffset(r), r += q, w = this.getTimezoneOffset(r), q !== w ? r += w - q : q - 36E5 !== this.getTimezoneOffset(r - 36E5) || h || (r -= 36E5)) : r = new this.Date(e, g, l(m, 1), l(p, 0), l(d, 0), l(k, 0)).getTime();\n        return r;\n      }\n      timezoneOffsetFunction() {\n        const e = this,\n          g = this.options,\n          h = g.getTimezoneOffset,\n          m = g.moment || x.moment;\n        if (!this.useUTC) return function (d) {\n          return 6E4 * new Date(d.toString()).getTimezoneOffset();\n        };\n        if (g.timezone) {\n          if (m) return function (d) {\n            return 6E4 * -m.tz(d, g.timezone).utcOffset();\n          };\n          C(25);\n        }\n        return this.useUTC && h ? function (d) {\n          return 6E4 * h(d.valueOf());\n        } : function () {\n          return 6E4 * (e.timezoneOffset || 0);\n        };\n      }\n      dateFormat(e, g, h) {\n        if (!L(g) || isNaN(g)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || \"\";\n        e = l(e, \"%Y-%m-%d %H:%M:%S\");\n        const m = this;\n        var d = new this.Date(g);\n        const k = this.get(\"Hours\", d),\n          r = this.get(\"Day\", d),\n          q = this.get(\"Date\", d),\n          w = this.get(\"Month\", d),\n          b = this.get(\"FullYear\", d),\n          f = a.defaultOptions.lang,\n          c = f && f.weekdays,\n          n = f && f.shortWeekdays;\n        d = z({\n          a: n ? n[r] : c[r].substr(0, 3),\n          A: c[r],\n          d: v(q),\n          e: v(q, 2, \" \"),\n          w: r,\n          b: f.shortMonths[w],\n          B: f.months[w],\n          m: v(w + 1),\n          o: w + 1,\n          y: b.toString().substr(2, 2),\n          Y: b,\n          H: v(k),\n          k,\n          I: v(k % 12 || 12),\n          l: k % 12 || 12,\n          M: v(this.get(\"Minutes\", d)),\n          p: 12 > k ? \"AM\" : \"PM\",\n          P: 12 > k ? \"am\" : \"pm\",\n          S: v(d.getSeconds()),\n          L: v(Math.floor(g % 1E3), 3)\n        }, a.dateFormats);\n        u(d, function (b, c) {\n          for (; -1 !== e.indexOf(\"%\" + c);) e = e.replace(\"%\" + c, \"function\" === typeof b ? b.call(m, g) : b);\n        });\n        return h ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;\n      }\n      resolveDTLFormat(e) {\n        return H(e, !0) ? e : (e = p(e), {\n          main: e[0],\n          from: e[1],\n          to: e[2]\n        });\n      }\n      getTimeTicks(e, g, h, m) {\n        const d = this,\n          k = [],\n          r = {};\n        var q = new d.Date(g);\n        const w = e.unitRange,\n          b = e.count || 1;\n        let f;\n        m = l(m, 1);\n        if (L(g)) {\n          d.set(\"Milliseconds\", q, w >= t.second ? 0 : b * Math.floor(d.get(\"Milliseconds\", q) / b));\n          w >= t.second && d.set(\"Seconds\", q, w >= t.minute ? 0 : b * Math.floor(d.get(\"Seconds\", q) / b));\n          w >= t.minute && d.set(\"Minutes\", q, w >= t.hour ? 0 : b * Math.floor(d.get(\"Minutes\", q) / b));\n          w >= t.hour && d.set(\"Hours\", q, w >= t.day ? 0 : b * Math.floor(d.get(\"Hours\", q) / b));\n          w >= t.day && d.set(\"Date\", q, w >= t.month ? 1 : Math.max(1, b * Math.floor(d.get(\"Date\", q) / b)));\n          if (w >= t.month) {\n            d.set(\"Month\", q, w >= t.year ? 0 : b * Math.floor(d.get(\"Month\", q) / b));\n            var c = d.get(\"FullYear\", q);\n          }\n          w >= t.year && d.set(\"FullYear\", q, c - c % b);\n          w === t.week && (c = d.get(\"Day\", q), d.set(\"Date\", q, d.get(\"Date\", q) - c + m + (c < m ? -7 : 0)));\n          c = d.get(\"FullYear\", q);\n          m = d.get(\"Month\", q);\n          const n = d.get(\"Date\", q),\n            e = d.get(\"Hours\", q);\n          g = q.getTime();\n          !d.variableTimezone && d.useUTC || !L(h) || (f = h - g > 4 * t.month || d.getTimezoneOffset(g) !== d.getTimezoneOffset(h));\n          g = q.getTime();\n          for (q = 1; g < h;) k.push(g), g = w === t.year ? d.makeTime(c + q * b, 0) : w === t.month ? d.makeTime(c, m + q * b) : !f || w !== t.day && w !== t.week ? f && w === t.hour && 1 < b ? d.makeTime(c, m, n, e + q * b) : g + w * b : d.makeTime(c, m, n + q * b * (w === t.day ? 1 : 7)), q++;\n          k.push(g);\n          w <= t.hour && 1E4 > k.length && k.forEach(function (b) {\n            0 === b % 18E5 && \"000000000\" === d.dateFormat(\"%H%M%S%L\", b) && (r[b] = \"day\");\n          });\n        }\n        k.info = z(e, {\n          higherRanks: r,\n          totalRange: w * b\n        });\n        return k;\n      }\n      getDateFormat(e, g, h, m) {\n        const d = this.dateFormat(\"%m-%d %H:%M:%S.%L\", g),\n          k = {\n            millisecond: 15,\n            second: 12,\n            minute: 9,\n            hour: 6,\n            day: 3\n          };\n        let r,\n          q = \"millisecond\";\n        for (r in t) {\n          if (e === t.week && +this.dateFormat(\"%w\", g) === h && \"00:00:00.000\" === d.substr(6)) {\n            r = \"week\";\n            break;\n          }\n          if (t[r] > e) {\n            r = q;\n            break;\n          }\n          if (k[r] && d.substr(k[r]) !== \"01-01 00:00:00.000\".substr(k[r])) break;\n          \"week\" !== r && (q = r);\n        }\n        return this.resolveDTLFormat(m[r]).main;\n      }\n    }\n    \"\";\n    return g;\n  });\n  M(a, \"Core/Defaults.js\", [a[\"Core/Chart/ChartDefaults.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Color/Palettes.js\"], a[\"Core/Time.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z) {\n    const {\n        isTouchDevice: x,\n        svg: B\n      } = I,\n      {\n        merge: u\n      } = z,\n      v = {\n        colors: L.colors,\n        symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n        lang: {\n          loading: \"Loading...\",\n          months: \"January February March April May June July August September October November December\".split(\" \"),\n          shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n          weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n          decimalPoint: \".\",\n          numericSymbols: \"kMGTPE\".split(\"\"),\n          resetZoom: \"Reset zoom\",\n          resetZoomTitle: \"Reset zoom level 1:1\",\n          thousandsSep: \" \"\n        },\n        global: {},\n        time: {\n          Date: void 0,\n          getTimezoneOffset: void 0,\n          timezone: void 0,\n          timezoneOffset: 0,\n          useUTC: !0\n        },\n        chart: a,\n        title: {\n          style: {\n            color: \"#333333\",\n            fontWeight: \"bold\"\n          },\n          text: \"Chart title\",\n          align: \"center\",\n          margin: 15,\n          widthAdjust: -44\n        },\n        subtitle: {\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          },\n          text: \"\",\n          align: \"center\",\n          widthAdjust: -44\n        },\n        caption: {\n          margin: 15,\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          },\n          text: \"\",\n          align: \"left\",\n          verticalAlign: \"bottom\"\n        },\n        plotOptions: {},\n        legend: {\n          enabled: !0,\n          align: \"center\",\n          alignColumns: !0,\n          className: \"highcharts-no-tooltip\",\n          layout: \"horizontal\",\n          itemMarginBottom: 2,\n          itemMarginTop: 2,\n          labelFormatter: function () {\n            return this.name;\n          },\n          borderColor: \"#999999\",\n          borderRadius: 0,\n          navigation: {\n            style: {\n              fontSize: \"0.8em\"\n            },\n            activeColor: \"#0022ff\",\n            inactiveColor: \"#cccccc\"\n          },\n          itemStyle: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontSize: \"0.8em\",\n            textDecoration: \"none\",\n            textOverflow: \"ellipsis\"\n          },\n          itemHoverStyle: {\n            color: \"#000000\"\n          },\n          itemHiddenStyle: {\n            color: \"#666666\",\n            textDecoration: \"line-through\"\n          },\n          shadow: !1,\n          itemCheckboxStyle: {\n            position: \"absolute\",\n            width: \"13px\",\n            height: \"13px\"\n          },\n          squareSymbol: !0,\n          symbolPadding: 5,\n          verticalAlign: \"bottom\",\n          x: 0,\n          y: 0,\n          title: {\n            style: {\n              fontSize: \"0.8em\",\n              fontWeight: \"bold\"\n            }\n          }\n        },\n        loading: {\n          labelStyle: {\n            fontWeight: \"bold\",\n            position: \"relative\",\n            top: \"45%\"\n          },\n          style: {\n            position: \"absolute\",\n            backgroundColor: \"#ffffff\",\n            opacity: .5,\n            textAlign: \"center\"\n          }\n        },\n        tooltip: {\n          enabled: !0,\n          animation: B,\n          borderRadius: 3,\n          dateTimeLabelFormats: {\n            millisecond: \"%A, %e %b, %H:%M:%S.%L\",\n            second: \"%A, %e %b, %H:%M:%S\",\n            minute: \"%A, %e %b, %H:%M\",\n            hour: \"%A, %e %b, %H:%M\",\n            day: \"%A, %e %b %Y\",\n            week: \"Week from %A, %e %b %Y\",\n            month: \"%B %Y\",\n            year: \"%Y\"\n          },\n          footerFormat: \"\",\n          headerShape: \"callout\",\n          hideDelay: 500,\n          padding: 8,\n          shape: \"callout\",\n          shared: !1,\n          snap: x ? 25 : 10,\n          headerFormat: '<span style=\"font-size: 0.8em\">{point.key}</span><br/>',\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n          backgroundColor: \"#ffffff\",\n          borderWidth: void 0,\n          shadow: !0,\n          stickOnContact: !1,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          },\n          useHTML: !1\n        },\n        credits: {\n          enabled: !0,\n          href: \"https://www.highcharts.com?credits\",\n          position: {\n            align: \"right\",\n            x: -10,\n            verticalAlign: \"bottom\",\n            y: -5\n          },\n          style: {\n            cursor: \"pointer\",\n            color: \"#999999\",\n            fontSize: \"0.6em\"\n          },\n          text: \"Highcharts.com\"\n        }\n      };\n    v.chart.styledMode = !1;\n    \"\";\n    const l = new C(v.time);\n    a = {\n      defaultOptions: v,\n      defaultTime: l,\n      getOptions: function () {\n        return v;\n      },\n      setOptions: function (a) {\n        u(!0, v, a);\n        if (a.time || a.global) I.time ? I.time.update(u(v.global, v.time, a.global, a.time)) : I.time = l;\n        return v;\n      }\n    };\n    \"\";\n    return a;\n  });\n  M(a, \"Core/Animation/Fx.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        parse: x\n      } = a,\n      {\n        win: C\n      } = y,\n      {\n        isNumber: z,\n        objectEach: H\n      } = I;\n    class B {\n      constructor(a, v, l) {\n        this.pos = NaN;\n        this.options = v;\n        this.elem = a;\n        this.prop = l;\n      }\n      dSetter() {\n        var a = this.paths;\n        const v = a && a[0];\n        a = a && a[1];\n        const l = this.now || 0;\n        let p = [];\n        if (1 !== l && v && a) {\n          if (v.length === a.length && 1 > l) for (let t = 0; t < a.length; t++) {\n            const m = v[t],\n              h = a[t],\n              g = [];\n            for (let e = 0; e < h.length; e++) {\n              const w = m[e],\n                a = h[e];\n              z(w) && z(a) && (\"A\" !== h[0] || 4 !== e && 5 !== e) ? g[e] = w + l * (a - w) : g[e] = a;\n            }\n            p.push(g);\n          } else p = a;\n        } else p = this.toD || [];\n        this.elem.attr(\"d\", p, void 0, !0);\n      }\n      update() {\n        const a = this.elem,\n          v = this.prop,\n          l = this.now,\n          p = this.options.step;\n        if (this[v + \"Setter\"]) this[v + \"Setter\"]();else a.attr ? a.element && a.attr(v, l, null, !0) : a.style[v] = l + this.unit;\n        p && p.call(a, l, this);\n      }\n      run(a, v, l) {\n        const p = this,\n          t = p.options,\n          m = function (e) {\n            return m.stopped ? !1 : p.step(e);\n          },\n          h = C.requestAnimationFrame || function (e) {\n            setTimeout(e, 13);\n          },\n          g = function () {\n            for (let e = 0; e < B.timers.length; e++) B.timers[e]() || B.timers.splice(e--, 1);\n            B.timers.length && h(g);\n          };\n        a !== v || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = a, this.end = v, this.unit = l, this.now = this.start, this.pos = 0, m.elem = this.elem, m.prop = this.prop, m() && 1 === B.timers.push(m) && h(g)) : (delete t.curAnim[this.prop], t.complete && 0 === Object.keys(t.curAnim).length && t.complete.call(this.elem));\n      }\n      step(a) {\n        const v = +new Date(),\n          l = this.options,\n          p = this.elem,\n          t = l.complete,\n          m = l.duration,\n          h = l.curAnim;\n        let g;\n        p.attr && !p.element ? a = !1 : a || v >= m + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), g = h[this.prop] = !0, H(h, function (e) {\n          !0 !== e && (g = !1);\n        }), g && t && t.call(p), a = !1) : (this.pos = l.easing((v - this.startTime) / m), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a = !0);\n        return a;\n      }\n      initPath(a, v, l) {\n        function p(d, k) {\n          for (; d.length < E;) {\n            var r = d[0];\n            const q = k[E - d.length];\n            q && \"M\" === r[0] && (d[0] = \"C\" === q[0] ? [\"C\", r[1], r[2], r[1], r[2], r[1], r[2]] : [\"L\", r[1], r[2]]);\n            d.unshift(r);\n            g && (r = d.pop(), d.push(d[d.length - 1], r));\n          }\n        }\n        function t(d, k) {\n          for (; d.length < E;) if (k = d[Math.floor(d.length / e) - 1].slice(), \"C\" === k[0] && (k[1] = k[5], k[2] = k[6]), g) {\n            const r = d[Math.floor(d.length / e)].slice();\n            d.splice(d.length / 2, 0, k, r);\n          } else d.push(k);\n        }\n        const m = a.startX,\n          h = a.endX;\n        l = l.slice();\n        const g = a.isArea,\n          e = g ? 2 : 1;\n        let w, E, F;\n        v = v && v.slice();\n        if (!v) return [l, l];\n        if (m && h && h.length) {\n          for (a = 0; a < m.length; a++) if (m[a] === h[0]) {\n            w = a;\n            break;\n          } else if (m[0] === h[h.length - m.length + a]) {\n            w = a;\n            F = !0;\n            break;\n          } else if (m[m.length - 1] === h[h.length - m.length + a]) {\n            w = m.length - a;\n            break;\n          }\n          \"undefined\" === typeof w && (v = []);\n        }\n        v.length && z(w) && (E = l.length + w * e, F ? (p(v, l), t(l, v)) : (p(l, v), t(v, l)));\n        return [v, l];\n      }\n      fillSetter() {\n        B.prototype.strokeSetter.apply(this, arguments);\n      }\n      strokeSetter() {\n        this.elem.attr(this.prop, x(this.start).tweenTo(x(this.end), this.pos), void 0, !0);\n      }\n    }\n    B.timers = [];\n    return B;\n  });\n  M(a, \"Core/Animation/AnimationUtilities.js\", [a[\"Core/Animation/Fx.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    function x(a) {\n      return u(a) ? v({\n        duration: 500,\n        defer: 0\n      }, a) : {\n        duration: a ? 500 : 0,\n        defer: 0\n      };\n    }\n    function L(l, m) {\n      let h = a.timers.length;\n      for (; h--;) a.timers[h].elem !== l || m && m !== a.timers[h].prop || (a.timers[h].stopped = !0);\n    }\n    const {\n      defined: C,\n      getStyle: z,\n      isArray: H,\n      isNumber: B,\n      isObject: u,\n      merge: v,\n      objectEach: l,\n      pick: p\n    } = y;\n    return {\n      animate: function (p, m, h) {\n        let g,\n          e = \"\",\n          w,\n          E,\n          F;\n        u(h) || (F = arguments, h = {\n          duration: F[2],\n          easing: F[3],\n          complete: F[4]\n        });\n        B(h.duration) || (h.duration = 400);\n        h.easing = \"function\" === typeof h.easing ? h.easing : Math[h.easing] || Math.easeInOutSine;\n        h.curAnim = v(m);\n        l(m, function (d, k) {\n          L(p, k);\n          E = new a(p, h, k);\n          w = void 0;\n          \"d\" === k && H(m.d) ? (E.paths = E.initPath(p, p.pathArray, m.d), E.toD = m.d, g = 0, w = 1) : p.attr ? g = p.attr(k) : (g = parseFloat(z(p, k)) || 0, \"opacity\" !== k && (e = \"px\"));\n          w || (w = d);\n          \"string\" === typeof w && w.match(\"px\") && (w = w.replace(/px/g, \"\"));\n          E.run(g, w, e);\n        });\n      },\n      animObject: x,\n      getDeferredAnimation: function (a, m, h) {\n        const g = x(m);\n        let e = 0,\n          w = 0;\n        (h ? [h] : a.series).forEach(h => {\n          h = x(h.options.animation);\n          e = m && C(m.defer) ? g.defer : Math.max(e, h.duration + h.defer);\n          w = Math.min(g.duration, h.duration);\n        });\n        a.renderer.forExport && (e = 0);\n        return {\n          defer: Math.max(0, e - w),\n          duration: Math.min(e, w)\n        };\n      },\n      setAnimation: function (a, m) {\n        m.renderer.globalAnimation = p(a, m.options.chart.animation, !0);\n      },\n      stop: L\n    };\n  });\n  M(a, \"Core/Renderer/HTML/AST.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n        SVG_NS: x,\n        win: L\n      } = a,\n      {\n        attr: C,\n        createElement: z,\n        css: H,\n        error: B,\n        isFunction: u,\n        isString: v,\n        objectEach: l,\n        splat: p\n      } = y;\n    ({\n      trustedTypes: y\n    } = L);\n    const t = y && u(y.createPolicy) && y.createPolicy(\"highcharts\", {\n      createHTML: e => e\n    });\n    y = t ? t.createHTML(\"\") : \"\";\n    try {\n      var m = !!new DOMParser().parseFromString(y, \"text/html\");\n    } catch (e) {\n      m = !1;\n    }\n    const h = m;\n    class g {\n      static filterUserAttributes(e) {\n        l(e, (h, m) => {\n          let a = !0;\n          -1 === g.allowedAttributes.indexOf(m) && (a = !1);\n          -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(m) && (a = v(h) && g.allowedReferences.some(d => 0 === h.indexOf(d)));\n          a || (B(33, !1, void 0, {\n            \"Invalid attribute in config\": `${m}`\n          }), delete e[m]);\n          v(h) && e[m] && (e[m] = h.replace(/</g, \"&lt;\"));\n        });\n        return e;\n      }\n      static parseStyle(e) {\n        return e.split(\";\").reduce((e, g) => {\n          g = g.split(\":\").map(d => d.trim());\n          const h = g.shift();\n          h && g.length && (e[h.replace(/-([a-z])/g, d => d[1].toUpperCase())] = g.join(\":\"));\n          return e;\n        }, {});\n      }\n      static setElementHTML(e, h) {\n        e.innerHTML = g.emptyHTML;\n        h && new g(h).addToDOM(e);\n      }\n      constructor(e) {\n        this.nodes = \"string\" === typeof e ? this.parseMarkup(e) : e;\n      }\n      addToDOM(e) {\n        function h(e, m) {\n          let d;\n          p(e).forEach(function (k) {\n            var e = k.tagName;\n            const q = k.textContent ? a.doc.createTextNode(k.textContent) : void 0,\n              w = g.bypassHTMLFiltering;\n            let b;\n            if (e) if (\"#text\" === e) b = q;else if (-1 !== g.allowedTags.indexOf(e) || w) {\n              e = a.doc.createElementNS(\"svg\" === e ? x : m.namespaceURI || x, e);\n              const f = k.attributes || {};\n              l(k, function (b, d) {\n                \"tagName\" !== d && \"attributes\" !== d && \"children\" !== d && \"style\" !== d && \"textContent\" !== d && (f[d] = b);\n              });\n              C(e, w ? f : g.filterUserAttributes(f));\n              k.style && H(e, k.style);\n              q && e.appendChild(q);\n              h(k.children || [], e);\n              b = e;\n            } else B(33, !1, void 0, {\n              \"Invalid tagName in config\": e\n            });\n            b && m.appendChild(b);\n            d = b;\n          });\n          return d;\n        }\n        return h(this.nodes, e);\n      }\n      parseMarkup(e) {\n        const m = [];\n        e = e.trim().replace(/ style=([\"'])/g, \" data-style=$1\");\n        if (h) e = new DOMParser().parseFromString(t ? t.createHTML(e) : e, \"text/html\");else {\n          const g = z(\"div\");\n          g.innerHTML = e;\n          e = {\n            body: g\n          };\n        }\n        const a = (e, d) => {\n          var k = e.nodeName.toLowerCase();\n          const r = {\n            tagName: k\n          };\n          \"#text\" === k && (r.textContent = e.textContent || \"\");\n          if (k = e.attributes) {\n            const d = {};\n            [].forEach.call(k, k => {\n              \"data-style\" === k.name ? r.style = g.parseStyle(k.value) : d[k.name] = k.value;\n            });\n            r.attributes = d;\n          }\n          if (e.childNodes.length) {\n            const d = [];\n            [].forEach.call(e.childNodes, k => {\n              a(k, d);\n            });\n            d.length && (r.children = d);\n          }\n          d.push(r);\n        };\n        [].forEach.call(e.body.childNodes, e => a(e, m));\n        return m;\n      }\n    }\n    g.allowedAttributes = \"alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex\".split(\" \");\n    g.allowedReferences = \"https:// http:// mailto: / ../ ./ #\".split(\" \");\n    g.allowedTags = \"a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text\".split(\" \");\n    g.emptyHTML = y;\n    g.bypassHTMLFiltering = !1;\n    \"\";\n    return g;\n  });\n  M(a, \"Core/Templating.js\", [a[\"Core/Defaults.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    function x(h = \"\", g, e) {\n      const a = /\\{([a-zA-Z0-9:\\.,;\\-\\/<>%_@\"'= #\\(\\)]+)\\}/g,\n        l = /\\(([a-zA-Z0-9:\\.,;\\-\\/<>%_@\"'= ]+)\\)/g,\n        v = [],\n        d = /f$/,\n        k = /\\.([0-9])/,\n        r = C.lang,\n        q = e && e.time || z,\n        G = e && e.numberFormatter || L,\n        b = (b = \"\") => {\n          let c;\n          return \"true\" === b ? !0 : \"false\" === b ? !1 : (c = Number(b)).toString() === b ? c : B(b, g);\n        };\n      let f,\n        c,\n        n = 0,\n        P;\n      for (; null !== (f = a.exec(h));) {\n        const b = l.exec(f[1]);\n        b && (f = b, P = !0);\n        c && c.isBlock || (c = {\n          ctx: g,\n          expression: f[1],\n          find: f[0],\n          isBlock: \"#\" === f[1].charAt(0),\n          start: f.index,\n          startInner: f.index + f[0].length,\n          length: f[0].length\n        });\n        var D = f[1].split(\" \")[0].replace(\"#\", \"\");\n        m[D] && (c.isBlock && D === c.fn && n++, c.fn || (c.fn = D));\n        D = \"else\" === f[1];\n        if (c.isBlock && c.fn && (f[1] === `/${c.fn}` || D)) {\n          if (n) D || n--;else {\n            var K = c.startInner;\n            K = h.substr(K, f.index - K);\n            void 0 === c.body ? (c.body = K, c.startInner = f.index + f[0].length) : c.elseBody = K;\n            c.find += K + f[0];\n            D || (v.push(c), c = void 0);\n          }\n        } else c.isBlock || v.push(c);\n        if (b && (null === c || void 0 === c || !c.isBlock)) break;\n      }\n      v.forEach(c => {\n        const {\n          body: f,\n          elseBody: n,\n          expression: K,\n          fn: e\n        } = c;\n        var A;\n        if (e) {\n          var a = [c],\n            w = K.split(\" \");\n          for (A = m[e].length; A--;) a.unshift(b(w[A + 1]));\n          A = m[e].apply(g, a);\n          c.isBlock && \"boolean\" === typeof A && (A = x(A ? f : n, g));\n        } else a = K.split(\":\"), A = b(a.shift() || \"\"), a.length && \"number\" === typeof A && (a = a.join(\":\"), d.test(a) ? (w = parseInt((a.match(k) || [\"\", \"-1\"])[1], 10), null !== A && (A = G(A, w, r.decimalPoint, -1 < a.indexOf(\",\") ? r.thousandsSep : \"\"))) : A = q.dateFormat(a, A));\n        h = h.replace(c.find, p(A, \"\"));\n      });\n      return P ? x(h, g, e) : h;\n    }\n    function L(h, g, e, a) {\n      h = +h || 0;\n      g = +g;\n      const m = C.lang;\n      var w = (h.toString().split(\".\")[1] || \"\").split(\"e\")[0].length;\n      const d = h.toString().split(\"e\"),\n        k = g;\n      if (-1 === g) g = Math.min(w, 20);else if (!v(g)) g = 2;else if (g && d[1] && 0 > d[1]) {\n        var r = g + +d[1];\n        0 <= r ? (d[0] = (+d[0]).toExponential(r).split(\"e\")[0], g = r) : (d[0] = d[0].split(\".\")[0] || 0, h = 20 > g ? (d[0] * Math.pow(10, d[1])).toFixed(g) : 0, d[1] = 0);\n      }\n      r = (Math.abs(d[1] ? d[0] : h) + Math.pow(10, -Math.max(g, w) - 1)).toFixed(g);\n      w = String(t(r));\n      const q = 3 < w.length ? w.length % 3 : 0;\n      e = p(e, m.decimalPoint);\n      a = p(a, m.thousandsSep);\n      h = (0 > h ? \"-\" : \"\") + (q ? w.substr(0, q) + a : \"\");\n      h = 0 > +d[1] && !k ? \"0\" : h + w.substr(q).replace(/(\\d{3})(?=\\d)/g, \"$1\" + a);\n      g && (h += e + r.slice(-g));\n      d[1] && 0 !== +h && (h += \"e\" + d[1]);\n      return h;\n    }\n    const {\n        defaultOptions: C,\n        defaultTime: z\n      } = a,\n      {\n        extend: H,\n        getNestedProperty: B,\n        isArray: u,\n        isNumber: v,\n        isObject: l,\n        pick: p,\n        pInt: t\n      } = y,\n      m = {\n        add: (h, g) => h + g,\n        divide: (h, g) => 0 !== g ? h / g : \"\",\n        eq: (h, g) => h == g,\n        each: function (h) {\n          const g = arguments[arguments.length - 1];\n          return u(h) ? h.map((e, a) => x(g.body, H(l(e) ? e : {\n            \"@this\": e\n          }, {\n            \"@index\": a,\n            \"@first\": 0 === a,\n            \"@last\": a === h.length - 1\n          }))).join(\"\") : !1;\n        },\n        ge: (h, g) => h >= g,\n        gt: (h, g) => h > g,\n        \"if\": h => !!h,\n        le: (h, g) => h <= g,\n        lt: (h, g) => h < g,\n        multiply: (h, g) => h * g,\n        ne: (h, g) => h != g,\n        subtract: (h, g) => h - g,\n        unless: h => !h\n      };\n    return {\n      dateFormat: function (h, g, e) {\n        return z.dateFormat(h, g, e);\n      },\n      format: x,\n      helpers: m,\n      numberFormat: L\n    };\n  });\n  M(a, \"Core/Renderer/RendererUtilities.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      clamp: x,\n      pick: I,\n      stableSort: L\n    } = a;\n    var C;\n    (function (a) {\n      function y(a, u, v) {\n        const l = a;\n        var p = l.reducedLen || u,\n          t = (e, g) => (g.rank || 0) - (e.rank || 0);\n        const m = (e, g) => e.target - g.target;\n        let h,\n          g = !0,\n          e = [],\n          w = 0;\n        for (h = a.length; h--;) w += a[h].size;\n        if (w > p) {\n          L(a, t);\n          for (w = h = 0; w <= p;) w += a[h].size, h++;\n          e = a.splice(h - 1, a.length);\n        }\n        L(a, m);\n        for (a = a.map(e => ({\n          size: e.size,\n          targets: [e.target],\n          align: I(e.align, .5)\n        })); g;) {\n          for (h = a.length; h--;) p = a[h], t = (Math.min.apply(0, p.targets) + Math.max.apply(0, p.targets)) / 2, p.pos = x(t - p.size * p.align, 0, u - p.size);\n          h = a.length;\n          for (g = !1; h--;) 0 < h && a[h - 1].pos + a[h - 1].size > a[h].pos && (a[h - 1].size += a[h].size, a[h - 1].targets = a[h - 1].targets.concat(a[h].targets), a[h - 1].align = .5, a[h - 1].pos + a[h - 1].size > u && (a[h - 1].pos = u - a[h - 1].size), a.splice(h, 1), g = !0);\n        }\n        l.push.apply(l, e);\n        h = 0;\n        a.some(e => {\n          let g = 0;\n          return (e.targets || []).some(() => {\n            l[h].pos = e.pos + g;\n            if (\"undefined\" !== typeof v && Math.abs(l[h].pos - l[h].target) > v) return l.slice(0, h + 1).forEach(d => delete d.pos), l.reducedLen = (l.reducedLen || u) - .1 * u, l.reducedLen > .1 * u && y(l, u, v), !0;\n            g += l[h].size;\n            h++;\n            return !1;\n          });\n        });\n        L(l, m);\n        return l;\n      }\n      a.distribute = y;\n    })(C || (C = {}));\n    return C;\n  });\n  M(a, \"Core/Renderer/SVG/SVGElement.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L) {\n    const {\n        animate: x,\n        animObject: z,\n        stop: H\n      } = a,\n      {\n        deg2rad: B,\n        doc: u,\n        svg: v,\n        SVG_NS: l,\n        win: p\n      } = I,\n      {\n        addEvent: t,\n        attr: m,\n        createElement: h,\n        css: g,\n        defined: e,\n        erase: w,\n        extend: E,\n        fireEvent: F,\n        isArray: d,\n        isFunction: k,\n        isObject: r,\n        isString: q,\n        merge: G,\n        objectEach: b,\n        pick: f,\n        pInt: c,\n        syncTimeout: n,\n        uniqueKey: P\n      } = L;\n    class D {\n      constructor() {\n        this.element = void 0;\n        this.onEvents = {};\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = l;\n      }\n      _defaultGetter(b) {\n        b = f(this[b + \"Value\"], this[b], this.element ? this.element.getAttribute(b) : null, 0);\n        /^[\\-0-9\\.]+$/.test(b) && (b = parseFloat(b));\n        return b;\n      }\n      _defaultSetter(b, c, f) {\n        f.setAttribute(c, b);\n      }\n      add(b) {\n        const c = this.renderer,\n          f = this.element;\n        let d;\n        b && (this.parentGroup = b);\n        \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && c.buildText(this);\n        this.added = !0;\n        if (!b || b.handleZ || this.zIndex) d = this.zIndexSetter();\n        d || (b ? b.element : c.box).appendChild(f);\n        if (this.onAdd) this.onAdd();\n        return this;\n      }\n      addClass(b, c) {\n        const f = c ? \"\" : this.attr(\"class\") || \"\";\n        b = (b || \"\").split(/ /g).reduce(function (b, c) {\n          -1 === f.indexOf(c) && b.push(c);\n          return b;\n        }, f ? [f] : []).join(\" \");\n        b !== f && this.attr(\"class\", b);\n        return this;\n      }\n      afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      }\n      align(b, c, d) {\n        const k = {};\n        var n = this.renderer,\n          e = n.alignedObjects,\n          A;\n        let K, g;\n        if (b) {\n          if (this.alignOptions = b, this.alignByTranslate = c, !d || q(d)) this.alignTo = A = d || \"renderer\", w(e, this), e.push(this), d = void 0;\n        } else b = this.alignOptions, c = this.alignByTranslate, A = this.alignTo;\n        d = f(d, n[A], \"scrollablePlotBox\" === A ? n.plotBox : void 0, n);\n        A = b.align;\n        const a = b.verticalAlign;\n        n = (d.x || 0) + (b.x || 0);\n        e = (d.y || 0) + (b.y || 0);\n        \"right\" === A ? K = 1 : \"center\" === A && (K = 2);\n        K && (n += (d.width - (b.width || 0)) / K);\n        k[c ? \"translateX\" : \"x\"] = Math.round(n);\n        \"bottom\" === a ? g = 1 : \"middle\" === a && (g = 2);\n        g && (e += (d.height - (b.height || 0)) / g);\n        k[c ? \"translateY\" : \"y\"] = Math.round(e);\n        this[this.placed ? \"animate\" : \"attr\"](k);\n        this.placed = !0;\n        this.alignAttr = k;\n        return this;\n      }\n      alignSetter(b) {\n        const c = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        c[b] && (this.alignValue = b, this.element.setAttribute(\"text-anchor\", c[b]));\n      }\n      animate(c, d, k) {\n        const e = z(f(d, this.renderer.globalAnimation, !0));\n        d = e.defer;\n        u.hidden && (e.duration = 0);\n        0 !== e.duration ? (k && (e.complete = k), n(() => {\n          this.element && x(this, c, e);\n        }, d)) : (this.attr(c, void 0, k || e.complete), b(c, function (b, c) {\n          e.step && e.step.call(this, b, {\n            prop: c,\n            pos: 1,\n            elem: this\n          });\n        }, this));\n        return this;\n      }\n      applyTextOutline(b) {\n        const c = this.element;\n        -1 !== b.indexOf(\"contrast\") && (b = b.replace(/contrast/g, this.renderer.getContrast(c.style.fill)));\n        var f = b.split(\" \");\n        b = f[f.length - 1];\n        if ((f = f[0]) && \"none\" !== f && I.svg) {\n          this.fakeTS = !0;\n          f = f.replace(/(^[\\d\\.]+)(.*?)$/g, function (b, c, f) {\n            return 2 * Number(c) + f;\n          });\n          this.removeTextOutline();\n          const d = u.createElementNS(l, \"tspan\");\n          m(d, {\n            \"class\": \"highcharts-text-outline\",\n            fill: b,\n            stroke: b,\n            \"stroke-width\": f,\n            \"stroke-linejoin\": \"round\"\n          });\n          b = c.querySelector(\"textPath\") || c;\n          [].forEach.call(b.childNodes, b => {\n            const c = b.cloneNode(!0);\n            c.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(b => c.removeAttribute(b));\n            d.appendChild(c);\n          });\n          let k = 0;\n          [].forEach.call(b.querySelectorAll(\"text tspan\"), b => {\n            k += Number(b.getAttribute(\"dy\"));\n          });\n          f = u.createElementNS(l, \"tspan\");\n          f.textContent = \"\\u200b\";\n          m(f, {\n            x: Number(c.getAttribute(\"x\")),\n            dy: -k\n          });\n          d.appendChild(f);\n          b.insertBefore(d, b.firstChild);\n        }\n      }\n      attr(c, f, d, k) {\n        const n = this.element,\n          e = D.symbolCustomAttribs;\n        let A,\n          q,\n          g = this,\n          a,\n          K;\n        \"string\" === typeof c && \"undefined\" !== typeof f && (A = c, c = {}, c[A] = f);\n        \"string\" === typeof c ? g = (this[c + \"Getter\"] || this._defaultGetter).call(this, c, n) : (b(c, function (b, f) {\n          a = !1;\n          k || H(this, f);\n          this.symbolName && -1 !== e.indexOf(f) && (q || (this.symbolAttr(c), q = !0), a = !0);\n          !this.rotation || \"x\" !== f && \"y\" !== f || (this.doTransform = !0);\n          a || (K = this[f + \"Setter\"] || this._defaultSetter, K.call(this, b, f, n));\n        }, this), this.afterSetters());\n        d && d.call(this);\n        return g;\n      }\n      clip(b) {\n        return this.attr(\"clip-path\", b ? \"url(\" + this.renderer.url + \"#\" + b.id + \")\" : \"none\");\n      }\n      crisp(b, c) {\n        c = c || b.strokeWidth || 0;\n        const f = Math.round(c) % 2 / 2;\n        b.x = Math.floor(b.x || this.x || 0) + f;\n        b.y = Math.floor(b.y || this.y || 0) + f;\n        b.width = Math.floor((b.width || this.width || 0) - 2 * f);\n        b.height = Math.floor((b.height || this.height || 0) - 2 * f);\n        e(b.strokeWidth) && (b.strokeWidth = c);\n        return b;\n      }\n      complexColor(c, f, k) {\n        const n = this.renderer;\n        let q,\n          g,\n          A,\n          a,\n          r,\n          K,\n          h,\n          J,\n          m,\n          O,\n          w = [],\n          l;\n        F(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          c.radialGradient ? g = \"radialGradient\" : c.linearGradient && (g = \"linearGradient\");\n          if (g) {\n            A = c[g];\n            r = n.gradients;\n            K = c.stops;\n            m = k.radialReference;\n            d(A) && (c[g] = A = {\n              x1: A[0],\n              y1: A[1],\n              x2: A[2],\n              y2: A[3],\n              gradientUnits: \"userSpaceOnUse\"\n            });\n            \"radialGradient\" === g && m && !e(A.gradientUnits) && (a = A, A = G(A, n.getRadialAttr(m, a), {\n              gradientUnits: \"userSpaceOnUse\"\n            }));\n            b(A, function (b, c) {\n              \"id\" !== c && w.push(c, b);\n            });\n            b(K, function (b) {\n              w.push(b);\n            });\n            w = w.join(\",\");\n            if (r[w]) O = r[w].attr(\"id\");else {\n              A.id = O = P();\n              const b = r[w] = n.createElement(g).attr(A).add(n.defs);\n              b.radAttr = a;\n              b.stops = [];\n              K.forEach(function (c) {\n                0 === c[1].indexOf(\"rgba\") ? (q = y.parse(c[1]), h = q.get(\"rgb\"), J = q.get(\"a\")) : (h = c[1], J = 1);\n                c = n.createElement(\"stop\").attr({\n                  offset: c[0],\n                  \"stop-color\": h,\n                  \"stop-opacity\": J\n                }).add(b);\n                b.stops.push(c);\n              });\n            }\n            l = \"url(\" + n.url + \"#\" + O + \")\";\n            k.setAttribute(f, l);\n            k.gradient = w;\n            c.toString = function () {\n              return l;\n            };\n          }\n        });\n      }\n      css(f) {\n        const d = this.styles,\n          k = {},\n          n = this.element;\n        let e,\n          q = !d;\n        d && b(f, function (b, c) {\n          d && d[c] !== b && (k[c] = b, q = !0);\n        });\n        if (q) {\n          d && (f = E(d, k));\n          null === f.width || \"auto\" === f.width ? delete this.textWidth : \"text\" === n.nodeName.toLowerCase() && f.width && (e = this.textWidth = c(f.width));\n          this.styles = f;\n          e && !v && this.renderer.forExport && delete f.width;\n          const b = G(f);\n          n.namespaceURI === this.SVG_NS && ([\"textOutline\", \"textOverflow\", \"width\"].forEach(c => b && delete b[c]), b.color && (b.fill = b.color));\n          g(n, b);\n        }\n        this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), f.textOutline && this.applyTextOutline(f.textOutline));\n        return this;\n      }\n      dashstyleSetter(b) {\n        let d = this[\"stroke-width\"];\n        \"inherit\" === d && (d = 1);\n        if (b = b && b.toLowerCase()) {\n          const k = b.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n          for (b = k.length; b--;) k[b] = \"\" + c(k[b]) * f(d, NaN);\n          b = k.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", b);\n        }\n      }\n      destroy() {\n        const c = this;\n        var f = c.element || {};\n        const d = c.renderer;\n        var k = f.ownerSVGElement;\n        let n = \"SPAN\" === f.nodeName && c.parentGroup || void 0;\n        f.onclick = f.onmouseout = f.onmouseover = f.onmousemove = f.point = null;\n        H(c);\n        if (c.clipPath && k) {\n          const b = c.clipPath;\n          [].forEach.call(k.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (c) {\n            -1 < c.getAttribute(\"clip-path\").indexOf(b.element.id) && c.removeAttribute(\"clip-path\");\n          });\n          c.clipPath = b.destroy();\n        }\n        if (c.stops) {\n          for (k = 0; k < c.stops.length; k++) c.stops[k].destroy();\n          c.stops.length = 0;\n          c.stops = void 0;\n        }\n        for (c.safeRemoveChild(f); n && n.div && 0 === n.div.childNodes.length;) f = n.parentGroup, c.safeRemoveChild(n.div), delete n.div, n = f;\n        c.alignTo && w(d.alignedObjects, c);\n        b(c, function (b, f) {\n          c[f] && c[f].parentGroup === c && c[f].destroy && c[f].destroy();\n          delete c[f];\n        });\n      }\n      dSetter(b, c, f) {\n        d(b) && (\"string\" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce((b, c, f) => c && c.join ? (f ? b + \" \" : \"\") + c.join(\" \") : (c || \"\").toString(), \"\"));\n        /(NaN| {2}|^$)/.test(b) && (b = \"M 0 0\");\n        this[c] !== b && (f.setAttribute(c, b), this[c] = b);\n      }\n      fadeOut(b) {\n        const c = this;\n        c.animate({\n          opacity: 0\n        }, {\n          duration: f(b, 150),\n          complete: function () {\n            c.hide();\n          }\n        });\n      }\n      fillSetter(b, c, f) {\n        \"string\" === typeof b ? f.setAttribute(c, b) : b && this.complexColor(b, c, f);\n      }\n      getBBox(b, c) {\n        const {\n            alignValue: d,\n            element: n,\n            renderer: q,\n            styles: a,\n            textStr: A\n          } = this,\n          {\n            cache: r,\n            cacheKeys: h\n          } = q;\n        var m = n.namespaceURI === this.SVG_NS;\n        c = f(c, this.rotation, 0);\n        var K = q.styledMode ? n && D.prototype.getStyle.call(n, \"font-size\") : a && a.fontSize;\n        let J;\n        let N;\n        e(A) && (N = A.toString(), -1 === N.indexOf(\"<\") && (N = N.replace(/[0-9]/g, \"0\")), N += [\"\", q.rootFontSize, K, c, this.textWidth, d, a && a.textOverflow, a && a.fontWeight].join());\n        N && !b && (J = r[N]);\n        if (!J) {\n          if (m || q.forExport) {\n            try {\n              var O = this.fakeTS && function (b) {\n                const c = n.querySelector(\".highcharts-text-outline\");\n                c && g(c, {\n                  display: b\n                });\n              };\n              k(O) && O(\"none\");\n              J = n.getBBox ? E({}, n.getBBox()) : {\n                width: n.offsetWidth,\n                height: n.offsetHeight,\n                x: 0,\n                y: 0\n              };\n              k(O) && O(\"\");\n            } catch (fa) {\n              \"\";\n            }\n            if (!J || 0 > J.width) J = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n          } else J = this.htmlGetBBox();\n          O = J.width;\n          b = J.height;\n          m && (J.height = b = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[`${K || \"\"},${Math.round(b)}`] || b);\n          if (c) {\n            m = Number(n.getAttribute(\"y\") || 0) - J.y;\n            K = {\n              right: 1,\n              center: .5\n            }[d || 0] || 0;\n            var w = c * B,\n              l = (c - 90) * B,\n              p = O * Math.cos(w);\n            c = O * Math.sin(w);\n            var G = Math.cos(l);\n            w = Math.sin(l);\n            O = J.x + K * (O - p) + m * G;\n            l = O + p;\n            G = l - b * G;\n            p = G - p;\n            m = J.y + m - K * c + m * w;\n            K = m + c;\n            b = K - b * w;\n            c = b - c;\n            J.x = Math.min(O, l, G, p);\n            J.y = Math.min(m, K, b, c);\n            J.width = Math.max(O, l, G, p) - J.x;\n            J.height = Math.max(m, K, b, c) - J.y;\n          }\n        }\n        if (N && (\"\" === A || 0 < J.height)) {\n          for (; 250 < h.length;) delete r[h.shift()];\n          r[N] || h.push(N);\n          r[N] = J;\n        }\n        return J;\n      }\n      getStyle(b) {\n        return p.getComputedStyle(this.element || this, \"\").getPropertyValue(b);\n      }\n      hasClass(b) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(b);\n      }\n      hide() {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      }\n      htmlGetBBox() {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      }\n      init(b, c) {\n        this.element = \"span\" === c ? h(c) : u.createElementNS(this.SVG_NS, c);\n        this.renderer = b;\n        F(this, \"afterInit\");\n      }\n      on(b, c) {\n        const {\n          onEvents: f\n        } = this;\n        if (f[b]) f[b]();\n        f[b] = t(this.element, b, c);\n        return this;\n      }\n      opacitySetter(b, c, f) {\n        this.opacity = b = Number(Number(b).toFixed(3));\n        f.setAttribute(c, b);\n      }\n      removeClass(b) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(q(b) ? new RegExp(`(^| )${b}( |$)`) : b, \" \").replace(/ +/g, \" \").trim());\n      }\n      removeTextOutline() {\n        const b = this.element.querySelector(\"tspan.highcharts-text-outline\");\n        b && this.safeRemoveChild(b);\n      }\n      safeRemoveChild(b) {\n        const c = b.parentNode;\n        c && c.removeChild(b);\n      }\n      setRadialReference(b) {\n        const c = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = b;\n        c && c.radAttr && c.animate(this.renderer.getRadialAttr(b, c.radAttr));\n        return this;\n      }\n      setTextPath(b, c) {\n        c = G(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, c);\n        const f = this.renderer.url,\n          d = this.text || this,\n          k = d.textPath,\n          {\n            attributes: n,\n            enabled: A\n          } = c;\n        b = b || k && k.path;\n        k && k.undo();\n        b && A ? (c = t(d, \"afterModifyTree\", c => {\n          if (b && A) {\n            let A = b.attr(\"id\");\n            A || b.attr(\"id\", A = P());\n            var k = {\n              x: 0,\n              y: 0\n            };\n            e(n.dx) && (k.dx = n.dx, delete n.dx);\n            e(n.dy) && (k.dy = n.dy, delete n.dy);\n            d.attr(k);\n            this.attr({\n              transform: \"\"\n            });\n            this.box && (this.box = this.box.destroy());\n            k = c.nodes.slice(0);\n            c.nodes.length = 0;\n            c.nodes[0] = {\n              tagName: \"textPath\",\n              attributes: E(n, {\n                \"text-anchor\": n.textAnchor,\n                href: `${f}#${A}`\n              }),\n              children: k\n            };\n          }\n        }), d.textPath = {\n          path: b,\n          undo: c\n        }) : (d.attr({\n          dx: 0,\n          dy: 0\n        }), delete d.textPath);\n        this.added && (d.textCache = \"\", this.renderer.buildText(d));\n        return this;\n      }\n      shadow(b) {\n        var c;\n        const {\n            renderer: f\n          } = this,\n          d = G(90 === (null === (c = this.parentGroup) || void 0 === c ? void 0 : c.rotation) ? {\n            offsetX: -1,\n            offsetY: -1\n          } : {}, r(b) ? b : {});\n        c = f.shadowDefinition(d);\n        return this.attr({\n          filter: b ? `url(${f.url}#${c})` : \"none\"\n        });\n      }\n      show(b = !0) {\n        return this.attr({\n          visibility: b ? \"inherit\" : \"visible\"\n        });\n      }\n      [\"stroke-widthSetter\"](b, c, f) {\n        this[c] = b;\n        f.setAttribute(c, b);\n      }\n      strokeWidth() {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        const b = this.getStyle(\"stroke-width\");\n        let f = 0,\n          d;\n        b.indexOf(\"px\") === b.length - 2 ? f = c(b) : \"\" !== b && (d = u.createElementNS(l, \"rect\"), m(d, {\n          width: b,\n          \"stroke-width\": 0\n        }), this.element.parentNode.appendChild(d), f = d.getBBox().width, d.parentNode.removeChild(d));\n        return f;\n      }\n      symbolAttr(b) {\n        const c = this;\n        D.symbolCustomAttribs.forEach(function (d) {\n          c[d] = f(b[d], c[d]);\n        });\n        c.attr({\n          d: c.renderer.symbols[c.symbolName](c.x, c.y, c.width, c.height, c)\n        });\n      }\n      textSetter(b) {\n        b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));\n      }\n      titleSetter(b) {\n        const c = this.element,\n          d = c.getElementsByTagName(\"title\")[0] || u.createElementNS(this.SVG_NS, \"title\");\n        c.insertBefore ? c.insertBefore(d, c.firstChild) : c.appendChild(d);\n        d.textContent = String(f(b, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n      }\n      toFront() {\n        const b = this.element;\n        b.parentNode.appendChild(b);\n        return this;\n      }\n      translate(b, c) {\n        return this.attr({\n          translateX: b,\n          translateY: c\n        });\n      }\n      updateTransform() {\n        const {\n            element: b,\n            matrix: c,\n            rotation: d = 0,\n            scaleX: k,\n            scaleY: n,\n            translateX: q = 0,\n            translateY: A = 0\n          } = this,\n          g = [\"translate(\" + q + \",\" + A + \")\"];\n        e(c) && g.push(\"matrix(\" + c.join(\",\") + \")\");\n        d && g.push(\"rotate(\" + d + \" \" + f(this.rotationOriginX, b.getAttribute(\"x\"), 0) + \" \" + f(this.rotationOriginY, b.getAttribute(\"y\") || 0) + \")\");\n        (e(k) || e(n)) && g.push(\"scale(\" + f(k, 1) + \" \" + f(n, 1) + \")\");\n        g.length && !(this.text || this).textPath && b.setAttribute(\"transform\", g.join(\" \"));\n      }\n      visibilitySetter(b, c, f) {\n        \"inherit\" === b ? f.removeAttribute(c) : this[c] !== b && f.setAttribute(c, b);\n        this[c] = b;\n      }\n      xGetter(b) {\n        \"circle\" === this.element.nodeName && (\"x\" === b ? b = \"cx\" : \"y\" === b && (b = \"cy\"));\n        return this._defaultGetter(b);\n      }\n      zIndexSetter(b, f) {\n        var d = this.renderer,\n          k = this.parentGroup;\n        const n = (k || d).element || d.box,\n          q = this.element;\n        d = n === d.box;\n        let A = !1,\n          g;\n        var a = this.added;\n        let r;\n        e(b) ? (q.setAttribute(\"data-z-index\", b), b = +b, this[f] === b && (a = !1)) : e(this[f]) && q.removeAttribute(\"data-z-index\");\n        this[f] = b;\n        if (a) {\n          (b = this.zIndex) && k && (k.handleZ = !0);\n          f = n.childNodes;\n          for (r = f.length - 1; 0 <= r && !A; r--) if (k = f[r], a = k.getAttribute(\"data-z-index\"), g = !e(a), k !== q) if (0 > b && g && !d && !r) n.insertBefore(q, f[r]), A = !0;else if (c(a) <= b || g && (!e(b) || 0 <= b)) n.insertBefore(q, f[r + 1]), A = !0;\n          A || (n.insertBefore(q, f[d ? 3 : 0]), A = !0);\n        }\n        return A;\n      }\n    }\n    D.symbolCustomAttribs = \"anchorX anchorY clockwise end height innerR r start width x y\".split(\" \");\n    D.prototype.strokeSetter = D.prototype.fillSetter;\n    D.prototype.yGetter = D.prototype.xGetter;\n    D.prototype.matrixSetter = D.prototype.rotationOriginXSetter = D.prototype.rotationOriginYSetter = D.prototype.rotationSetter = D.prototype.scaleXSetter = D.prototype.scaleYSetter = D.prototype.translateXSetter = D.prototype.translateYSetter = D.prototype.verticalAlignSetter = function (b, c) {\n      this[c] = b;\n      this.doTransform = !0;\n    };\n    \"\";\n    return D;\n  });\n  M(a, \"Core/Renderer/RendererRegistry.js\", [a[\"Core/Globals.js\"]], function (a) {\n    var x;\n    (function (x) {\n      x.rendererTypes = {};\n      let y;\n      x.getRendererType = function (a = y) {\n        return x.rendererTypes[a] || x.rendererTypes[y];\n      };\n      x.registerRendererType = function (C, z, H) {\n        x.rendererTypes[C] = z;\n        if (!y || H) y = C, a.Renderer = z;\n      };\n    })(x || (x = {}));\n    return x;\n  });\n  M(a, \"Core/Renderer/SVG/SVGLabel.js\", [a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n      defined: x,\n      extend: L,\n      isNumber: C,\n      merge: z,\n      pick: H,\n      removeEvent: B\n    } = y;\n    class u extends a {\n      constructor(a, l, p, t, m, h, g, e, w, E) {\n        super();\n        this.paddingRightSetter = this.paddingLeftSetter = this.paddingSetter;\n        this.init(a, \"g\");\n        this.textStr = l;\n        this.x = p;\n        this.y = t;\n        this.anchorX = h;\n        this.anchorY = g;\n        this.baseline = w;\n        this.className = E;\n        this.addClass(\"button\" === E ? \"highcharts-no-tooltip\" : \"highcharts-label\");\n        E && this.addClass(\"highcharts-\" + E);\n        this.text = a.text(void 0, 0, 0, e).attr({\n          zIndex: 1\n        });\n        let v;\n        \"string\" === typeof m && ((v = /^url\\((.*?)\\)$/.test(m)) || this.renderer.symbols[m]) && (this.symbolKey = m);\n        this.bBox = u.emptyBBox;\n        this.padding = 3;\n        this.baselineOffset = 0;\n        this.needsBox = a.styledMode || v;\n        this.deferredAttr = {};\n        this.alignFactor = 0;\n      }\n      alignSetter(a) {\n        a = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[a];\n        a !== this.alignFactor && (this.alignFactor = a, this.bBox && C(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      }\n      anchorXSetter(a, l) {\n        this.anchorX = a;\n        this.boxAttr(l, Math.round(a) - this.getCrispAdjust() - this.xSetting);\n      }\n      anchorYSetter(a, l) {\n        this.anchorY = a;\n        this.boxAttr(l, a - this.ySetting);\n      }\n      boxAttr(a, l) {\n        this.box ? this.box.attr(a, l) : this.deferredAttr[a] = l;\n      }\n      css(v) {\n        if (v) {\n          const a = {};\n          v = z(v);\n          u.textProps.forEach(l => {\n            \"undefined\" !== typeof v[l] && (a[l] = v[l], delete v[l]);\n          });\n          this.text.css(a);\n          \"fontSize\" in a || \"fontWeight\" in a ? this.updateTextPadding() : (\"width\" in a || \"textOverflow\" in a) && this.updateBoxSize();\n        }\n        return a.prototype.css.call(this, v);\n      }\n      destroy() {\n        B(this.element, \"mouseenter\");\n        B(this.element, \"mouseleave\");\n        this.text && this.text.destroy();\n        this.box && (this.box = this.box.destroy());\n        a.prototype.destroy.call(this);\n      }\n      fillSetter(a, l) {\n        a && (this.needsBox = !0);\n        this.fill = a;\n        this.boxAttr(l, a);\n      }\n      getBBox() {\n        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n        const a = this.padding,\n          l = H(this.paddingLeft, a);\n        return {\n          width: this.width,\n          height: this.height,\n          x: this.bBox.x - l,\n          y: this.bBox.y - a\n        };\n      }\n      getCrispAdjust() {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      }\n      heightSetter(a) {\n        this.heightSetting = a;\n      }\n      onAdd() {\n        this.text.add(this);\n        this.attr({\n          text: H(this.textStr, \"\"),\n          x: this.x || 0,\n          y: this.y || 0\n        });\n        this.box && x(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      }\n      paddingSetter(a, l) {\n        C(a) ? a !== this[l] && (this[l] = a, this.updateTextPadding()) : this[l] = void 0;\n      }\n      rSetter(a, l) {\n        this.boxAttr(l, a);\n      }\n      strokeSetter(a, l) {\n        this.stroke = a;\n        this.boxAttr(l, a);\n      }\n      [\"stroke-widthSetter\"](a, l) {\n        a && (this.needsBox = !0);\n        this[\"stroke-width\"] = a;\n        this.boxAttr(l, a);\n      }\n      [\"text-alignSetter\"](a) {\n        this.textAlign = a;\n      }\n      textSetter(a) {\n        \"undefined\" !== typeof a && this.text.attr({\n          text: a\n        });\n        this.updateTextPadding();\n      }\n      updateBoxSize() {\n        var a = this.text;\n        const l = {},\n          p = this.padding,\n          t = this.bBox = C(this.widthSetting) && C(this.heightSetting) && !this.textAlign || !x(a.textStr) ? u.emptyBBox : a.getBBox();\n        this.width = this.getPaddedWidth();\n        this.height = (this.heightSetting || t.height || 0) + 2 * p;\n        const m = this.renderer.fontMetrics(a);\n        this.baselineOffset = p + Math.min((this.text.firstLineMetrics || m).b, t.height || Infinity);\n        this.heightSetting && (this.baselineOffset += (this.heightSetting - m.h) / 2);\n        this.needsBox && !a.textPath && (this.box || (a = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), a.add(this)), a = this.getCrispAdjust(), l.x = a, l.y = (this.baseline ? -this.baselineOffset : 0) + a, l.width = Math.round(this.width), l.height = Math.round(this.height), this.box.attr(L(l, this.deferredAttr)), this.deferredAttr = {});\n      }\n      updateTextPadding() {\n        const a = this.text;\n        if (!a.textPath) {\n          this.updateBoxSize();\n          const l = this.baseline ? 0 : this.baselineOffset;\n          let p = H(this.paddingLeft, this.padding);\n          x(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (p += {\n            center: .5,\n            right: 1\n          }[this.textAlign] * (this.widthSetting - this.bBox.width));\n          if (p !== a.x || l !== a.y) a.attr(\"x\", p), a.hasBoxWidthChanged && (this.bBox = a.getBBox(!0)), \"undefined\" !== typeof l && a.attr(\"y\", l);\n          a.x = p;\n          a.y = l;\n        }\n      }\n      widthSetter(a) {\n        this.widthSetting = C(a) ? a : void 0;\n      }\n      getPaddedWidth() {\n        var a = this.padding;\n        const l = H(this.paddingLeft, a);\n        a = H(this.paddingRight, a);\n        return (this.widthSetting || this.bBox.width || 0) + l + a;\n      }\n      xSetter(a) {\n        this.x = a;\n        this.alignFactor && (a -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0);\n        this.xSetting = Math.round(a);\n        this.attr(\"translateX\", this.xSetting);\n      }\n      ySetter(a) {\n        this.ySetting = this.y = Math.round(a);\n        this.attr(\"translateY\", this.ySetting);\n      }\n    }\n    u.emptyBBox = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    };\n    u.textProps = \"color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width\".split(\" \");\n    return u;\n  });\n  M(a, \"Core/Renderer/SVG/Symbols.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    function x(a, u, v, l, p) {\n      const t = [];\n      if (p) {\n        const m = p.start || 0,\n          h = H(p.r, v);\n        v = H(p.r, l || v);\n        l = (p.end || 0) - .001;\n        const g = p.innerR,\n          e = H(p.open, .001 > Math.abs((p.end || 0) - m - 2 * Math.PI)),\n          w = Math.cos(m),\n          E = Math.sin(m),\n          F = Math.cos(l),\n          d = Math.sin(l),\n          k = H(p.longArc, .001 > l - m - Math.PI ? 0 : 1);\n        let r = [\"A\", h, v, 0, k, H(p.clockwise, 1), a + h * F, u + v * d];\n        r.params = {\n          start: m,\n          end: l,\n          cx: a,\n          cy: u\n        };\n        t.push([\"M\", a + h * w, u + v * E], r);\n        C(g) && (r = [\"A\", g, g, 0, k, C(p.clockwise) ? 1 - p.clockwise : 0, a + g * w, u + g * E], r.params = {\n          start: l,\n          end: m,\n          cx: a,\n          cy: u\n        }, t.push(e ? [\"M\", a + g * F, u + g * d] : [\"L\", a + g * F, u + g * d], r));\n        e || t.push([\"Z\"]);\n      }\n      return t;\n    }\n    function I(a, u, v, l, p) {\n      return p && p.r ? L(a, u, v, l, p) : [[\"M\", a, u], [\"L\", a + v, u], [\"L\", a + v, u + l], [\"L\", a, u + l], [\"Z\"]];\n    }\n    function L(a, u, v, l, p) {\n      p = (null === p || void 0 === p ? void 0 : p.r) || 0;\n      return [[\"M\", a + p, u], [\"L\", a + v - p, u], [\"A\", p, p, 0, 0, 1, a + v, u + p], [\"L\", a + v, u + l - p], [\"A\", p, p, 0, 0, 1, a + v - p, u + l], [\"L\", a + p, u + l], [\"A\", p, p, 0, 0, 1, a, u + l - p], [\"L\", a, u + p], [\"A\", p, p, 0, 0, 1, a + p, u], [\"Z\"]];\n    }\n    const {\n      defined: C,\n      isNumber: z,\n      pick: H\n    } = a;\n    return {\n      arc: x,\n      callout: function (a, u, v, l, p) {\n        const t = Math.min(p && p.r || 0, v, l),\n          m = t + 6,\n          h = p && p.anchorX;\n        p = p && p.anchorY || 0;\n        const g = L(a, u, v, l, {\n          r: t\n        });\n        if (!z(h)) return g;\n        a + h >= v ? p > u + m && p < u + l - m ? g.splice(3, 1, [\"L\", a + v, p - 6], [\"L\", a + v + 6, p], [\"L\", a + v, p + 6], [\"L\", a + v, u + l - t]) : g.splice(3, 1, [\"L\", a + v, l / 2], [\"L\", h, p], [\"L\", a + v, l / 2], [\"L\", a + v, u + l - t]) : 0 >= a + h ? p > u + m && p < u + l - m ? g.splice(7, 1, [\"L\", a, p + 6], [\"L\", a - 6, p], [\"L\", a, p - 6], [\"L\", a, u + t]) : g.splice(7, 1, [\"L\", a, l / 2], [\"L\", h, p], [\"L\", a, l / 2], [\"L\", a, u + t]) : p && p > l && h > a + m && h < a + v - m ? g.splice(5, 1, [\"L\", h + 6, u + l], [\"L\", h, u + l + 6], [\"L\", h - 6, u + l], [\"L\", a + t, u + l]) : p && 0 > p && h > a + m && h < a + v - m && g.splice(1, 1, [\"L\", h - 6, u], [\"L\", h, u - 6], [\"L\", h + 6, u], [\"L\", v - t, u]);\n        return g;\n      },\n      circle: function (a, u, v, l) {\n        return x(a + v / 2, u + l / 2, v / 2, l / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function (a, u, v, l) {\n        return [[\"M\", a + v / 2, u], [\"L\", a + v, u + l / 2], [\"L\", a + v / 2, u + l], [\"L\", a, u + l / 2], [\"Z\"]];\n      },\n      rect: I,\n      roundedRect: L,\n      square: I,\n      triangle: function (a, u, v, l) {\n        return [[\"M\", a + v / 2, u], [\"L\", a + v, u + l], [\"L\", a, u + l], [\"Z\"]];\n      },\n      \"triangle-down\": function (a, u, v, l) {\n        return [[\"M\", a, u], [\"L\", a + v, u], [\"L\", a + v / 2, u + l], [\"Z\"]];\n      }\n    };\n  });\n  M(a, \"Core/Renderer/SVG/TextBuilder.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        doc: x,\n        SVG_NS: C,\n        win: z\n      } = y,\n      {\n        attr: H,\n        extend: B,\n        fireEvent: u,\n        isString: v,\n        objectEach: l,\n        pick: p\n      } = I;\n    class t {\n      constructor(a) {\n        const h = a.styles;\n        this.renderer = a.renderer;\n        this.svgElement = a;\n        this.width = a.textWidth;\n        this.textLineHeight = h && h.lineHeight;\n        this.textOutline = h && h.textOutline;\n        this.ellipsis = !(!h || \"ellipsis\" !== h.textOverflow);\n        this.noWrap = !(!h || \"nowrap\" !== h.whiteSpace);\n      }\n      buildSVG() {\n        const m = this.svgElement,\n          h = m.element;\n        var g = m.renderer,\n          e = p(m.textStr, \"\").toString();\n        const w = -1 !== e.indexOf(\"<\"),\n          l = h.childNodes;\n        g = !m.added && g.box;\n        const t = /<br.*?>/g;\n        var d = [e, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, m.getStyle(\"font-size\"), this.width].join();\n        if (d !== m.textCache) {\n          m.textCache = d;\n          delete m.actualWidth;\n          for (d = l.length; d--;) h.removeChild(l[d]);\n          w || this.ellipsis || this.width || m.textPath || -1 !== e.indexOf(\" \") && (!this.noWrap || t.test(e)) ? \"\" !== e && (g && g.appendChild(h), e = new a(e), this.modifyTree(e.nodes), e.addToDOM(h), this.modifyDOM(), this.ellipsis && -1 !== (h.textContent || \"\").indexOf(\"\\u2026\") && m.attr(\"title\", this.unescapeEntities(m.textStr || \"\", [\"&lt;\", \"&gt;\"])), g && g.removeChild(h)) : h.appendChild(x.createTextNode(this.unescapeEntities(e)));\n          v(this.textOutline) && m.applyTextOutline && m.applyTextOutline(this.textOutline);\n        }\n      }\n      modifyDOM() {\n        const a = this.svgElement,\n          h = H(a.element, \"x\");\n        a.firstLineMetrics = void 0;\n        let g;\n        for (; g = a.element.firstChild;) if (/^[\\s\\u200B]*$/.test(g.textContent || \" \")) a.element.removeChild(g);else break;\n        [].forEach.call(a.element.querySelectorAll(\"tspan.highcharts-br\"), (e, d) => {\n          e.nextSibling && e.previousSibling && (0 === d && 1 === e.previousSibling.nodeType && (a.firstLineMetrics = a.renderer.fontMetrics(e.previousSibling)), H(e, {\n            dy: this.getLineHeight(e.nextSibling),\n            x: h\n          }));\n        });\n        const e = this.width || 0;\n        if (e) {\n          var w = (g, d) => {\n              var k = g.textContent || \"\";\n              const r = k.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n              var q = !this.noWrap && (1 < r.length || 1 < a.element.childNodes.length);\n              const m = this.getLineHeight(d);\n              let b = 0,\n                f = a.actualWidth;\n              if (this.ellipsis) k && this.truncate(g, k, void 0, 0, Math.max(0, e - .8 * m), (b, f) => b.substring(0, f) + \"\\u2026\");else if (q) {\n                k = [];\n                for (q = []; d.firstChild && d.firstChild !== g;) q.push(d.firstChild), d.removeChild(d.firstChild);\n                for (; r.length;) r.length && !this.noWrap && 0 < b && (k.push(g.textContent || \"\"), g.textContent = r.join(\" \").replace(/- /g, \"-\")), this.truncate(g, void 0, r, 0 === b ? f || 0 : 0, e, (b, f) => r.slice(0, f).join(\" \").replace(/- /g, \"-\")), f = a.actualWidth, b++;\n                q.forEach(b => {\n                  d.insertBefore(b, g);\n                });\n                k.forEach(b => {\n                  d.insertBefore(x.createTextNode(b), g);\n                  b = x.createElementNS(C, \"tspan\");\n                  b.textContent = \"\\u200b\";\n                  H(b, {\n                    dy: m,\n                    x: h\n                  });\n                  d.insertBefore(b, g);\n                });\n              }\n            },\n            l = e => {\n              [].slice.call(e.childNodes).forEach(d => {\n                d.nodeType === z.Node.TEXT_NODE ? w(d, e) : (-1 !== d.className.baseVal.indexOf(\"highcharts-br\") && (a.actualWidth = 0), l(d));\n              });\n            };\n          l(a.element);\n        }\n      }\n      getLineHeight(a) {\n        a = a.nodeType === z.Node.TEXT_NODE ? a.parentElement : a;\n        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a || this.svgElement.element).h;\n      }\n      modifyTree(a) {\n        const h = (g, e) => {\n          const {\n              attributes: m = {},\n              children: l,\n              style: p = {},\n              tagName: d\n            } = g,\n            k = this.renderer.styledMode;\n          if (\"b\" === d || \"strong\" === d) k ? m[\"class\"] = \"highcharts-strong\" : p.fontWeight = \"bold\";else if (\"i\" === d || \"em\" === d) k ? m[\"class\"] = \"highcharts-emphasized\" : p.fontStyle = \"italic\";\n          p && p.color && (p.fill = p.color);\n          \"br\" === d ? (m[\"class\"] = \"highcharts-br\", g.textContent = \"\\u200b\", (e = a[e + 1]) && e.textContent && (e.textContent = e.textContent.replace(/^ +/gm, \"\"))) : \"a\" === d && l && l.some(d => \"#text\" === d.tagName) && (g.children = [{\n            children: l,\n            tagName: \"tspan\"\n          }]);\n          \"#text\" !== d && \"a\" !== d && (g.tagName = \"tspan\");\n          B(g, {\n            attributes: m,\n            style: p\n          });\n          l && l.filter(d => \"#text\" !== d.tagName).forEach(h);\n        };\n        a.forEach(h);\n        u(this.svgElement, \"afterModifyTree\", {\n          nodes: a\n        });\n      }\n      truncate(a, h, g, e, l, p) {\n        const m = this.svgElement,\n          {\n            rotation: d\n          } = m,\n          k = [];\n        let r = g ? 1 : 0,\n          q = (h || g || \"\").length,\n          w = q,\n          b,\n          f;\n        const c = function (b, c) {\n          b = c || b;\n          if ((c = a.parentNode) && \"undefined\" === typeof k[b] && c.getSubStringLength) try {\n            k[b] = e + c.getSubStringLength(0, g ? b + 1 : b);\n          } catch (D) {\n            \"\";\n          }\n          return k[b];\n        };\n        m.rotation = 0;\n        f = c(a.textContent.length);\n        if (e + f > l) {\n          for (; r <= q;) w = Math.ceil((r + q) / 2), g && (b = p(g, w)), f = c(w, b && b.length - 1), r === q ? r = q + 1 : f > l ? q = w - 1 : r = w;\n          0 === q ? a.textContent = \"\" : h && q === h.length - 1 || (a.textContent = b || p(h || g, w));\n        }\n        g && g.splice(0, w);\n        m.actualWidth = f;\n        m.rotation = d;\n      }\n      unescapeEntities(a, h) {\n        l(this.renderer.escapes, function (g, e) {\n          h && -1 !== h.indexOf(g) || (a = a.toString().replace(new RegExp(g, \"g\"), e));\n        });\n        return a;\n      }\n    }\n    return t;\n  });\n  M(a, \"Core/Renderer/SVG/SVGRenderer.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGLabel.js\"], a[\"Core/Renderer/SVG/Symbols.js\"], a[\"Core/Renderer/SVG/TextBuilder.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z, H, B, u) {\n    const {\n        charts: v,\n        deg2rad: l,\n        doc: p,\n        isFirefox: t,\n        isMS: m,\n        isWebKit: h,\n        noop: g,\n        SVG_NS: e,\n        symbolSizes: w,\n        win: E\n      } = I,\n      {\n        addEvent: F,\n        attr: d,\n        createElement: k,\n        css: r,\n        defined: q,\n        destroyObjectProperties: G,\n        extend: b,\n        isArray: f,\n        isNumber: c,\n        isObject: n,\n        isString: P,\n        merge: D,\n        pick: K,\n        pInt: x,\n        uniqueKey: T\n      } = u;\n    let Z;\n    class V {\n      constructor(b, c, f, d, a, k, n) {\n        this.width = this.url = this.style = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(b, c, f, d, a, k, n);\n      }\n      init(b, c, f, a, k, n, J) {\n        const A = this.createElement(\"svg\").attr({\n            version: \"1.1\",\n            \"class\": \"highcharts-root\"\n          }),\n          e = A.element;\n        J || A.css(this.getStyle(a));\n        b.appendChild(e);\n        d(b, \"dir\", \"ltr\");\n        -1 === b.innerHTML.indexOf(\"xmlns\") && d(e, \"xmlns\", this.SVG_NS);\n        this.box = e;\n        this.boxWrapper = A;\n        this.alignedObjects = [];\n        this.url = this.getReferenceURL();\n        this.createElement(\"desc\").add().element.appendChild(p.createTextNode(\"Created with Highcharts 11.1.0\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = n;\n        this.forExport = k;\n        this.styledMode = J;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.rootFontSize = A.getStyle(\"font-size\");\n        this.setSize(c, f, !1);\n        let q;\n        t && b.getBoundingClientRect && (c = function () {\n          r(b, {\n            left: 0,\n            top: 0\n          });\n          q = b.getBoundingClientRect();\n          r(b, {\n            left: Math.ceil(q.left) - q.left + \"px\",\n            top: Math.ceil(q.top) - q.top + \"px\"\n          });\n        }, c(), this.unSubPixelFix = F(E, \"resize\", c));\n      }\n      definition(b) {\n        return new a([b]).addToDOM(this.defs.element);\n      }\n      getReferenceURL() {\n        if ((t || h) && p.getElementsByTagName(\"base\").length) {\n          if (!q(Z)) {\n            var b = T();\n            b = new a([{\n              tagName: \"svg\",\n              attributes: {\n                width: 8,\n                height: 8\n              },\n              children: [{\n                tagName: \"defs\",\n                children: [{\n                  tagName: \"clipPath\",\n                  attributes: {\n                    id: b\n                  },\n                  children: [{\n                    tagName: \"rect\",\n                    attributes: {\n                      width: 4,\n                      height: 4\n                    }\n                  }]\n                }]\n              }, {\n                tagName: \"rect\",\n                attributes: {\n                  id: \"hitme\",\n                  width: 8,\n                  height: 8,\n                  \"clip-path\": `url(#${b})`,\n                  fill: \"rgba(0,0,0,0.001)\"\n                }\n              }]\n            }]).addToDOM(p.body);\n            r(b, {\n              position: \"fixed\",\n              top: 0,\n              left: 0,\n              zIndex: 9E5\n            });\n            const c = p.elementFromPoint(6, 6);\n            Z = \"hitme\" === (c && c.id);\n            p.body.removeChild(b);\n          }\n          if (Z) return E.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\");\n        }\n        return \"\";\n      }\n      getStyle(c) {\n        return this.style = b({\n          fontFamily: \"Helvetica, Arial, sans-serif\",\n          fontSize: \"1rem\"\n        }, c);\n      }\n      setStyle(b) {\n        this.boxWrapper.css(this.getStyle(b));\n      }\n      isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      }\n      destroy() {\n        const b = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        G(this.gradients || {});\n        this.gradients = null;\n        this.defs = b.destroy();\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      }\n      createElement(b) {\n        const c = new this.Element();\n        c.init(this, b);\n        return c;\n      }\n      getRadialAttr(b, c) {\n        return {\n          cx: b[0] - b[2] / 2 + (c.cx || 0) * b[2],\n          cy: b[1] - b[2] / 2 + (c.cy || 0) * b[2],\n          r: (c.r || 0) * b[2]\n        };\n      }\n      shadowDefinition(b) {\n        const c = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(b).map(c => b[c])].join(\"-\").replace(/[^a-z0-9\\-]/g, \"\"),\n          f = D({\n            color: \"#000000\",\n            offsetX: 1,\n            offsetY: 1,\n            opacity: .15,\n            width: 5\n          }, b);\n        this.defs.element.querySelector(`#${c}`) || this.definition({\n          tagName: \"filter\",\n          attributes: {\n            id: c\n          },\n          children: [{\n            tagName: \"feDropShadow\",\n            attributes: {\n              dx: f.offsetX,\n              dy: f.offsetY,\n              \"flood-color\": f.color,\n              \"flood-opacity\": Math.min(5 * f.opacity, 1),\n              stdDeviation: f.width / 2\n            }\n          }]\n        });\n        return c;\n      }\n      buildText(b) {\n        new B(b).buildSVG();\n      }\n      getContrast(b) {\n        b = y.parse(b).rgba.map(b => {\n          b /= 255;\n          return .03928 >= b ? b / 12.92 : Math.pow((b + .055) / 1.055, 2.4);\n        });\n        b = .2126 * b[0] + .7152 * b[1] + .0722 * b[2];\n        return 1.05 / (b + .05) > (b + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n      }\n      button(c, f, d, k, e = {}, q, J, g, r, h) {\n        const A = this.label(c, f, d, r, void 0, void 0, h, void 0, \"button\"),\n          O = this.styledMode;\n        c = e.states || {};\n        let N = 0;\n        e = D(e);\n        delete e.states;\n        const l = D({\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"0.8em\",\n          fontWeight: \"normal\"\n        }, e.style);\n        delete e.style;\n        let w = a.filterUserAttributes(e);\n        A.attr(D({\n          padding: 8,\n          r: 2\n        }, w));\n        let p, G, R;\n        O || (w = D({\n          fill: \"#f7f7f7\",\n          stroke: \"#cccccc\",\n          \"stroke-width\": 1\n        }, w), q = D(w, {\n          fill: \"#e6e6e6\"\n        }, a.filterUserAttributes(q || c.hover || {})), p = q.style, delete q.style, J = D(w, {\n          fill: \"#e6e9ff\",\n          style: {\n            color: \"#000000\",\n            fontWeight: \"bold\"\n          }\n        }, a.filterUserAttributes(J || c.select || {})), G = J.style, delete J.style, g = D(w, {\n          style: {\n            color: \"#cccccc\"\n          }\n        }, a.filterUserAttributes(g || c.disabled || {})), R = g.style, delete g.style);\n        F(A.element, m ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== N && A.setState(1);\n        });\n        F(A.element, m ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== N && A.setState(N);\n        });\n        A.setState = function (b) {\n          1 !== b && (A.state = N = b);\n          A.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][b || 0]);\n          O || (A.attr([w, q, J, g][b || 0]), b = [l, p, G, R][b || 0], n(b) && A.css(b));\n        };\n        O || (A.attr(w).css(b({\n          cursor: \"default\"\n        }, l)), h && A.text.css({\n          pointerEvents: \"none\"\n        }));\n        return A.on(\"touchstart\", b => b.stopPropagation()).on(\"click\", function (b) {\n          3 !== N && k.call(A, b);\n        });\n      }\n      crispLine(b, c, f = \"round\") {\n        const d = b[0],\n          a = b[1];\n        q(d[1]) && d[1] === a[1] && (d[1] = a[1] = Math[f](d[1]) - c % 2 / 2);\n        q(d[2]) && d[2] === a[2] && (d[2] = a[2] = Math[f](d[2]) + c % 2 / 2);\n        return b;\n      }\n      path(c) {\n        const d = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        f(c) ? d.d = c : n(c) && b(d, c);\n        return this.createElement(\"path\").attr(d);\n      }\n      circle(b, c, f) {\n        b = n(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: c,\n          r: f\n        };\n        c = this.createElement(\"circle\");\n        c.xSetter = c.ySetter = function (b, c, f) {\n          f.setAttribute(\"c\" + c, b);\n        };\n        return c.attr(b);\n      }\n      arc(b, c, f, d, a, k) {\n        n(b) ? (d = b, c = d.y, f = d.r, b = d.x) : d = {\n          innerR: d,\n          start: a,\n          end: k\n        };\n        b = this.symbol(\"arc\", b, c, f, f, d);\n        b.r = f;\n        return b;\n      }\n      rect(c, f, a, k, e, q) {\n        c = n(c) ? c : \"undefined\" === typeof c ? {} : {\n          x: c,\n          y: f,\n          r: e,\n          width: Math.max(a || 0, 0),\n          height: Math.max(k || 0, 0)\n        };\n        const A = this.createElement(\"rect\");\n        this.styledMode || (\"undefined\" !== typeof q && (c[\"stroke-width\"] = q, b(c, A.crisp(c))), c.fill = \"none\");\n        A.rSetter = function (b, c, f) {\n          A.r = b;\n          d(f, {\n            rx: b,\n            ry: b\n          });\n        };\n        A.rGetter = function () {\n          return A.r || 0;\n        };\n        return A.attr(c);\n      }\n      roundedRect(b) {\n        return this.symbol(\"roundedRect\").attr(b);\n      }\n      setSize(b, c, f) {\n        this.width = b;\n        this.height = c;\n        this.boxWrapper.animate({\n          width: b,\n          height: c\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: K(f, !0) ? void 0 : 0\n        });\n        this.alignElements();\n      }\n      g(b) {\n        const c = this.createElement(\"g\");\n        return b ? c.attr({\n          \"class\": \"highcharts-\" + b\n        }) : c;\n      }\n      image(b, f, d, a, k, n) {\n        const A = {\n          preserveAspectRatio: \"none\"\n        };\n        c(f) && (A.x = f);\n        c(d) && (A.y = d);\n        c(a) && (A.width = a);\n        c(k) && (A.height = k);\n        const e = this.createElement(\"image\").attr(A);\n        f = function (c) {\n          e.attr({\n            href: b\n          });\n          n.call(e, c);\n        };\n        n ? (e.attr({\n          href: \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"\n        }), d = new E.Image(), F(d, \"load\", f), d.src = b, d.complete && f({})) : e.attr({\n          href: b\n        });\n        return e;\n      }\n      symbol(c, f, a, n, e, g) {\n        const A = this,\n          h = /^url\\((.*?)\\)$/,\n          O = h.test(c),\n          m = !O && (this.symbols[c] ? c : \"circle\"),\n          l = m && this.symbols[m];\n        let D, G, P, t;\n        if (l) \"number\" === typeof f && (G = l.call(this.symbols, Math.round(f || 0), Math.round(a || 0), n || 0, e || 0, g)), D = this.path(G), A.styledMode || D.attr(\"fill\", \"none\"), b(D, {\n          symbolName: m || void 0,\n          x: f,\n          y: a,\n          width: n,\n          height: e\n        }), g && b(D, g);else if (O) {\n          P = c.match(h)[1];\n          const b = D = this.image(P);\n          b.imgwidth = K(g && g.width, w[P] && w[P].width);\n          b.imgheight = K(g && g.height, w[P] && w[P].height);\n          t = b => b.attr({\n            width: b.width,\n            height: b.height\n          });\n          [\"width\", \"height\"].forEach(function (c) {\n            b[c + \"Setter\"] = function (b, c) {\n              this[c] = b;\n              const {\n                alignByTranslate: f,\n                element: a,\n                width: k,\n                height: A,\n                imgwidth: n,\n                imgheight: e\n              } = this;\n              b = this[\"img\" + c];\n              if (q(b)) {\n                let J = 1;\n                g && \"within\" === g.backgroundSize && k && A ? (J = Math.min(k / n, A / e), d(a, {\n                  width: Math.round(n * J),\n                  height: Math.round(e * J)\n                })) : a && a.setAttribute(c, b);\n                f || this.translate(((k || 0) - n * J) / 2, ((A || 0) - e * J) / 2);\n              }\n            };\n          });\n          q(f) && b.attr({\n            x: f,\n            y: a\n          });\n          b.isImg = !0;\n          q(b.imgwidth) && q(b.imgheight) ? t(b) : (b.attr({\n            width: 0,\n            height: 0\n          }), k(\"img\", {\n            onload: function () {\n              const c = v[A.chartIndex];\n              0 === this.width && (r(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), p.body.appendChild(this));\n              w[P] = {\n                width: this.width,\n                height: this.height\n              };\n              b.imgwidth = this.width;\n              b.imgheight = this.height;\n              b.element && t(b);\n              this.parentNode && this.parentNode.removeChild(this);\n              A.imgCount--;\n              if (!A.imgCount && c && !c.hasLoaded) c.onload();\n            },\n            src: P\n          }), this.imgCount++);\n        }\n        return D;\n      }\n      clipRect(b, c, f, d) {\n        const a = T() + \"-\",\n          k = this.createElement(\"clipPath\").attr({\n            id: a\n          }).add(this.defs);\n        b = this.rect(b, c, f, d, 0).add(k);\n        b.id = a;\n        b.clipPath = k;\n        b.count = 0;\n        return b;\n      }\n      text(b, c, f, d) {\n        const a = {};\n        if (d && (this.allowHTML || !this.forExport)) return this.html(b, c, f);\n        a.x = Math.round(c || 0);\n        f && (a.y = Math.round(f));\n        q(b) && (a.text = b);\n        b = this.createElement(\"text\").attr(a);\n        if (!d || this.forExport && !this.allowHTML) b.xSetter = function (b, c, f) {\n          const d = f.getElementsByTagName(\"tspan\"),\n            a = f.getAttribute(c);\n          for (let f = 0, k; f < d.length; f++) k = d[f], k.getAttribute(c) === a && k.setAttribute(c, b);\n          f.setAttribute(c, b);\n        };\n        return b;\n      }\n      fontMetrics(b) {\n        b = x(C.prototype.getStyle.call(b, \"font-size\") || 0);\n        const c = 24 > b ? b + 3 : Math.round(1.2 * b);\n        return {\n          h: c,\n          b: Math.round(.8 * c),\n          f: b\n        };\n      }\n      rotCorr(b, c, f) {\n        let d = b;\n        c && f && (d = Math.max(d * Math.cos(c * l), 4));\n        return {\n          x: -b / 3 * Math.sin(c * l),\n          y: d\n        };\n      }\n      pathToSegments(b) {\n        const f = [],\n          d = [],\n          a = {\n            A: 8,\n            C: 7,\n            H: 2,\n            L: 3,\n            M: 3,\n            Q: 5,\n            S: 5,\n            T: 3,\n            V: 2\n          };\n        for (let k = 0; k < b.length; k++) P(d[0]) && c(b[k]) && d.length === a[d[0].toUpperCase()] && b.splice(k, 0, d[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof b[k] && (d.length && f.push(d.slice(0)), d.length = 0), d.push(b[k]);\n        f.push(d.slice(0));\n        return f;\n      }\n      label(b, c, f, d, a, k, n, e, q) {\n        return new z(this, b, c, f, d, a, k, n, e, q);\n      }\n      alignElements() {\n        this.alignedObjects.forEach(b => b.align());\n      }\n    }\n    b(V.prototype, {\n      Element: C,\n      SVG_NS: e,\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      symbols: H,\n      draw: g\n    });\n    L.registerRendererType(\"svg\", V, !0);\n    \"\";\n    return V;\n  });\n  M(a, \"Core/Renderer/HTML/HTMLElement.js\", [a[\"Core/Globals.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        isFirefox: x,\n        isMS: C,\n        isWebKit: z,\n        win: H\n      } = a,\n      {\n        css: B,\n        defined: u,\n        extend: v,\n        pick: l,\n        pInt: p\n      } = I,\n      t = [];\n    class m extends y {\n      static compose(a) {\n        if (I.pushUnique(t, a)) {\n          const g = m.prototype,\n            e = a.prototype;\n          e.getSpanCorrection = g.getSpanCorrection;\n          e.htmlCss = g.htmlCss;\n          e.htmlGetBBox = g.htmlGetBBox;\n          e.htmlUpdateTransform = g.htmlUpdateTransform;\n          e.setSpanRotation = g.setSpanRotation;\n        }\n        return a;\n      }\n      getSpanCorrection(a, g, e) {\n        this.xCorr = -a * e;\n        this.yCorr = -g;\n      }\n      htmlCss(a) {\n        const g = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n          e = l(g && a.width, void 0);\n        let h;\n        g && (delete a.width, this.textWidth = e, h = !0);\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = v(this.styles, a);\n        B(this.element, a);\n        h && this.htmlUpdateTransform();\n        return this;\n      }\n      htmlGetBBox() {\n        const a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      }\n      htmlUpdateTransform() {\n        if (this.added) {\n          var a = this.renderer,\n            g = this.element,\n            e = this.x || 0,\n            m = this.y || 0,\n            l = this.textAlign || \"left\",\n            t = {\n              left: 0,\n              center: .5,\n              right: 1\n            }[l],\n            d = this.styles,\n            k = d && d.whiteSpace;\n          B(g, {\n            marginLeft: this.translateX || 0,\n            marginTop: this.translateY || 0\n          });\n          if (\"SPAN\" === g.tagName) {\n            d = this.rotation;\n            const q = this.textWidth && p(this.textWidth),\n              h = [d, l, g.innerHTML, this.textWidth, this.textAlign].join();\n            let b = !1;\n            if (q !== this.oldTextWidth) {\n              if (this.textPxLength) var r = this.textPxLength;else B(g, {\n                width: \"\",\n                whiteSpace: k || \"nowrap\"\n              }), r = g.offsetWidth;\n              (q > this.oldTextWidth || r > q) && (/[ \\-]/.test(g.textContent || g.innerText) || \"ellipsis\" === g.style.textOverflow) && (B(g, {\n                width: r > q || d ? q + \"px\" : \"auto\",\n                display: \"block\",\n                whiteSpace: k || \"normal\"\n              }), this.oldTextWidth = q, b = !0);\n            }\n            this.hasBoxWidthChanged = b;\n            h !== this.cTT && (a = a.fontMetrics(g).b, !u(d) || d === (this.oldRotation || 0) && l === this.oldAlign || this.setSpanRotation(d, t, a), this.getSpanCorrection(!u(d) && this.textPxLength || g.offsetWidth, a, t, d, l));\n            B(g, {\n              left: e + (this.xCorr || 0) + \"px\",\n              top: m + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = h;\n            this.oldRotation = d;\n            this.oldAlign = l;\n          }\n        } else this.alignOnAdd = !0;\n      }\n      setSpanRotation(a, g, e) {\n        const h = {},\n          m = C && !/Edge/.test(H.navigator.userAgent) ? \"-ms-transform\" : z ? \"-webkit-transform\" : x ? \"MozTransform\" : H.opera ? \"-o-transform\" : void 0;\n        m && (h[m] = h.transform = \"rotate(\" + a + \"deg)\", h[m + (x ? \"Origin\" : \"-origin\")] = h.transformOrigin = 100 * g + \"% \" + e + \"px\", B(this.element, h));\n      }\n    }\n    return m;\n  });\n  M(a, \"Core/Renderer/HTML/HTMLRenderer.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L) {\n    const {\n        attr: x,\n        createElement: z,\n        extend: H,\n        pick: B\n      } = L,\n      u = [];\n    class v extends I {\n      static compose(a) {\n        L.pushUnique(u, a) && (a.prototype.html = v.prototype.html);\n        return a;\n      }\n      html(l, p, t) {\n        const m = this.createElement(\"span\"),\n          h = m.element,\n          g = m.renderer,\n          e = function (a, e) {\n            [\"opacity\", \"visibility\"].forEach(function (g) {\n              a[g + \"Setter\"] = function (d, k, r) {\n                const q = a.div ? a.div.style : e;\n                y.prototype[g + \"Setter\"].call(this, d, k, r);\n                q && (q[k] = d);\n              };\n            });\n            a.addedSetters = !0;\n          };\n        m.textSetter = function (e) {\n          e !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, B(e, \"\")), this.textStr = e, m.doTransform = !0);\n        };\n        e(m, m.element.style);\n        m.xSetter = m.ySetter = m.alignSetter = m.rotationSetter = function (a, e) {\n          \"align\" === e ? m.alignValue = m.textAlign = a : m[e] = a;\n          m.doTransform = !0;\n        };\n        m.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n        m.attr({\n          text: l,\n          x: Math.round(p),\n          y: Math.round(t)\n        }).css({\n          position: \"absolute\"\n        });\n        g.styledMode || m.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        h.style.whiteSpace = \"nowrap\";\n        m.css = m.htmlCss;\n        m.add = function (a) {\n          const l = g.box.parentNode,\n            w = [];\n          let d;\n          if (this.parentGroup = a) {\n            if (d = a.div, !d) {\n              for (; a;) w.push(a), a = a.parentGroup;\n              w.reverse().forEach(function (a) {\n                function k(f, c) {\n                  a[c] = f;\n                  \"translateX\" === c ? b.left = f + \"px\" : b.top = f + \"px\";\n                  a.doTransform = !0;\n                }\n                const q = x(a.element, \"class\"),\n                  g = a.styles || {};\n                d = a.div = a.div || z(\"div\", q ? {\n                  className: q\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  visibility: a.visibility\n                }, d || l);\n                const b = d.style;\n                H(a, {\n                  classSetter: function (b) {\n                    return function (c) {\n                      this.element.setAttribute(\"class\", c);\n                      b.className = c;\n                    };\n                  }(d),\n                  css: function (f) {\n                    m.css.call(a, f);\n                    [\"cursor\", \"pointerEvents\"].forEach(c => {\n                      f[c] && (b[c] = f[c]);\n                    });\n                    return a;\n                  },\n                  on: function () {\n                    w[0].div && m.on.apply({\n                      element: w[0].div,\n                      onEvents: a.onEvents\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: k,\n                  translateYSetter: k\n                });\n                a.addedSetters || e(a);\n                a.css(g);\n              });\n            }\n          } else d = l;\n          d.appendChild(h);\n          m.added = !0;\n          m.alignOnAdd && m.htmlUpdateTransform();\n          return m;\n        };\n        return m;\n      }\n    }\n    return v;\n  });\n  M(a, \"Core/Axis/AxisDefaults.js\", [], function () {\n    var a;\n    (function (a) {\n      a.defaultXAxisOptions = {\n        alignTicks: !0,\n        allowDecimals: void 0,\n        panningEnabled: !0,\n        zIndex: 2,\n        zoomEnabled: !0,\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e %b\"\n          },\n          week: {\n            main: \"%e %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        gridLineDashStyle: \"Solid\",\n        gridZIndex: 1,\n        labels: {\n          autoRotation: void 0,\n          autoRotationLimit: 80,\n          distance: 15,\n          enabled: !0,\n          indentation: 10,\n          overflow: \"justify\",\n          padding: 5,\n          reserveSpace: void 0,\n          rotation: void 0,\n          staggerLines: 0,\n          step: 0,\n          useHTML: !1,\n          zIndex: 7,\n          style: {\n            color: \"#333333\",\n            cursor: \"default\",\n            fontSize: \"0.8em\"\n          }\n        },\n        maxPadding: .01,\n        minorGridLineDashStyle: \"Solid\",\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minorTicksPerMajor: 5,\n        minPadding: .01,\n        offset: void 0,\n        opposite: !1,\n        reversed: void 0,\n        reversedStacks: !1,\n        showEmpty: !0,\n        showFirstLabel: !0,\n        showLastLabel: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          rotation: 0,\n          useHTML: !1,\n          x: 0,\n          y: 0,\n          style: {\n            color: \"#666666\",\n            fontSize: \"0.8em\"\n          }\n        },\n        type: \"linear\",\n        uniqueNames: !0,\n        visible: !0,\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#333333\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        gridLineWidth: void 0,\n        tickColor: \"#333333\"\n      };\n      a.defaultYAxisOptions = {\n        reversedStacks: !0,\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: void 0\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          animation: {},\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function () {\n            const {\n              numberFormatter: a\n            } = this.axis.chart;\n            return a(this.total || 0, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"0.7em\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      };\n      a.defaultLeftAxisOptions = {\n        title: {\n          rotation: 270\n        }\n      };\n      a.defaultRightAxisOptions = {\n        title: {\n          rotation: 90\n        }\n      };\n      a.defaultBottomAxisOptions = {\n        labels: {\n          autoRotation: [-45]\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      a.defaultTopAxisOptions = {\n        labels: {\n          autoRotation: [-45]\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n    })(a || (a = {}));\n    return a;\n  });\n  M(a, \"Core/Foundation.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: x,\n      isFunction: I,\n      objectEach: L,\n      removeEvent: C\n    } = a;\n    var z;\n    (function (a) {\n      a.registerEventOptions = function (a, u) {\n        a.eventOptions = a.eventOptions || {};\n        L(u.events, function (v, l) {\n          a.eventOptions[l] !== v && (a.eventOptions[l] && (C(a, l, a.eventOptions[l]), delete a.eventOptions[l]), I(v) && (a.eventOptions[l] = v, x(a, l, v, {\n            order: 0\n          })));\n        });\n      };\n    })(z || (z = {}));\n    return z;\n  });\n  M(a, \"Core/Axis/Tick.js\", [a[\"Core/Templating.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        deg2rad: x\n      } = y,\n      {\n        clamp: C,\n        correctFloat: z,\n        defined: H,\n        destroyObjectProperties: B,\n        extend: u,\n        fireEvent: v,\n        isNumber: l,\n        merge: p,\n        objectEach: t,\n        pick: m\n      } = I;\n    class h {\n      constructor(a, e, h, m, l) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = a;\n        this.pos = e;\n        this.type = h || \"\";\n        this.parameters = l || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        v(this, \"init\");\n        h || m || this.addLabel();\n      }\n      addLabel() {\n        const g = this,\n          e = g.axis;\n        var h = e.options;\n        const p = e.chart;\n        var t = e.categories;\n        const d = e.logarithmic,\n          k = e.names,\n          r = g.pos,\n          q = m(g.options && g.options.labels, h.labels);\n        var G = e.tickPositions;\n        const b = r === G[0],\n          f = r === G[G.length - 1],\n          c = (!q.step || 1 === q.step) && 1 === e.tickInterval;\n        G = G.info;\n        let n = g.label,\n          P,\n          D,\n          K;\n        t = this.parameters.category || (t ? m(t[r], k[r], r) : r);\n        d && l(t) && (t = z(d.lin2log(t)));\n        e.dateTime && (G ? (D = p.time.resolveDTLFormat(h.dateTimeLabelFormats[!h.grid && G.higherRanks[r] || G.unitName]), P = D.main) : l(t) && (P = e.dateTime.getXDateFormat(t, h.dateTimeLabelFormats || {})));\n        g.isFirst = b;\n        g.isLast = f;\n        const x = {\n          axis: e,\n          chart: p,\n          dateTimeLabelFormat: P,\n          isFirst: b,\n          isLast: f,\n          pos: r,\n          tick: g,\n          tickPositionInfo: G,\n          value: t\n        };\n        v(this, \"labelFormat\", x);\n        const B = b => q.formatter ? q.formatter.call(b, b) : q.format ? (b.text = e.defaultLabelFormatter.call(b, b), a.format(q.format, b, p)) : e.defaultLabelFormatter.call(b, b);\n        h = B.call(x, x);\n        const y = D && D.list;\n        g.shortenLabel = y ? function () {\n          for (K = 0; K < y.length; K++) if (u(x, {\n            dateTimeLabelFormat: y[K]\n          }), n.attr({\n            text: B.call(x, x)\n          }), n.getBBox().width < e.getSlotWidth(g) - 2 * q.padding) return;\n          n.attr({\n            text: \"\"\n          });\n        } : void 0;\n        c && e._addedPlotLB && g.moveLabel(h, q);\n        H(n) || g.movedLabel ? n && n.textStr !== h && !c && (!n.textWidth || q.style.width || n.styles.width || n.css({\n          width: null\n        }), n.attr({\n          text: h\n        }), n.textPxLength = n.getBBox().width) : (g.label = n = g.createLabel({\n          x: 0,\n          y: 0\n        }, h, q), g.rotation = 0);\n      }\n      createLabel(a, e, h) {\n        const g = this.axis,\n          m = g.chart;\n        if (a = H(e) && h.enabled ? m.renderer.text(e, a.x, a.y, h.useHTML).add(g.labelGroup) : null) m.styledMode || a.css(p(h.style)), a.textPxLength = a.getBBox().width;\n        return a;\n      }\n      destroy() {\n        B(this, this.axis);\n      }\n      getPosition(a, e, h, m) {\n        const g = this.axis,\n          d = g.chart,\n          k = m && d.oldChartHeight || d.chartHeight;\n        a = {\n          x: a ? z(g.translate(e + h, void 0, void 0, m) + g.transB) : g.left + g.offset + (g.opposite ? (m && d.oldChartWidth || d.chartWidth) - g.right - g.left : 0),\n          y: a ? k - g.bottom + g.offset - (g.opposite ? g.height : 0) : z(k - g.translate(e + h, void 0, void 0, m) - g.transB)\n        };\n        a.y = C(a.y, -1E5, 1E5);\n        v(this, \"afterGetPosition\", {\n          pos: a\n        });\n        return a;\n      }\n      getLabelPosition(a, e, h, l, p, d, k, r) {\n        const q = this.axis,\n          g = q.transA,\n          b = q.isLinked && q.linkedParent ? q.linkedParent.reversed : q.reversed,\n          f = q.staggerLines,\n          c = q.tickRotCorr || {\n            x: 0,\n            y: 0\n          },\n          n = l || q.reserveSpaceDefault ? 0 : -q.labelOffset * (\"center\" === q.labelAlign ? .5 : 1),\n          w = p.distance,\n          D = {};\n        h = 0 === q.side ? h.rotation ? -w : -h.getBBox().height : 2 === q.side ? c.y + w : Math.cos(h.rotation * x) * (c.y - h.getBBox(!1, 0).height / 2);\n        H(p.y) && (h = 0 === q.side && q.horiz ? p.y + h : p.y);\n        a = a + m(p.x, [0, 1, 0, -1][q.side] * w) + n + c.x - (d && l ? d * g * (b ? -1 : 1) : 0);\n        e = e + h - (d && !l ? d * g * (b ? 1 : -1) : 0);\n        f && (l = k / (r || 1) % f, q.opposite && (l = f - l - 1), e += q.labelOffset / f * l);\n        D.x = a;\n        D.y = Math.round(e);\n        v(this, \"afterGetLabelPosition\", {\n          pos: D,\n          tickmarkOffset: d,\n          index: k\n        });\n        return D;\n      }\n      getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      }\n      getMarkPath(a, e, h, m, l, d) {\n        return d.crispLine([[\"M\", a, e], [\"L\", a + (l ? 0 : -h), e + (l ? h : 0)]], m);\n      }\n      handleOverflow(a) {\n        const e = this.axis,\n          g = e.options.labels,\n          h = a.x;\n        var l = e.chart.chartWidth,\n          d = e.chart.spacing;\n        const k = m(e.labelLeft, Math.min(e.pos, d[3]));\n        d = m(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, l - d[1]));\n        const r = this.label,\n          q = this.rotation,\n          p = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[e.labelAlign || r.attr(\"align\")],\n          b = r.getBBox().width,\n          f = e.getSlotWidth(this),\n          c = {};\n        let n = f,\n          t = 1,\n          D;\n        if (q || \"justify\" !== g.overflow) 0 > q && h - p * b < k ? D = Math.round(h / Math.cos(q * x) - k) : 0 < q && h + p * b > d && (D = Math.round((l - h) / Math.cos(q * x)));else if (l = h + (1 - p) * b, h - p * b < k ? n = a.x + n * (1 - p) - k : l > d && (n = d - a.x + n * p, t = -1), n = Math.min(f, n), n < f && \"center\" === e.labelAlign && (a.x += t * (f - n - p * (f - Math.min(b, n)))), b > n || e.autoRotation && (r.styles || {}).width) D = n;\n        D && (this.shortenLabel ? this.shortenLabel() : (c.width = Math.floor(D) + \"px\", (g.style || {}).textOverflow || (c.textOverflow = \"ellipsis\"), r.css(c)));\n      }\n      moveLabel(a, e) {\n        const g = this;\n        var h = g.label;\n        const m = g.axis;\n        let d = !1;\n        h && h.textStr === a ? (g.movedLabel = h, d = !0, delete g.label) : t(m.ticks, function (k) {\n          d || k.isNew || k === g || !k.label || k.label.textStr !== a || (g.movedLabel = k.label, d = !0, k.labelPos = g.movedLabel.xy, delete k.label);\n        });\n        d || !g.labelPos && !h || (h = g.labelPos || h.xy, g.movedLabel = g.createLabel(h, a, e), g.movedLabel && g.movedLabel.attr({\n          opacity: 0\n        }));\n      }\n      render(a, e, h) {\n        var g = this.axis,\n          l = g.horiz,\n          d = this.pos,\n          k = m(this.tickmarkOffset, g.tickmarkOffset);\n        d = this.getPosition(l, d, k, e);\n        k = d.x;\n        const r = d.y;\n        g = l && k === g.pos + g.len || !l && r === g.pos ? -1 : 1;\n        l = m(h, this.label && this.label.newOpacity, 1);\n        h = m(h, 1);\n        this.isActive = !0;\n        this.renderGridLine(e, h, g);\n        this.renderMark(d, h, g);\n        this.renderLabel(d, e, l, a);\n        this.isNew = !1;\n        v(this, \"afterRender\");\n      }\n      renderGridLine(a, e, h) {\n        const g = this.axis,\n          l = g.options,\n          d = {},\n          k = this.pos,\n          r = this.type,\n          q = m(this.tickmarkOffset, g.tickmarkOffset),\n          p = g.chart.renderer;\n        let b = this.gridLine,\n          f = l.gridLineWidth,\n          c = l.gridLineColor,\n          n = l.gridLineDashStyle;\n        \"minor\" === this.type && (f = l.minorGridLineWidth, c = l.minorGridLineColor, n = l.minorGridLineDashStyle);\n        b || (g.chart.styledMode || (d.stroke = c, d[\"stroke-width\"] = f || 0, d.dashstyle = n), r || (d.zIndex = 1), a && (e = 0), this.gridLine = b = p.path().attr(d).addClass(\"highcharts-\" + (r ? r + \"-\" : \"\") + \"grid-line\").add(g.gridGroup));\n        if (b && (h = g.getPlotLinePath({\n          value: k + q,\n          lineWidth: b.strokeWidth() * h,\n          force: \"pass\",\n          old: a,\n          acrossPanes: !1\n        }))) b[a || this.isNew ? \"attr\" : \"animate\"]({\n          d: h,\n          opacity: e\n        });\n      }\n      renderMark(a, e, h) {\n        const g = this.axis;\n        var l = g.options;\n        const d = g.chart.renderer,\n          k = this.type,\n          r = g.tickSize(k ? k + \"Tick\" : \"tick\"),\n          q = a.x;\n        a = a.y;\n        const p = m(l[\"minor\" !== k ? \"tickWidth\" : \"minorTickWidth\"], !k && g.isXAxis ? 1 : 0);\n        l = l[\"minor\" !== k ? \"tickColor\" : \"minorTickColor\"];\n        let b = this.mark;\n        const f = !b;\n        r && (g.opposite && (r[0] = -r[0]), b || (this.mark = b = d.path().addClass(\"highcharts-\" + (k ? k + \"-\" : \"\") + \"tick\").add(g.axisGroup), g.chart.styledMode || b.attr({\n          stroke: l,\n          \"stroke-width\": p\n        })), b[f ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(q, a, r[0], b.strokeWidth() * h, g.horiz, d),\n          opacity: e\n        }));\n      }\n      renderLabel(a, e, h, p) {\n        var g = this.axis;\n        const d = g.horiz,\n          k = g.options,\n          r = this.label,\n          q = k.labels,\n          t = q.step;\n        g = m(this.tickmarkOffset, g.tickmarkOffset);\n        const b = a.x;\n        a = a.y;\n        let f = !0;\n        r && l(b) && (r.xy = a = this.getLabelPosition(b, a, r, d, q, g, p, t), this.isFirst && !this.isLast && !k.showFirstLabel || this.isLast && !this.isFirst && !k.showLastLabel ? f = !1 : !d || q.step || q.rotation || e || 0 === h || this.handleOverflow(a), t && p % t && (f = !1), f && l(a.y) ? (a.opacity = h, r[this.isNewLabel ? \"attr\" : \"animate\"](a).show(!0), this.isNewLabel = !1) : (r.hide(), this.isNewLabel = !0));\n      }\n      replaceMovedLabel() {\n        const a = this.label,\n          e = this.axis;\n        a && !this.isNew && (a.animate({\n          opacity: 0\n        }, void 0, a.destroy), delete this.label);\n        e.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      }\n    }\n    \"\";\n    return h;\n  });\n  M(a, \"Core/Axis/Axis.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/AxisDefaults.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Defaults.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z, H, B) {\n    const {\n        animObject: u\n      } = a,\n      {\n        defaultOptions: v\n      } = L,\n      {\n        registerEventOptions: l\n      } = C,\n      {\n        deg2rad: p\n      } = z,\n      {\n        arrayMax: t,\n        arrayMin: m,\n        clamp: h,\n        correctFloat: g,\n        defined: e,\n        destroyObjectProperties: w,\n        erase: x,\n        error: F,\n        extend: d,\n        fireEvent: k,\n        getClosestDistance: r,\n        insertItem: q,\n        isArray: G,\n        isNumber: b,\n        isString: f,\n        merge: c,\n        normalizeTickInterval: n,\n        objectEach: P,\n        pick: D,\n        relativeLength: K,\n        removeEvent: X,\n        splat: T,\n        syncTimeout: Z\n      } = B,\n      V = (b, c) => n(c, void 0, void 0, D(b.options.allowDecimals, .5 > c || void 0 !== b.tickAmount), !!b.tickAmount);\n    class Y {\n      constructor(b, c, f) {\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.index = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;\n        this.init(b, c, f);\n      }\n      init(c, f, a = this.coll) {\n        const d = \"xAxis\" === a;\n        this.chart = c;\n        this.horiz = this.isZAxis || (c.inverted ? !d : d);\n        this.isXAxis = d;\n        this.coll = a;\n        k(this, \"init\", {\n          userOptions: f\n        });\n        this.opposite = D(f.opposite, this.opposite);\n        this.side = D(f.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);\n        this.setOptions(f);\n        a = this.options;\n        const A = a.labels,\n          n = a.type;\n        this.userOptions = f;\n        this.minPixelPadding = 0;\n        this.reversed = D(a.reversed, this.reversed);\n        this.visible = a.visible;\n        this.zoomEnabled = a.zoomEnabled;\n        this.hasNames = \"category\" === n || !0 === a.categories;\n        this.categories = a.categories || (this.hasNames ? [] : void 0);\n        this.names || (this.names = [], this.names.keys = {});\n        this.plotLinesAndBandsGroups = {};\n        this.positiveValuesOnly = !!this.logarithmic;\n        this.isLinked = e(a.linkedTo);\n        this.ticks = {};\n        this.labelEdge = [];\n        this.minorTicks = {};\n        this.plotLinesAndBands = [];\n        this.alternateBands = {};\n        this.len = 0;\n        this.minRange = this.userMinRange = a.minRange || a.maxZoom;\n        this.range = a.range;\n        this.offset = a.offset || 0;\n        this.min = this.max = null;\n        f = D(a.crosshair, T(c.options.tooltip.crosshairs)[d ? 0 : 1]);\n        this.crosshair = !0 === f ? {} : f;\n        -1 === c.axes.indexOf(this) && (d ? c.axes.splice(c.xAxis.length, 0, this) : c.axes.push(this), q(this, c[this.coll]));\n        c.orderItems(this.coll);\n        this.series = this.series || [];\n        c.inverted && !this.isZAxis && d && \"undefined\" === typeof this.reversed && (this.reversed = !0);\n        this.labelRotation = b(A.rotation) ? A.rotation : void 0;\n        l(this, a);\n        k(this, \"afterInit\");\n      }\n      setOptions(b) {\n        this.options = c(y.defaultXAxisOptions, \"yAxis\" === this.coll && y.defaultYAxisOptions, [y.defaultTopAxisOptions, y.defaultRightAxisOptions, y.defaultBottomAxisOptions, y.defaultLeftAxisOptions][this.side], c(v[this.coll], b));\n        k(this, \"afterSetOptions\", {\n          userOptions: b\n        });\n      }\n      defaultLabelFormatter(c) {\n        var f = this.axis;\n        ({\n          numberFormatter: c\n        } = this.chart);\n        const a = b(this.value) ? this.value : NaN,\n          d = f.chart.time,\n          k = this.dateTimeLabelFormat;\n        var n = v.lang;\n        const A = n.numericSymbols;\n        n = n.numericSymbolMagnitude || 1E3;\n        const e = f.logarithmic ? Math.abs(a) : f.tickInterval;\n        let q = A && A.length,\n          g;\n        if (f.categories) g = `${this.value}`;else if (k) g = d.dateFormat(k, a);else if (q && 1E3 <= e) for (; q-- && \"undefined\" === typeof g;) f = Math.pow(n, q + 1), e >= f && 0 === 10 * a % f && null !== A[q] && 0 !== a && (g = c(a / f, -1) + A[q]);\n        \"undefined\" === typeof g && (g = 1E4 <= Math.abs(a) ? c(a, -1) : c(a, -1, void 0, \"\"));\n        return g;\n      }\n      getSeriesExtremes() {\n        const c = this,\n          f = c.chart;\n        let a;\n        k(this, \"getSeriesExtremes\", null, function () {\n          c.hasVisibleSeries = !1;\n          c.dataMin = c.dataMax = c.threshold = null;\n          c.softThreshold = !c.isXAxis;\n          c.series.forEach(function (d) {\n            if (d.visible || !f.options.chart.ignoreHiddenSeries) {\n              var k = d.options;\n              let f = k.threshold,\n                n,\n                A;\n              c.hasVisibleSeries = !0;\n              c.positiveValuesOnly && 0 >= f && (f = null);\n              if (c.isXAxis) (k = d.xData) && k.length && (k = c.logarithmic ? k.filter(b => 0 < b) : k, a = d.getXExtremes(k), n = a.min, A = a.max, b(n) || n instanceof Date || (k = k.filter(b), a = d.getXExtremes(k), n = a.min, A = a.max), k.length && (c.dataMin = Math.min(D(c.dataMin, n), n), c.dataMax = Math.max(D(c.dataMax, A), A)));else if (d = d.applyExtremes(), b(d.dataMin) && (n = d.dataMin, c.dataMin = Math.min(D(c.dataMin, n), n)), b(d.dataMax) && (A = d.dataMax, c.dataMax = Math.max(D(c.dataMax, A), A)), e(f) && (c.threshold = f), !k.softThreshold || c.positiveValuesOnly) c.softThreshold = !1;\n            }\n          });\n        });\n        k(this, \"afterGetSeriesExtremes\");\n      }\n      translate(c, f, a, d, k, n) {\n        const e = this.linkedParent || this,\n          A = d && e.old ? e.old.min : e.min;\n        if (!b(A)) return NaN;\n        const q = e.minPixelPadding;\n        k = (e.isOrdinal || e.brokenAxis && e.brokenAxis.hasBreaks || e.logarithmic && k) && e.lin2val;\n        let J = 1,\n          h = 0;\n        d = d && e.old ? e.old.transA : e.transA;\n        d || (d = e.transA);\n        a && (J *= -1, h = e.len);\n        e.reversed && (J *= -1, h -= J * (e.sector || e.len));\n        f ? (n = (c * J + h - q) / d + A, k && (n = e.lin2val(n))) : (k && (c = e.val2lin(c)), c = J * (c - A) * d, n = (e.isRadial ? c : g(c)) + h + J * q + (b(n) ? d * n : 0));\n        return n;\n      }\n      toPixels(b, c) {\n        return this.translate(b, !1, !this.horiz, void 0, !0) + (c ? 0 : this.pos);\n      }\n      toValue(b, c) {\n        return this.translate(b - (c ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n      }\n      getPlotLinePath(c) {\n        function f(b, c, f) {\n          \"pass\" !== t && (b < c || b > f) && (t ? b = h(b, c, f) : K = !0);\n          return b;\n        }\n        const a = this,\n          d = a.chart,\n          n = a.left,\n          e = a.top,\n          A = c.old,\n          q = c.value,\n          g = c.lineWidth,\n          r = A && d.oldChartHeight || d.chartHeight,\n          m = A && d.oldChartWidth || d.chartWidth,\n          l = a.transB;\n        let p = c.translatedValue,\n          t = c.force,\n          P,\n          w,\n          R,\n          Q,\n          K;\n        c = {\n          value: q,\n          lineWidth: g,\n          old: A,\n          force: t,\n          acrossPanes: c.acrossPanes,\n          translatedValue: p\n        };\n        k(this, \"getPlotLinePath\", c, function (c) {\n          p = D(p, a.translate(q, void 0, void 0, A));\n          p = h(p, -1E5, 1E5);\n          P = R = Math.round(p + l);\n          w = Q = Math.round(r - p - l);\n          b(p) ? a.horiz ? (w = e, Q = r - a.bottom, P = R = f(P, n, n + a.width)) : (P = n, R = m - a.right, w = Q = f(w, e, e + a.height)) : (K = !0, t = !1);\n          c.path = K && !t ? null : d.renderer.crispLine([[\"M\", P, w], [\"L\", R, Q]], g || 1);\n        });\n        return c.path;\n      }\n      getLinearTickPositions(b, c, f) {\n        const a = g(Math.floor(c / b) * b);\n        f = g(Math.ceil(f / b) * b);\n        const d = [];\n        let k, n;\n        g(a + b) === a && (n = 20);\n        if (this.single) return [c];\n        for (c = a; c <= f;) {\n          d.push(c);\n          c = g(c + b, n);\n          if (c === k) break;\n          k = c;\n        }\n        return d;\n      }\n      getMinorTickInterval() {\n        const b = this.options;\n        return !0 === b.minorTicks ? D(b.minorTickInterval, \"auto\") : !1 === b.minorTicks ? null : b.minorTickInterval;\n      }\n      getMinorTickPositions() {\n        var b = this.options;\n        const c = this.tickPositions,\n          f = this.minorTickInterval;\n        var a = this.pointRangePadding || 0;\n        const d = this.min - a;\n        a = this.max + a;\n        const k = a - d;\n        let n = [];\n        if (k && k / f < this.len / 3) {\n          const k = this.logarithmic;\n          if (k) this.paddedTicks.forEach(function (b, c, a) {\n            c && n.push.apply(n, k.getLogTickPositions(f, a[c - 1], a[c], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) n = n.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(f), d, a, b.startOfWeek));else for (b = d + (c[0] - d) % f; b <= a && b !== n[0]; b += f) n.push(b);\n        }\n        0 !== n.length && this.trimTicks(n);\n        return n;\n      }\n      adjustForMinRange() {\n        const b = this.options,\n          c = this.logarithmic;\n        let f = this.min;\n        var a = this.max;\n        let d, k;\n        if (this.isXAxis && \"undefined\" === typeof this.minRange && !c) if (e(b.min) || e(b.max) || e(b.floor) || e(b.ceiling)) this.minRange = null;else {\n          var n = r(this.series.map(b => {\n            var c;\n            return (b.xIncrement ? null === (c = b.xData) || void 0 === c ? void 0 : c.slice(0, 2) : b.xData) || [];\n          })) || 0;\n          this.minRange = Math.min(5 * n, this.dataMax - this.dataMin);\n        }\n        a - f < this.minRange && (n = this.dataMax - this.dataMin >= this.minRange, k = this.minRange, a = (k - a + f) / 2, d = [f - a, D(b.min, f - a)], n && (d[2] = c ? c.log2lin(this.dataMin) : this.dataMin), f = t(d), a = [f + k, D(b.max, f + k)], n && (a[2] = c ? c.log2lin(this.dataMax) : this.dataMax), a = m(a), a - f < k && (d[0] = a - k, d[1] = D(b.min, a - k), f = t(d)));\n        this.min = f;\n        this.max = a;\n      }\n      getClosest() {\n        let b, c;\n        if (this.categories) c = 1;else {\n          const f = [];\n          this.series.forEach(function (b) {\n            var a;\n            const d = b.closestPointRange,\n              k = b.visible || !b.chart.options.chart.ignoreHiddenSeries;\n            1 === (null === (a = b.xData) || void 0 === a ? void 0 : a.length) ? f.push(b.xData[0]) : !b.noSharedTooltip && e(d) && k && (c = e(c) ? Math.min(c, d) : d);\n          });\n          f.length && (f.sort((b, c) => b - c), b = r([f]));\n        }\n        return b && c ? Math.min(b, c) : b || c;\n      }\n      nameToX(b) {\n        const c = G(this.options.categories),\n          f = c ? this.categories : this.names;\n        let a = b.options.x,\n          d;\n        b.series.requireSorting = !1;\n        e(a) || (a = this.options.uniqueNames && f ? c ? f.indexOf(b.name) : D(f.keys[b.name], -1) : b.series.autoIncrement());\n        -1 === a ? !c && f && (d = f.length) : d = a;\n        \"undefined\" !== typeof d ? (this.names[d] = b.name, this.names.keys[b.name] = d) : b.x && (d = b.x);\n        return d;\n      }\n      updateNames() {\n        const b = this,\n          c = this.names;\n        0 < c.length && (Object.keys(c.keys).forEach(function (b) {\n          delete c.keys[b];\n        }), c.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (c) {\n          c.xIncrement = null;\n          if (!c.points || c.isDirtyData) b.max = Math.max(b.max, c.xData.length - 1), c.processData(), c.generatePoints();\n          c.data.forEach(function (f, a) {\n            let d;\n            f && f.options && \"undefined\" !== typeof f.name && (d = b.nameToX(f), \"undefined\" !== typeof d && d !== f.x && (f.x = d, c.xData[a] = d));\n          });\n        }));\n      }\n      setAxisTranslation() {\n        const b = this,\n          c = b.max - b.min;\n        var a = b.linkedParent;\n        const d = !!b.categories,\n          n = b.isXAxis;\n        let e = b.axisPointRange || 0,\n          q,\n          g = 0,\n          h = 0,\n          r = b.transA;\n        if (n || d || e) q = b.getClosest(), a ? (g = a.minPointOffset, h = a.pointRangePadding) : b.series.forEach(function (c) {\n          const a = d ? 1 : n ? D(c.options.pointRange, q, 0) : b.axisPointRange || 0,\n            k = c.options.pointPlacement;\n          e = Math.max(e, a);\n          if (!b.single || d) c = c.is(\"xrange\") ? !n : n, g = Math.max(g, c && f(k) ? 0 : a / 2), h = Math.max(h, c && \"on\" === k ? 0 : a);\n        }), a = b.ordinal && b.ordinal.slope && q ? b.ordinal.slope / q : 1, b.minPointOffset = g *= a, b.pointRangePadding = h *= a, b.pointRange = Math.min(e, b.single && d ? 1 : c), n && q && (b.closestPointRange = q);\n        b.translationSlope = b.transA = r = b.staticScale || b.len / (c + h || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = r * g;\n        k(this, \"afterSetAxisTranslation\");\n      }\n      minFromRange() {\n        return this.max - this.range;\n      }\n      setTickInterval(c) {\n        var f = this.chart;\n        const a = this.logarithmic,\n          d = this.options,\n          n = this.isXAxis,\n          q = this.isLinked,\n          h = d.tickPixelInterval,\n          A = this.categories,\n          r = this.softThreshold;\n        let m = d.maxPadding,\n          l = d.minPadding;\n        let p = b(d.tickInterval) && 0 <= d.tickInterval ? d.tickInterval : void 0,\n          t = b(this.threshold) ? this.threshold : null,\n          P,\n          w,\n          K;\n        this.dateTime || A || q || this.getTickAmount();\n        w = D(this.userMin, d.min);\n        K = D(this.userMax, d.max);\n        if (q) {\n          this.linkedParent = f[this.coll][d.linkedTo];\n          var R = this.linkedParent.getExtremes();\n          this.min = D(R.min, R.dataMin);\n          this.max = D(R.max, R.dataMax);\n          d.type !== this.linkedParent.options.type && F(11, 1, f);\n        } else r && e(t) && (this.dataMin >= t ? (R = t, l = 0) : this.dataMax <= t && (P = t, m = 0)), this.min = D(w, R, this.dataMin), this.max = D(K, P, this.dataMax);\n        a && (this.positiveValuesOnly && !c && 0 >= Math.min(this.min, D(this.dataMin, this.min)) && F(10, 1, f), this.min = g(a.log2lin(this.min), 16), this.max = g(a.log2lin(this.max), 16));\n        this.range && e(this.max) && (this.userMin = this.min = w = Math.max(this.dataMin, this.minFromRange()), this.userMax = K = this.max, this.range = null);\n        k(this, \"foundExtremes\");\n        this.beforePadding && this.beforePadding();\n        this.adjustForMinRange();\n        !b(this.userMin) && b(d.softMin) && d.softMin < this.min && (this.min = w = d.softMin);\n        !b(this.userMax) && b(d.softMax) && d.softMax > this.max && (this.max = K = d.softMax);\n        !(A || this.axisPointRange || this.stacking && this.stacking.usePercentage || q) && e(this.min) && e(this.max) && (f = this.max - this.min) && (!e(w) && l && (this.min -= f * l), !e(K) && m && (this.max += f * m));\n        !b(this.userMin) && b(d.floor) && (this.min = Math.max(this.min, d.floor));\n        !b(this.userMax) && b(d.ceiling) && (this.max = Math.min(this.max, d.ceiling));\n        r && e(this.dataMin) && (t = t || 0, !e(w) && this.min < t && this.dataMin >= t ? this.min = this.options.minRange ? Math.min(t, this.max - this.minRange) : t : !e(K) && this.max > t && this.dataMax <= t && (this.max = this.options.minRange ? Math.max(t, this.min + this.minRange) : t));\n        b(this.min) && b(this.max) && !this.chart.polar && this.min > this.max && (e(this.options.min) ? this.max = this.min : e(this.options.max) && (this.min = this.max));\n        this.tickInterval = this.min === this.max || \"undefined\" === typeof this.min || \"undefined\" === typeof this.max ? 1 : q && this.linkedParent && !p && h === this.linkedParent.options.tickPixelInterval ? p = this.linkedParent.tickInterval : D(p, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, A ? 1 : (this.max - this.min) * h / Math.max(this.len, h));\n        if (n && !c) {\n          const b = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);\n          this.series.forEach(function (c) {\n            c.forceCrop = c.forceCropping && c.forceCropping();\n            c.processData(b);\n          });\n          k(this, \"postProcessData\", {\n            hasExtremesChanged: b\n          });\n        }\n        this.setAxisTranslation();\n        k(this, \"initialAxisTranslation\");\n        this.pointRange && !p && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n        c = D(d.minTickInterval, this.dateTime && !this.series.some(b => b.noSharedTooltip) ? this.closestPointRange : 0);\n        !p && this.tickInterval < c && (this.tickInterval = c);\n        this.dateTime || this.logarithmic || p || (this.tickInterval = V(this, this.tickInterval));\n        this.tickAmount || (this.tickInterval = this.unsquish());\n        this.setTickPositions();\n      }\n      setTickPositions() {\n        var c = this.options;\n        const f = c.tickPositions,\n          a = c.tickPositioner;\n        var d = this.getMinorTickInterval(),\n          n = this.hasVerticalPanning(),\n          q = \"colorAxis\" === this.coll;\n        const g = (q || !n) && c.startOnTick;\n        n = (q || !n) && c.endOnTick;\n        q = [];\n        let h;\n        this.tickmarkOffset = this.categories && \"between\" === c.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === d && this.tickInterval ? this.tickInterval / c.minorTicksPerMajor : d;\n        this.single = this.min === this.max && e(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== c.allowDecimals);\n        if (f) q = f.slice();else if (b(this.min) && b(this.max)) {\n          if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {\n            if (this.dateTime) q = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, c.units), this.min, this.max, c.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) q = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (d = c = this.tickInterval; d <= 2 * c;) if (q = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && q.length > this.tickAmount) this.tickInterval = V(this, d *= 1.1);else break;\n          } else q = [this.min, this.max], F(19, !1, this.chart);\n          q.length > this.len && (q = [q[0], q[q.length - 1]], q[0] === q[1] && (q.length = 1));\n          a && (this.tickPositions = q, (h = a.apply(this, [this.min, this.max])) && (q = h));\n        }\n        this.tickPositions = q;\n        this.paddedTicks = q.slice(0);\n        this.trimTicks(q, g, n);\n        !this.isLinked && b(this.min) && b(this.max) && (this.single && 2 > q.length && !this.categories && !this.series.some(b => b.is(\"heatmap\") && \"between\" === b.options.pointPlacement) && (this.min -= .5, this.max += .5), f || h || this.adjustTickAmount());\n        k(this, \"afterSetTickPositions\");\n      }\n      trimTicks(b, c, f) {\n        const a = b[0],\n          d = b[b.length - 1],\n          n = !this.isOrdinal && this.minPointOffset || 0;\n        k(this, \"trimTicks\");\n        if (!this.isLinked) {\n          if (c && -Infinity !== a) this.min = a;else for (; this.min - n > b[0];) b.shift();\n          if (f) this.max = d;else for (; this.max + n < b[b.length - 1];) b.pop();\n          0 === b.length && e(a) && !this.options.tickPositions && b.push((d + a) / 2);\n        }\n      }\n      alignToOthers() {\n        const c = this,\n          f = [this],\n          a = c.options,\n          d = \"yAxis\" === this.coll && this.chart.options.chart.alignThresholds,\n          k = [];\n        let n;\n        c.thresholdAlignment = void 0;\n        if ((!1 !== this.chart.options.chart.alignTicks && a.alignTicks || d) && !1 !== a.startOnTick && !1 !== a.endOnTick && !c.logarithmic) {\n          const b = b => {\n              const {\n                horiz: c,\n                options: f\n              } = b;\n              return [c ? f.left : f.top, f.width, f.height, f.pane].join();\n            },\n            a = b(this);\n          this.chart[this.coll].forEach(function (d) {\n            const {\n              series: k\n            } = d;\n            k.length && k.some(b => b.visible) && d !== c && b(d) === a && (n = !0, f.push(d));\n          });\n        }\n        if (n && d) {\n          f.forEach(f => {\n            f = f.getThresholdAlignment(c);\n            b(f) && k.push(f);\n          });\n          const a = 1 < k.length ? k.reduce((b, c) => b + c, 0) / k.length : void 0;\n          f.forEach(b => {\n            b.thresholdAlignment = a;\n          });\n        }\n        return n;\n      }\n      getThresholdAlignment(c) {\n        (!b(this.dataMin) || this !== c && this.series.some(b => b.isDirty || b.isDirtyData)) && this.getSeriesExtremes();\n        if (b(this.threshold)) return c = h((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (c = 1 - c), c;\n      }\n      getTickAmount() {\n        const b = this.options,\n          c = b.tickPixelInterval;\n        let f = b.tickAmount;\n        !e(b.tickInterval) && !f && this.len < c && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (f = 2);\n        !f && this.alignToOthers() && (f = Math.ceil(this.len / c) + 1);\n        4 > f && (this.finalTickAmt = f, f = 5);\n        this.tickAmount = f;\n      }\n      adjustTickAmount() {\n        const c = this,\n          {\n            finalTickAmt: f,\n            max: a,\n            min: d,\n            options: k,\n            tickPositions: n,\n            tickAmount: q,\n            thresholdAlignment: h\n          } = c,\n          r = n && n.length;\n        var m = D(c.threshold, c.softThreshold ? 0 : null);\n        var l = c.tickInterval;\n        let p;\n        b(h) && (p = .5 > h ? Math.ceil(h * (q - 1)) : Math.floor(h * (q - 1)), k.reversed && (p = q - 1 - p));\n        if (c.hasData() && b(d) && b(a)) {\n          const h = () => {\n            c.transA *= (r - 1) / (q - 1);\n            c.min = k.startOnTick ? n[0] : Math.min(d, n[0]);\n            c.max = k.endOnTick ? n[n.length - 1] : Math.max(a, n[n.length - 1]);\n          };\n          if (b(p) && b(c.threshold)) {\n            for (; n[p] !== m || n.length !== q || n[0] > d || n[n.length - 1] < a;) {\n              n.length = 0;\n              for (n.push(c.threshold); n.length < q;) void 0 === n[p] || n[p] > c.threshold ? n.unshift(g(n[0] - l)) : n.push(g(n[n.length - 1] + l));\n              if (l > 8 * c.tickInterval) break;\n              l *= 2;\n            }\n            h();\n          } else if (r < q) {\n            for (; n.length < q;) n.length % 2 || d === m ? n.push(g(n[n.length - 1] + l)) : n.unshift(g(n[0] - l));\n            h();\n          }\n          if (e(f)) {\n            for (l = m = n.length; l--;) (3 === f && 1 === l % 2 || 2 >= f && 0 < l && l < m - 1) && n.splice(l, 1);\n            c.finalTickAmt = void 0;\n          }\n        }\n      }\n      setScale() {\n        let b = !1,\n          c = !1;\n        this.series.forEach(function (f) {\n          b = b || f.isDirtyData || f.isDirty;\n          c = c || f.xAxis && f.xAxis.isDirty || !1;\n        });\n        this.setAxisSize();\n        const f = this.len !== (this.old && this.old.len);\n        f || b || c || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && (this.stacking.resetStacks(), this.stacking.buildStacks()), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = f || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();\n        b && this.panningState && (this.panningState.isDirty = !0);\n        k(this, \"afterSetScale\");\n      }\n      setExtremes(b, c, f, a, n) {\n        const e = this,\n          q = e.chart;\n        f = D(f, !0);\n        e.series.forEach(function (b) {\n          delete b.kdTree;\n        });\n        n = d(n, {\n          min: b,\n          max: c\n        });\n        k(e, \"setExtremes\", n, function () {\n          e.userMin = b;\n          e.userMax = c;\n          e.eventArgs = n;\n          f && q.redraw(a);\n        });\n      }\n      zoom(b, c) {\n        const f = this,\n          a = this.dataMin,\n          d = this.dataMax,\n          n = this.options,\n          q = Math.min(a, D(n.min, a)),\n          g = Math.max(d, D(n.max, d));\n        b = {\n          newMin: b,\n          newMax: c\n        };\n        k(this, \"zoom\", b, function (b) {\n          let c = b.newMin,\n            n = b.newMax;\n          if (c !== f.min || n !== f.max) f.allowZoomOutside || (e(a) && (c < q && (c = q), c > g && (c = g)), e(d) && (n < q && (n = q), n > g && (n = g))), f.displayBtn = \"undefined\" !== typeof c || \"undefined\" !== typeof n, f.setExtremes(c, n, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          b.zoomed = !0;\n        });\n        return b.zoomed;\n      }\n      setAxisSize() {\n        const b = this.chart;\n        var c = this.options;\n        const f = c.offsets || [0, 0, 0, 0],\n          a = this.horiz,\n          d = this.width = Math.round(K(D(c.width, b.plotWidth - f[3] + f[1]), b.plotWidth)),\n          n = this.height = Math.round(K(D(c.height, b.plotHeight - f[0] + f[2]), b.plotHeight)),\n          k = this.top = Math.round(K(D(c.top, b.plotTop + f[0]), b.plotHeight, b.plotTop));\n        c = this.left = Math.round(K(D(c.left, b.plotLeft + f[3]), b.plotWidth, b.plotLeft));\n        this.bottom = b.chartHeight - n - k;\n        this.right = b.chartWidth - d - c;\n        this.len = Math.max(a ? d : n, 0);\n        this.pos = a ? c : k;\n      }\n      getExtremes() {\n        const b = this.logarithmic;\n        return {\n          min: b ? g(b.lin2log(this.min)) : this.min,\n          max: b ? g(b.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      }\n      getThreshold(b) {\n        var c = this.logarithmic;\n        const f = c ? c.lin2log(this.min) : this.min;\n        c = c ? c.lin2log(this.max) : this.max;\n        null === b || -Infinity === b ? b = f : Infinity === b ? b = c : f > b ? b = f : c < b && (b = c);\n        return this.translate(b, 0, 1, 0, 1);\n      }\n      autoLabelAlign(b) {\n        const c = (D(b, 0) - 90 * this.side + 720) % 360;\n        b = {\n          align: \"center\"\n        };\n        k(this, \"autoLabelAlign\", b, function (b) {\n          15 < c && 165 > c ? b.align = \"right\" : 195 < c && 345 > c && (b.align = \"left\");\n        });\n        return b.align;\n      }\n      tickSize(b) {\n        const c = this.options,\n          f = D(c[\"tick\" === b ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === b && this.isXAxis && !this.categories ? 1 : 0);\n        let a = c[\"tick\" === b ? \"tickLength\" : \"minorTickLength\"],\n          d;\n        f && a && (\"inside\" === c[b + \"Position\"] && (a = -a), d = [a, f]);\n        b = {\n          tickSize: d\n        };\n        k(this, \"afterTickSize\", b);\n        return b.tickSize;\n      }\n      labelMetrics() {\n        const b = this.chart.renderer;\n        var c = this.ticks;\n        c = c[Object.keys(c)[0]] || {};\n        return this.chart.renderer.fontMetrics(c.label || c.movedLabel || b.box);\n      }\n      unsquish() {\n        const c = this.options.labels;\n        var f = this.horiz;\n        const a = this.tickInterval,\n          d = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a),\n          n = c.rotation,\n          k = .75 * this.labelMetrics().h,\n          e = Math.max(this.max - this.min, 0),\n          q = function (b) {\n            let c = b / (d || 1);\n            c = 1 < c ? Math.ceil(c) : 1;\n            c * a > e && Infinity !== b && Infinity !== d && e && (c = Math.ceil(e / a));\n            return g(c * a);\n          };\n        let h = a,\n          r,\n          l = Number.MAX_VALUE,\n          m;\n        if (f) {\n          if (c.staggerLines || (b(n) ? m = [n] : d < c.autoRotationLimit && (m = c.autoRotation)), m) {\n            let b;\n            for (const c of m) if (c === n || c && -90 <= c && 90 >= c) f = q(Math.abs(k / Math.sin(p * c))), b = f + Math.abs(c / 360), b < l && (l = b, r = c, h = f);\n          }\n        } else h = q(k);\n        this.autoRotation = m;\n        this.labelRotation = D(r, b(n) ? n : 0);\n        return c.step ? a : h;\n      }\n      getSlotWidth(c) {\n        const f = this.chart,\n          a = this.horiz,\n          d = this.options.labels,\n          n = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n          k = f.margin[3];\n        if (c && b(c.slotWidth)) return c.slotWidth;\n        if (a && 2 > d.step) return d.rotation ? 0 : (this.staggerLines || 1) * this.len / n;\n        if (!a) {\n          c = d.style.width;\n          if (void 0 !== c) return parseInt(String(c), 10);\n          if (k) return k - f.spacing[3];\n        }\n        return .33 * f.chartWidth;\n      }\n      renderUnsquish() {\n        const b = this.chart,\n          c = b.renderer,\n          a = this.tickPositions,\n          d = this.ticks,\n          n = this.options.labels,\n          k = n.style,\n          e = this.horiz,\n          q = this.getSlotWidth();\n        var g = Math.max(1, Math.round(q - 2 * n.padding));\n        const h = {},\n          r = this.labelMetrics(),\n          m = k.textOverflow;\n        let l,\n          p,\n          D = 0;\n        f(n.rotation) || (h.rotation = n.rotation || 0);\n        a.forEach(function (b) {\n          b = d[b];\n          b.movedLabel && b.replaceMovedLabel();\n          b && b.label && b.label.textPxLength > D && (D = b.label.textPxLength);\n        });\n        this.maxLabelLength = D;\n        if (this.autoRotation) D > g && D > r.h ? h.rotation = this.labelRotation : this.labelRotation = 0;else if (q && (l = g, !m)) for (p = \"clip\", g = a.length; !e && g--;) {\n          var t = a[g];\n          if (t = d[t].label) t.styles && \"ellipsis\" === t.styles.textOverflow ? t.css({\n            textOverflow: \"clip\"\n          }) : t.textPxLength > q && t.css({\n            width: q + \"px\"\n          }), t.getBBox().height > this.len / a.length - (r.h - r.f) && (t.specificTextOverflow = \"ellipsis\");\n        }\n        h.rotation && (l = D > .5 * b.chartHeight ? .33 * b.chartHeight : D, m || (p = \"ellipsis\"));\n        if (this.labelAlign = n.align || this.autoLabelAlign(this.labelRotation)) h.align = this.labelAlign;\n        a.forEach(function (b) {\n          const c = (b = d[b]) && b.label,\n            f = k.width,\n            a = {};\n          c && (c.attr(h), b.shortenLabel ? b.shortenLabel() : l && !f && \"nowrap\" !== k.whiteSpace && (l < c.textPxLength || \"SPAN\" === c.element.tagName) ? (a.width = l + \"px\", m || (a.textOverflow = c.specificTextOverflow || p), c.css(a)) : c.styles && c.styles.width && !a.width && !f && c.css({\n            width: null\n          }), delete c.specificTextOverflow, b.rotation = h.rotation);\n        }, this);\n        this.tickRotCorr = c.rotCorr(r.b, this.labelRotation || 0, 0 !== this.side);\n      }\n      hasData() {\n        return this.series.some(function (b) {\n          return b.hasData();\n        }) || this.options.showEmpty && e(this.min) && e(this.max);\n      }\n      addTitle(b) {\n        const f = this.chart.renderer,\n          a = this.horiz,\n          d = this.opposite,\n          n = this.options.title,\n          k = this.chart.styledMode;\n        let e;\n        this.axisTitle || ((e = n.textAlign) || (e = (a ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: d ? \"right\" : \"left\",\n          middle: \"center\",\n          high: d ? \"left\" : \"right\"\n        })[n.align]), this.axisTitle = f.text(n.text || \"\", 0, 0, n.useHTML).attr({\n          zIndex: 7,\n          rotation: n.rotation,\n          align: e\n        }).addClass(\"highcharts-axis-title\"), k || this.axisTitle.css(c(n.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        k || n.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        });\n        this.axisTitle[b ? \"show\" : \"hide\"](b);\n      }\n      generateTick(b) {\n        const c = this.ticks;\n        c[b] ? c[b].addLabel() : c[b] = new H(this, b);\n      }\n      getOffset() {\n        const c = this,\n          {\n            chart: f,\n            horiz: a,\n            options: d,\n            side: n,\n            ticks: q,\n            tickPositions: g,\n            coll: h,\n            axisParent: r\n          } = c,\n          m = f.renderer,\n          l = f.inverted && !c.isZAxis ? [1, 0, 3, 2][n] : n;\n        var p = c.hasData();\n        const t = d.title;\n        var w = d.labels;\n        const K = b(d.crossing);\n        var G = f.axisOffset;\n        const R = f.clipOffset,\n          Q = [-1, 1, 1, -1][n],\n          v = d.className;\n        let ja,\n          u = 0,\n          x;\n        var E = 0;\n        let F = 0;\n        c.showAxis = ja = p || d.showEmpty;\n        c.staggerLines = c.horiz && w.staggerLines || void 0;\n        if (!c.axisGroup) {\n          const b = (b, c, f) => m.g(b).attr({\n            zIndex: f\n          }).addClass(`highcharts-${h.toLowerCase()}${c} ` + (this.isRadial ? `highcharts-radial-axis${c} ` : \"\") + (v || \"\")).add(r);\n          c.gridGroup = b(\"grid\", \"-grid\", d.gridZIndex);\n          c.axisGroup = b(\"axis\", \"\", d.zIndex);\n          c.labelGroup = b(\"axis-labels\", \"-labels\", w.zIndex);\n        }\n        p || c.isLinked ? (g.forEach(function (b) {\n          c.generateTick(b);\n        }), c.renderUnsquish(), c.reserveSpaceDefault = 0 === n || 2 === n || {\n          1: \"left\",\n          3: \"right\"\n        }[n] === c.labelAlign, D(w.reserveSpace, K ? !1 : null, \"center\" === c.labelAlign ? !0 : null, c.reserveSpaceDefault) && g.forEach(function (b) {\n          F = Math.max(q[b].getLabelSize(), F);\n        }), c.staggerLines && (F *= c.staggerLines), c.labelOffset = F * (c.opposite ? -1 : 1)) : P(q, function (b, c) {\n          b.destroy();\n          delete q[c];\n        });\n        t && t.text && !1 !== t.enabled && (c.addTitle(ja), ja && !K && !1 !== t.reserveSpace && (c.titleOffset = u = c.axisTitle.getBBox()[a ? \"height\" : \"width\"], x = t.offset, E = e(x) ? 0 : D(t.margin, a ? 5 : 10)));\n        c.renderLine();\n        c.offset = Q * D(d.offset, G[n] ? G[n] + (d.margin || 0) : 0);\n        c.tickRotCorr = c.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        p = 0 === n ? -c.labelMetrics().h : 2 === n ? c.tickRotCorr.y : 0;\n        E = Math.abs(F) + E;\n        F && (E = E - p + Q * (a ? D(w.y, c.tickRotCorr.y + Q * w.distance) : D(w.x, Q * w.distance)));\n        c.axisTitleMargin = D(x, E);\n        c.getMaxLabelDimensions && (c.maxLabelDimensions = c.getMaxLabelDimensions(q, g));\n        \"colorAxis\" !== h && (w = this.tickSize(\"tick\"), G[n] = Math.max(G[n], (c.axisTitleMargin || 0) + u + Q * c.offset, E, g && g.length && w ? w[0] + Q * c.offset : 0), G = !c.axisLine || d.offset ? 0 : 2 * Math.floor(c.axisLine.strokeWidth() / 2), R[l] = Math.max(R[l], G));\n        k(this, \"afterGetOffset\");\n      }\n      getLinePath(b) {\n        const c = this.chart,\n          f = this.opposite;\n        var a = this.offset;\n        const d = this.horiz,\n          n = this.left + (f ? this.width : 0) + a;\n        a = c.chartHeight - this.bottom - (f ? this.height : 0) + a;\n        f && (b *= -1);\n        return c.renderer.crispLine([[\"M\", d ? this.left : n, d ? a : this.top], [\"L\", d ? c.chartWidth - this.right : n, d ? a : c.chartHeight - this.bottom]], b);\n      }\n      renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      }\n      getTitlePosition(b) {\n        var c = this.horiz,\n          f = this.left;\n        const a = this.top;\n        var d = this.len;\n        const n = this.options.title,\n          e = c ? f : a,\n          q = this.opposite,\n          g = this.offset,\n          h = n.x,\n          r = n.y,\n          l = this.chart.renderer.fontMetrics(b);\n        b = b ? Math.max(b.getBBox(!1, 0).height - l.h - 1, 0) : 0;\n        d = {\n          low: e + (c ? 0 : d),\n          middle: e + d / 2,\n          high: e + (c ? d : 0)\n        }[n.align];\n        f = (c ? a + this.height : f) + (c ? 1 : -1) * (q ? -1 : 1) * (this.axisTitleMargin || 0) + [-b, b, l.f, -b][this.side];\n        c = {\n          x: c ? d + h : f + (q ? this.width : 0) + g + h,\n          y: c ? f + r - (q ? this.height : 0) + g : d + r\n        };\n        k(this, \"afterGetTitlePosition\", {\n          titlePosition: c\n        });\n        return c;\n      }\n      renderMinorTick(b, c) {\n        const f = this.minorTicks;\n        f[b] || (f[b] = new H(this, b, \"minor\"));\n        c && f[b].isNew && f[b].render(null, !0);\n        f[b].render(null, !1, 1);\n      }\n      renderTick(b, c, f) {\n        const a = this.ticks;\n        if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) a[b] || (a[b] = new H(this, b)), f && a[b].isNew && a[b].render(c, !0, -1), a[b].render(c);\n      }\n      render() {\n        const c = this,\n          f = c.chart,\n          a = c.logarithmic,\n          d = c.options,\n          n = c.isLinked,\n          e = c.tickPositions,\n          q = c.axisTitle,\n          g = c.ticks,\n          h = c.minorTicks,\n          r = c.alternateBands,\n          l = d.stackLabels,\n          m = d.alternateGridColor;\n        var p = d.crossing;\n        const D = c.tickmarkOffset,\n          t = c.axisLine,\n          w = c.showAxis,\n          K = u(f.renderer.globalAnimation);\n        let Q, G;\n        c.labelEdge.length = 0;\n        c.overlap = !1;\n        [g, h, r].forEach(function (b) {\n          P(b, function (b) {\n            b.isActive = !1;\n          });\n        });\n        if (b(p)) {\n          const b = this.isXAxis ? f.yAxis[0] : f.xAxis[0],\n            a = [1, -1, -1, 1][this.side];\n          b && (p = b.toPixels(p, !0), c.horiz && (p = b.len - p), c.offset = a * p);\n        }\n        if (c.hasData() || n) {\n          const n = c.chart.hasRendered && c.old && b(c.old.min);\n          c.minorTickInterval && !c.categories && c.getMinorTickPositions().forEach(function (b) {\n            c.renderMinorTick(b, n);\n          });\n          e.length && (e.forEach(function (b, f) {\n            c.renderTick(b, f, n);\n          }), D && (0 === c.min || c.single) && (g[-1] || (g[-1] = new H(c, -1, null, !0)), g[-1].render(-1)));\n          m && e.forEach(function (b, d) {\n            G = \"undefined\" !== typeof e[d + 1] ? e[d + 1] + D : c.max - D;\n            0 === d % 2 && b < c.max && G <= c.max + (f.polar ? -D : D) && (r[b] || (r[b] = new z.PlotLineOrBand(c)), Q = b + D, r[b].options = {\n              from: a ? a.lin2log(Q) : Q,\n              to: a ? a.lin2log(G) : G,\n              color: m,\n              className: \"highcharts-alternate-grid\"\n            }, r[b].render(), r[b].isActive = !0);\n          });\n          c._addedPlotLB || (c._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(function (b) {\n            c.addPlotBandOrLine(b);\n          }));\n        }\n        [g, h, r].forEach(function (b) {\n          const c = [],\n            a = K.duration;\n          P(b, function (b, f) {\n            b.isActive || (b.render(f, !1, 0), b.isActive = !1, c.push(f));\n          });\n          Z(function () {\n            let f = c.length;\n            for (; f--;) b[c[f]] && !b[c[f]].isActive && (b[c[f]].destroy(), delete b[c[f]]);\n          }, b !== r && f.hasRendered && a ? a : 0);\n        });\n        t && (t[t.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(t.strokeWidth())\n        }), t.isPlaced = !0, t[w ? \"show\" : \"hide\"](w));\n        q && w && (q[q.isNew ? \"attr\" : \"animate\"](c.getTitlePosition(q)), q.isNew = !1);\n        l && l.enabled && c.stacking && c.stacking.renderStackTotals();\n        c.old = {\n          len: c.len,\n          max: c.max,\n          min: c.min,\n          transA: c.transA,\n          userMax: c.userMax,\n          userMin: c.userMin\n        };\n        c.isDirty = !1;\n        k(this, \"afterRender\");\n      }\n      redraw() {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {\n          b.render();\n        }));\n        this.series.forEach(function (b) {\n          b.isDirty = !0;\n        });\n      }\n      getKeepProps() {\n        return this.keepProps || Y.keepProps;\n      }\n      destroy(b) {\n        const c = this,\n          f = c.plotLinesAndBands,\n          a = this.eventOptions;\n        k(this, \"destroy\", {\n          keepEvents: b\n        });\n        b || X(c);\n        [c.ticks, c.minorTicks, c.alternateBands].forEach(function (b) {\n          w(b);\n        });\n        if (f) for (b = f.length; b--;) f[b].destroy();\n        \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (b) {\n          c[b] && (c[b] = c[b].destroy());\n        });\n        for (const b in c.plotLinesAndBandsGroups) c.plotLinesAndBandsGroups[b] = c.plotLinesAndBandsGroups[b].destroy();\n        P(c, function (b, f) {\n          -1 === c.getKeepProps().indexOf(f) && delete c[f];\n        });\n        this.eventOptions = a;\n      }\n      drawCrosshair(b, c) {\n        const f = this.crosshair;\n        var a = D(f && f.snap, !0);\n        const n = this.chart;\n        let q,\n          g = this.cross;\n        k(this, \"drawCrosshair\", {\n          e: b,\n          point: c\n        });\n        b || (b = this.cross && this.cross.e);\n        if (f && !1 !== (e(c) || !a)) {\n          a ? e(c) && (q = D(\"colorAxis\" !== this.coll ? c.crosshairPos : null, this.isXAxis ? c.plotX : this.len - c.plotY)) : q = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);\n          if (e(q)) {\n            var h = {\n              value: c && (this.isXAxis ? c.x : D(c.stackY, c.y)),\n              translatedValue: q\n            };\n            n.polar && d(h, {\n              isCrosshair: !0,\n              chartX: b && b.chartX,\n              chartY: b && b.chartY,\n              point: c\n            });\n            h = this.getPlotLinePath(h) || null;\n          }\n          if (!e(h)) {\n            this.hideCrosshair();\n            return;\n          }\n          a = this.categories && !this.isRadial;\n          g || (this.cross = g = n.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (a ? \"category \" : \"thin \") + (f.className || \"\")).attr({\n            zIndex: D(f.zIndex, 2)\n          }).add(), n.styledMode || (g.attr({\n            stroke: f.color || (a ? I.parse(\"#ccd3ff\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": D(f.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), f.dashStyle && g.attr({\n            dashstyle: f.dashStyle\n          })));\n          g.show().attr({\n            d: h\n          });\n          a && !f.width && g.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = b;\n        } else this.hideCrosshair();\n        k(this, \"afterDrawCrosshair\", {\n          e: b,\n          point: c\n        });\n      }\n      hideCrosshair() {\n        this.cross && this.cross.hide();\n        k(this, \"afterHideCrosshair\");\n      }\n      hasVerticalPanning() {\n        const b = this.chart.options.chart.panning;\n        return !!(b && b.enabled && /y/.test(b.type));\n      }\n      update(b, f) {\n        const a = this.chart;\n        b = c(this.userOptions, b);\n        this.destroy(!0);\n        this.init(a, b);\n        a.isDirtyBox = !0;\n        D(f, !0) && a.redraw();\n      }\n      remove(b) {\n        const c = this.chart,\n          f = this.coll,\n          a = this.series;\n        let d = a.length;\n        for (; d--;) a[d] && a[d].remove(!1);\n        x(c.axes, this);\n        x(c[f] || [], this);\n        c.orderItems(f);\n        this.destroy();\n        c.isDirtyBox = !0;\n        D(b, !0) && c.redraw();\n      }\n      setTitle(b, c) {\n        this.update({\n          title: b\n        }, c);\n      }\n      setCategories(b, c) {\n        this.update({\n          categories: b\n        }, c);\n      }\n    }\n    Y.defaultOptions = y.defaultXAxisOptions;\n    Y.keepProps = \"coll extKey hcEvents names series userMax userMin\".split(\" \");\n    \"\";\n    return Y;\n  });\n  M(a, \"Core/Axis/DateTimeAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: x,\n      getMagnitude: I,\n      normalizeTickInterval: L,\n      timeUnits: C\n    } = a;\n    var z;\n    (function (y) {\n      function B() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n      function u(a) {\n        \"datetime\" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new l(this));\n      }\n      const v = [];\n      y.compose = function (l) {\n        a.pushUnique(v, l) && (l.keepProps.push(\"dateTime\"), l.prototype.getTimeTicks = B, x(l, \"init\", u));\n        return l;\n      };\n      class l {\n        constructor(a) {\n          this.axis = a;\n        }\n        normalizeTimeTickInterval(a, l) {\n          const m = l || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n          l = m[m.length - 1];\n          let h = C[l[0]],\n            g = l[1],\n            e;\n          for (e = 0; e < m.length && !(l = m[e], h = C[l[0]], g = l[1], m[e + 1] && a <= (h * g[g.length - 1] + C[m[e + 1][0]]) / 2); e++);\n          h === C.year && a < 5 * h && (g = [1, 2, 5]);\n          a = L(a / h, g, \"year\" === l[0] ? Math.max(I(a / h), 1) : 1);\n          return {\n            unitRange: h,\n            count: a,\n            unitName: l[0]\n          };\n        }\n        getXDateFormat(a, l) {\n          const {\n              axis: m\n            } = this,\n            h = m.chart.time;\n          return m.closestPointRange ? h.getDateFormat(m.closestPointRange, a, m.options.startOfWeek, l) || h.resolveDTLFormat(l.year).main : h.resolveDTLFormat(l.day).main;\n        }\n      }\n      y.Additions = l;\n    })(z || (z = {}));\n    return z;\n  });\n  M(a, \"Core/Axis/LogarithmicAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      addEvent: x,\n      normalizeTickInterval: I,\n      pick: L\n    } = a;\n    var C;\n    (function (y) {\n      function H(a) {\n        let l = this.logarithmic;\n        \"logarithmic\" !== a.userOptions.type ? this.logarithmic = void 0 : l || (this.logarithmic = new v(this));\n      }\n      function B() {\n        const a = this.logarithmic;\n        a && (this.lin2val = function (l) {\n          return a.lin2log(l);\n        }, this.val2lin = function (l) {\n          return a.log2lin(l);\n        });\n      }\n      const u = [];\n      y.compose = function (l) {\n        a.pushUnique(u, l) && (l.keepProps.push(\"logarithmic\"), x(l, \"init\", H), x(l, \"afterInit\", B));\n        return l;\n      };\n      class v {\n        constructor(a) {\n          this.axis = a;\n        }\n        getLogTickPositions(a, p, t, m) {\n          const h = this.axis;\n          var g = h.len,\n            e = h.options;\n          let l = [];\n          m || (this.minorAutoInterval = void 0);\n          if (.5 <= a) a = Math.round(a), l = h.getLinearTickPositions(a, p, t);else if (.08 <= a) {\n            e = Math.floor(p);\n            let h, w, d, k, r;\n            for (g = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; e < t + 1 && !r; e++) for (w = g.length, h = 0; h < w && !r; h++) d = this.log2lin(this.lin2log(e) * g[h]), d > p && (!m || k <= t) && \"undefined\" !== typeof k && l.push(k), k > t && (r = !0), k = d;\n          } else p = this.lin2log(p), t = this.lin2log(t), a = m ? h.getMinorTickInterval() : e.tickInterval, a = L(\"auto\" === a ? null : a, this.minorAutoInterval, e.tickPixelInterval / (m ? 5 : 1) * (t - p) / ((m ? g / h.tickPositions.length : g) || 1)), a = I(a), l = h.getLinearTickPositions(a, p, t).map(this.log2lin), m || (this.minorAutoInterval = a / 5);\n          m || (h.tickInterval = a);\n          return l;\n        }\n        lin2log(a) {\n          return Math.pow(10, a);\n        }\n        log2lin(a) {\n          return Math.log(a) / Math.LN10;\n        }\n      }\n      y.Additions = v;\n    })(C || (C = {}));\n    return C;\n  });\n  M(a, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      erase: x,\n      extend: I,\n      isNumber: L\n    } = a;\n    var C;\n    (function (y) {\n      function H(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      }\n      function B(a, e) {\n        const g = this.userOptions;\n        let l = new h(this, a);\n        this.visible && (l = l.render());\n        if (l) {\n          this._addedPlotLB || (this._addedPlotLB = !0, (g.plotLines || []).concat(g.plotBands || []).forEach(a => {\n            this.addPlotBandOrLine(a);\n          }));\n          if (e) {\n            const h = g[e] || [];\n            h.push(a);\n            g[e] = h;\n          }\n          this.plotLinesAndBands.push(l);\n        }\n        return l;\n      }\n      function u(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      }\n      function v(a, e, h = this.options) {\n        const g = this.getPlotLinePath({\n            value: e,\n            force: !0,\n            acrossPanes: h.acrossPanes\n          }),\n          l = [],\n          d = this.horiz;\n        e = !L(this.min) || !L(this.max) || a < this.min && e < this.min || a > this.max && e > this.max;\n        a = this.getPlotLinePath({\n          value: a,\n          force: !0,\n          acrossPanes: h.acrossPanes\n        });\n        h = 1;\n        let k;\n        if (a && g) for (e && (k = a.toString() === g.toString(), h = 0), e = 0; e < a.length; e += 2) {\n          const r = a[e],\n            q = a[e + 1],\n            m = g[e],\n            b = g[e + 1];\n          \"M\" !== r[0] && \"L\" !== r[0] || \"M\" !== q[0] && \"L\" !== q[0] || \"M\" !== m[0] && \"L\" !== m[0] || \"M\" !== b[0] && \"L\" !== b[0] || (d && m[1] === r[1] ? (m[1] += h, b[1] += h) : d || m[2] !== r[2] || (m[2] += h, b[2] += h), l.push([\"M\", r[1], r[2]], [\"L\", q[1], q[2]], [\"L\", b[1], b[2]], [\"L\", m[1], m[2]], [\"Z\"]));\n          l.isFlat = k;\n        }\n        return l;\n      }\n      function l(a) {\n        this.removePlotBandOrLine(a);\n      }\n      function p(a) {\n        const e = this.plotLinesAndBands,\n          g = this.options,\n          h = this.userOptions;\n        if (e) {\n          let l = e.length;\n          for (; l--;) e[l].id === a && e[l].destroy();\n          [g.plotLines || [], h.plotLines || [], g.plotBands || [], h.plotBands || []].forEach(function (d) {\n            for (l = d.length; l--;) (d[l] || {}).id === a && x(d, d[l]);\n          });\n        }\n      }\n      function t(a) {\n        this.removePlotBandOrLine(a);\n      }\n      const m = [];\n      let h;\n      y.compose = function (g, e) {\n        h || (h = g);\n        a.pushUnique(m, e) && I(e.prototype, {\n          addPlotBand: H,\n          addPlotLine: u,\n          addPlotBandOrLine: B,\n          getPlotBandPath: v,\n          removePlotBand: l,\n          removePlotLine: t,\n          removePlotBandOrLine: p\n        });\n        return e;\n      };\n    })(C || (C = {}));\n    return C;\n  });\n  M(a, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [a[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n      arrayMax: x,\n      arrayMin: L,\n      defined: C,\n      destroyObjectProperties: z,\n      erase: H,\n      fireEvent: B,\n      merge: u,\n      objectEach: v,\n      pick: l\n    } = y;\n    class p {\n      static compose(l) {\n        return a.compose(p, l);\n      }\n      constructor(a, l) {\n        this.axis = a;\n        l && (this.options = l, this.id = l.id);\n      }\n      render() {\n        B(this, \"render\");\n        const a = this,\n          m = a.axis,\n          h = m.horiz;\n        var g = m.logarithmic;\n        const e = a.options,\n          p = e.color,\n          x = l(e.zIndex, 0),\n          F = e.events,\n          d = {},\n          k = m.chart.renderer;\n        let r = e.label,\n          q = a.label,\n          G = e.to,\n          b = e.from,\n          f = e.value,\n          c = a.svgElem;\n        var n = [];\n        const P = C(b) && C(G);\n        n = C(f);\n        const D = !c,\n          K = {\n            \"class\": \"highcharts-plot-\" + (P ? \"band \" : \"line \") + (e.className || \"\")\n          };\n        let X = P ? \"bands\" : \"lines\";\n        g && (b = g.log2lin(b), G = g.log2lin(G), f = g.log2lin(f));\n        m.chart.styledMode || (n ? (K.stroke = p || \"#999999\", K[\"stroke-width\"] = l(e.width, 1), e.dashStyle && (K.dashstyle = e.dashStyle)) : P && (K.fill = p || \"#e6e9ff\", e.borderWidth && (K.stroke = e.borderColor, K[\"stroke-width\"] = e.borderWidth)));\n        d.zIndex = x;\n        X += \"-\" + x;\n        (g = m.plotLinesAndBandsGroups[X]) || (m.plotLinesAndBandsGroups[X] = g = k.g(\"plot-\" + X).attr(d).add());\n        D && (a.svgElem = c = k.path().attr(K).add(g));\n        if (n) n = m.getPlotLinePath({\n          value: f,\n          lineWidth: c.strokeWidth(),\n          acrossPanes: e.acrossPanes\n        });else if (P) n = m.getPlotBandPath(b, G, e);else return;\n        !a.eventsAdded && F && (v(F, function (b, f) {\n          c.on(f, function (b) {\n            F[f].apply(a, [b]);\n          });\n        }), a.eventsAdded = !0);\n        (D || !c.d) && n && n.length ? c.attr({\n          d: n\n        }) : c && (n ? (c.show(), c.animate({\n          d: n\n        })) : c.d && (c.hide(), q && (a.label = q = q.destroy())));\n        r && (C(r.text) || C(r.formatter)) && n && n.length && 0 < m.width && 0 < m.height && !n.isFlat ? (r = u({\n          align: h && P && \"center\",\n          x: h ? !P && 4 : 10,\n          verticalAlign: !h && P && \"middle\",\n          y: h ? P ? 16 : 10 : P ? 6 : -4,\n          rotation: h && !P && 90\n        }, r), this.renderLabel(r, n, P, x)) : q && q.hide();\n        return a;\n      }\n      renderLabel(a, l, h, g) {\n        const e = this.axis;\n        var m = e.chart.renderer;\n        let p = this.label;\n        p || (this.label = p = m.text(this.getLabelText(a), 0, 0, a.useHTML).attr({\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (h ? \"band\" : \"line\") + \"-label \" + (a.className || \"\"),\n          zIndex: g\n        }).add(), e.chart.styledMode || p.css(u({\n          fontSize: \"0.8em\",\n          textOverflow: \"ellipsis\"\n        }, a.style)));\n        g = l.xBounds || [l[0][1], l[1][1], h ? l[2][1] : l[0][1]];\n        l = l.yBounds || [l[0][2], l[1][2], h ? l[2][2] : l[0][2]];\n        h = L(g);\n        m = L(l);\n        p.align(a, !1, {\n          x: h,\n          y: m,\n          width: x(g) - h,\n          height: x(l) - m\n        });\n        p.alignValue && \"left\" !== p.alignValue || (a = a.clip ? e.width : e.chart.chartWidth, p.css({\n          width: (90 === p.rotation ? e.height - (p.alignAttr.y - e.top) : a - (p.alignAttr.x - e.left)) + \"px\"\n        }));\n        p.show(!0);\n      }\n      getLabelText(a) {\n        return C(a.formatter) ? a.formatter.call(this) : a.text;\n      }\n      destroy() {\n        H(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        z(this);\n      }\n    }\n    \"\";\n    \"\";\n    return p;\n  });\n  M(a, \"Core/Tooltip.js\", [a[\"Core/Templating.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C) {\n    const {\n        format: x\n      } = a,\n      {\n        doc: H,\n        isSafari: B\n      } = y,\n      {\n        distribute: u\n      } = I,\n      {\n        addEvent: v,\n        clamp: l,\n        css: p,\n        discardElement: t,\n        extend: m,\n        fireEvent: h,\n        isArray: g,\n        isNumber: e,\n        isString: w,\n        merge: E,\n        pick: F,\n        splat: d,\n        syncTimeout: k\n      } = C;\n    class r {\n      constructor(a, d) {\n        this.allowShared = !0;\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = a;\n        this.init(a, d);\n      }\n      bodyFormatter(a) {\n        return a.map(function (a) {\n          const b = a.series.tooltipOptions;\n          return (b[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, b[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      }\n      cleanSplit(a) {\n        this.chart.series.forEach(function (d) {\n          const b = d && d.tt;\n          b && (!b.isActive || a ? d.tt = b.destroy() : b.isActive = !1);\n        });\n      }\n      defaultFormatter(a) {\n        const k = this.points || d(this);\n        let b;\n        b = [a.tooltipFooterHeaderFormatter(k[0])];\n        b = b.concat(a.bodyFormatter(k));\n        b.push(a.tooltipFooterHeaderFormatter(k[0], !0));\n        return b;\n      }\n      destroy() {\n        this.label && (this.label = this.label.destroy());\n        this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy()));\n        this.renderer && (this.renderer = this.renderer.destroy(), t(this.container));\n        C.clearTimeout(this.hideTimer);\n        C.clearTimeout(this.tooltipTimeout);\n      }\n      getAnchor(a, k) {\n        var b = this.chart;\n        const f = b.pointer,\n          c = b.inverted,\n          n = b.plotTop;\n        b = b.plotLeft;\n        a = d(a);\n        a[0].series && a[0].series.yAxis && !a[0].series.yAxis.options.reversedStacks && (a = a.slice().reverse());\n        if (this.followPointer && k) \"undefined\" === typeof k.chartX && (k = f.normalize(k)), a = [k.chartX - b, k.chartY - n];else if (a[0].tooltipPos) a = a[0].tooltipPos;else {\n          let f = 0,\n            d = 0;\n          a.forEach(function (b) {\n            if (b = b.pos(!0)) f += b[0], d += b[1];\n          });\n          f /= a.length;\n          d /= a.length;\n          this.shared && 1 < a.length && k && (c ? f = k.chartX : d = k.chartY);\n          a = [f - b, d - n];\n        }\n        return a.map(Math.round);\n      }\n      getClassName(a, d, b) {\n        const f = a.series,\n          c = f.options;\n        return [this.options.className, \"highcharts-label\", b && \"highcharts-tooltip-header\", d ? \"highcharts-tooltip-box\" : \"highcharts-tooltip\", !b && \"highcharts-color-\" + F(a.colorIndex, f.colorIndex), c && c.className].filter(w).join(\" \");\n      }\n      getLabel() {\n        const a = this,\n          d = this.chart.styledMode,\n          b = this.options,\n          f = this.split && this.allowShared,\n          c = b.style.pointerEvents || (this.shouldStickOnContact() ? \"auto\" : \"none\");\n        let n,\n          k = this.chart.renderer;\n        if (this.label) {\n          var e = !this.label.hasClass(\"highcharts-label\");\n          (!f && e || f && !e) && this.destroy();\n        }\n        if (!this.label) {\n          if (this.outside) {\n            e = this.chart.options.chart.style;\n            const b = L.getRendererType();\n            this.container = n = y.doc.createElement(\"div\");\n            n.className = \"highcharts-tooltip-container\";\n            p(n, {\n              position: \"absolute\",\n              top: \"1px\",\n              pointerEvents: c,\n              zIndex: Math.max(this.options.style.zIndex || 0, (e && e.zIndex || 0) + 3)\n            });\n            y.doc.body.appendChild(n);\n            this.renderer = k = new b(n, 0, 0, e, void 0, void 0, k.styledMode);\n          }\n          f ? this.label = k.g(\"tooltip\") : (this.label = k.label(\"\", 0, 0, b.shape, void 0, void 0, b.useHTML, void 0, \"tooltip\").attr({\n            padding: b.padding,\n            r: b.borderRadius\n          }), d || this.label.attr({\n            fill: b.backgroundColor,\n            \"stroke-width\": b.borderWidth || 0\n          }).css(b.style).css({\n            pointerEvents: c\n          }));\n          if (a.outside) {\n            const b = this.label,\n              {\n                xSetter: c,\n                ySetter: f\n              } = b;\n            b.xSetter = function (f) {\n              c.call(b, a.distance);\n              n.style.left = f + \"px\";\n            };\n            b.ySetter = function (c) {\n              f.call(b, a.distance);\n              n.style.top = c + \"px\";\n            };\n          }\n          this.label.attr({\n            zIndex: 8\n          }).shadow(b.shadow).add();\n        }\n        return this.label;\n      }\n      getPlayingField() {\n        const {\n            body: a,\n            documentElement: d\n          } = H,\n          {\n            chart: b,\n            distance: f,\n            outside: c\n          } = this;\n        return {\n          width: c ? Math.max(a.scrollWidth, d.scrollWidth, a.offsetWidth, d.offsetWidth, d.clientWidth) - 2 * f : b.chartWidth,\n          height: c ? Math.max(a.scrollHeight, d.scrollHeight, a.offsetHeight, d.offsetHeight, d.clientHeight) : b.chartHeight\n        };\n      }\n      getPosition(a, d, b) {\n        const f = this.chart,\n          c = this.distance,\n          n = {},\n          k = f.inverted && b.h || 0,\n          e = this.outside;\n        var q = this.getPlayingField();\n        const g = q.width,\n          h = q.height,\n          r = f.pointer.getChartPosition();\n        q = n => {\n          const k = \"x\" === n;\n          return [n, k ? g : h, k ? a : d].concat(e ? [k ? a * r.scaleX : d * r.scaleY, k ? r.left - c + (b.plotX + f.plotLeft) * r.scaleX : r.top - c + (b.plotY + f.plotTop) * r.scaleY, 0, k ? g : h] : [k ? a : d, k ? b.plotX + f.plotLeft : b.plotY + f.plotTop, k ? f.plotLeft : f.plotTop, k ? f.plotLeft + f.plotWidth : f.plotTop + f.plotHeight]);\n        };\n        let l = q(\"y\"),\n          m = q(\"x\"),\n          p;\n        q = !!b.negative;\n        !f.polar && f.hoverSeries && f.hoverSeries.yAxis && f.hoverSeries.yAxis.reversed && (q = !q);\n        const t = !this.followPointer && F(b.ttBelow, !f.inverted === q),\n          w = function (b, a, f, d, q, g, h) {\n            const l = e ? \"y\" === b ? c * r.scaleY : c * r.scaleX : c,\n              m = (f - d) / 2,\n              p = d < q - c,\n              J = q + c + d < a,\n              D = q - l - f + m;\n            q = q + l - m;\n            if (t && J) n[b] = q;else if (!t && p) n[b] = D;else if (p) n[b] = Math.min(h - d, 0 > D - k ? D : D - k);else if (J) n[b] = Math.max(g, q + k + f > a ? q : q + k);else return !1;\n          },\n          G = function (b, a, f, d, k) {\n            let e;\n            k < c || k > a - c ? e = !1 : n[b] = k < f / 2 ? 1 : k > a - d / 2 ? a - d - 2 : k - f / 2;\n            return e;\n          },\n          v = function (b) {\n            const c = l;\n            l = m;\n            m = c;\n            p = b;\n          },\n          J = function () {\n            !1 !== w.apply(0, l) ? !1 !== G.apply(0, m) || p || (v(!0), J()) : p ? n.x = n.y = 0 : (v(!0), J());\n          };\n        (f.inverted || 1 < this.len) && v();\n        J();\n        return n;\n      }\n      hide(a) {\n        const d = this;\n        C.clearTimeout(this.hideTimer);\n        a = F(a, this.options.hideDelay);\n        this.isHidden || (this.hideTimer = k(function () {\n          d.getLabel().fadeOut(a ? void 0 : a);\n          d.isHidden = !0;\n        }, a));\n      }\n      init(a, d) {\n        this.chart = a;\n        this.options = d;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = d.split && !a.inverted && !a.polar;\n        this.shared = d.shared || this.split;\n        this.outside = F(d.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));\n      }\n      shouldStickOnContact(a) {\n        return !(this.followPointer || !this.options.stickOnContact || a && !this.chart.pointer.inClass(a.target, \"highcharts-tooltip\"));\n      }\n      move(a, d, b, f) {\n        const c = this,\n          n = c.now,\n          k = !1 !== c.options.animation && !c.isHidden && (1 < Math.abs(a - n.x) || 1 < Math.abs(d - n.y)),\n          e = c.followPointer || 1 < c.len;\n        m(n, {\n          x: k ? (2 * n.x + a) / 3 : a,\n          y: k ? (n.y + d) / 2 : d,\n          anchorX: e ? void 0 : k ? (2 * n.anchorX + b) / 3 : b,\n          anchorY: e ? void 0 : k ? (n.anchorY + f) / 2 : f\n        });\n        c.getLabel().attr(n);\n        c.drawTracker();\n        k && (C.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          c && c.move(a, d, b, f);\n        }, 32));\n      }\n      refresh(a, k) {\n        const b = this.chart,\n          f = this.options,\n          c = b.pointer,\n          n = d(a),\n          e = n[0],\n          q = [];\n        var r = f.format,\n          l = f.formatter || this.defaultFormatter;\n        const m = this.shared,\n          p = b.styledMode;\n        let t = {};\n        if (f.enabled && e.series) {\n          C.clearTimeout(this.hideTimer);\n          this.allowShared = !(!g(a) && a.series && a.series.noSharedTooltip);\n          this.followPointer = !this.split && e.series.tooltipOptions.followPointer;\n          a = this.getAnchor(a, k);\n          var v = a[0],\n            G = a[1];\n          m && this.allowShared ? (c.applyInactiveState(n), n.forEach(function (b) {\n            b.setState(\"hover\");\n            q.push(b.getLabelConfig());\n          }), t = e.getLabelConfig(), t.points = q) : t = e.getLabelConfig();\n          this.len = q.length;\n          r = w(r) ? x(r, t, b) : l.call(t, this);\n          l = e.series;\n          this.distance = F(l.tooltipOptions.distance, 16);\n          if (!1 === r) this.hide();else {\n            if (this.split && this.allowShared) this.renderSplit(r, n);else {\n              let d = v,\n                g = G;\n              k && c.isDirectTouch && (d = k.chartX - b.plotLeft, g = k.chartY - b.plotTop);\n              if (b.polar || !1 === l.options.clip || n.some(b => c.isDirectTouch || b.series.shouldShowTooltip(d, g))) k = this.getLabel(), f.style.width && !p || k.css({\n                width: (this.outside ? this.getPlayingField() : b.spacingBox).width + \"px\"\n              }), k.attr({\n                text: r && r.join ? r.join(\"\") : r\n              }), k.addClass(this.getClassName(e), !0), p || k.attr({\n                stroke: f.borderColor || e.color || l.color || \"#666666\"\n              }), this.updatePosition({\n                plotX: v,\n                plotY: G,\n                negative: e.negative,\n                ttBelow: e.ttBelow,\n                h: a[2] || 0\n              });else {\n                this.hide();\n                return;\n              }\n            }\n            this.isHidden && this.label && this.label.attr({\n              opacity: 1\n            }).show();\n            this.isHidden = !1;\n          }\n          h(this, \"refresh\");\n        }\n      }\n      renderSplit(a, d) {\n        function b(b, c, a, d, n = !0) {\n          a ? (c = S ? 0 : z, b = l(b - d / 2, J.left, J.right - d - (f.outside ? W : 0))) : (c -= da, b = n ? b - d - x : b + x, b = l(b, n ? b : J.left, J.right));\n          return {\n            x: b,\n            y: c\n          };\n        }\n        const f = this,\n          {\n            chart: c,\n            chart: {\n              chartWidth: n,\n              chartHeight: k,\n              plotHeight: e,\n              plotLeft: g,\n              plotTop: h,\n              pointer: q,\n              scrollablePixelsY: r = 0,\n              scrollablePixelsX: p,\n              scrollingContainer: {\n                scrollLeft: t,\n                scrollTop: v\n              } = {\n                scrollLeft: 0,\n                scrollTop: 0\n              },\n              styledMode: G\n            },\n            distance: x,\n            options: E,\n            options: {\n              positioner: y\n            }\n          } = f,\n          J = f.outside && \"number\" !== typeof p ? H.documentElement.getBoundingClientRect() : {\n            left: t,\n            right: t + n,\n            top: v,\n            bottom: v + k\n          },\n          N = f.getLabel(),\n          O = this.renderer || c.renderer,\n          S = !(!c.xAxis[0] || !c.xAxis[0].opposite),\n          {\n            left: W,\n            top: ha\n          } = q.getChartPosition();\n        let da = h + v,\n          C = 0,\n          z = e - r;\n        w(a) && (a = [!1, a]);\n        a = a.slice(0, d.length + 1).reduce(function (c, a, n) {\n          if (!1 !== a && \"\" !== a) {\n            n = d[n - 1] || {\n              isHeader: !0,\n              plotX: d[0].plotX,\n              plotY: e,\n              series: {}\n            };\n            const D = n.isHeader;\n            var k = D ? f : n.series,\n              q;\n            {\n              var r = n;\n              a = a.toString();\n              var m = k.tt;\n              const {\n                isHeader: b,\n                series: c\n              } = r;\n              m || (m = {\n                padding: E.padding,\n                r: E.borderRadius\n              }, G || (m.fill = E.backgroundColor, m[\"stroke-width\"] = null !== (q = E.borderWidth) && void 0 !== q ? q : 1), m = O.label(\"\", 0, 0, E[b ? \"headerShape\" : \"shape\"], void 0, void 0, E.useHTML).addClass(f.getClassName(r, !0, b)).attr(m).add(N));\n              m.isActive = !0;\n              m.attr({\n                text: a\n              });\n              G || m.css(E.style).attr({\n                stroke: E.borderColor || r.color || c.color || \"#333333\"\n              });\n              q = m;\n            }\n            q = k.tt = q;\n            r = q.getBBox();\n            k = r.width + q.strokeWidth();\n            D && (C = r.height, z += C, S && (da -= C));\n            {\n              const {\n                isHeader: b,\n                plotX: c = 0,\n                plotY: f = 0,\n                series: d\n              } = n;\n              if (b) {\n                a = g + c;\n                var p = h + e / 2;\n              } else {\n                const {\n                  xAxis: b,\n                  yAxis: n\n                } = d;\n                a = b.pos + l(c, -x, b.len + x);\n                d.shouldShowTooltip(0, n.pos - h + f, {\n                  ignoreX: !0\n                }) && (p = n.pos + f);\n              }\n              a = l(a, J.left - x, J.right + x);\n              p = {\n                anchorX: a,\n                anchorY: p\n              };\n            }\n            const {\n              anchorX: t,\n              anchorY: Q\n            } = p;\n            \"number\" === typeof Q ? (p = r.height + 1, r = y ? y.call(f, k, p, n) : b(t, Q, D, k), c.push({\n              align: y ? 0 : void 0,\n              anchorX: t,\n              anchorY: Q,\n              boxWidth: k,\n              point: n,\n              rank: F(r.rank, D ? 1 : 0),\n              size: p,\n              target: r.y,\n              tt: q,\n              x: r.x\n            })) : q.isActive = !1;\n          }\n          return c;\n        }, []);\n        !y && a.some(b => {\n          var {\n            outside: c\n          } = f;\n          c = (c ? W : 0) + b.anchorX;\n          return c < J.left && c + b.boxWidth < J.right ? !0 : c < W - J.left + b.boxWidth && J.right - c > c;\n        }) && (a = a.map(c => {\n          const {\n            x: a,\n            y: f\n          } = b(c.anchorX, c.anchorY, c.point.isHeader, c.boxWidth, !1);\n          return m(c, {\n            target: f,\n            x: a\n          });\n        }));\n        f.cleanSplit();\n        u(a, z);\n        var ca = W,\n          L = W;\n        a.forEach(function (b) {\n          const {\n            x: c,\n            boxWidth: a,\n            isHeader: d\n          } = b;\n          d || (f.outside && W + c < ca && (ca = W + c), !d && f.outside && ca + a > L && (L = W + c));\n        });\n        a.forEach(function (b) {\n          const {\n              x: c,\n              anchorX: a,\n              anchorY: d,\n              pos: n,\n              point: {\n                isHeader: k\n              }\n            } = b,\n            e = {\n              visibility: \"undefined\" === typeof n ? \"hidden\" : \"inherit\",\n              x: c,\n              y: (n || 0) + da,\n              anchorX: a,\n              anchorY: d\n            };\n          if (f.outside && c < a) {\n            const b = W - ca;\n            0 < b && (k || (e.x = c + b, e.anchorX = a + b), k && (e.x = (L - ca) / 2, e.anchorX = a + b));\n          }\n          b.tt.attr(e);\n        });\n        const {\n          container: R,\n          outside: Q,\n          renderer: la\n        } = f;\n        if (Q && R && la) {\n          const {\n            width: b,\n            height: c,\n            x: a,\n            y: f\n          } = N.getBBox();\n          la.setSize(b + a, c + f, !1);\n          R.style.left = ca + \"px\";\n          R.style.top = ha + \"px\";\n        }\n        B && N.attr({\n          opacity: 1 === N.opacity ? .999 : 1\n        });\n      }\n      drawTracker() {\n        if (this.shouldStickOnContact()) {\n          var a = this.chart,\n            d = this.label,\n            b = this.shared ? a.hoverPoints : a.hoverPoint;\n          if (d && b) {\n            var f = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n            b = this.getAnchor(b);\n            var c = d.getBBox();\n            b[0] += a.plotLeft - d.translateX;\n            b[1] += a.plotTop - d.translateY;\n            f.x = Math.min(0, b[0]);\n            f.y = Math.min(0, b[1]);\n            f.width = 0 > b[0] ? Math.max(Math.abs(b[0]), c.width - b[0]) : Math.max(Math.abs(b[0]), c.width);\n            f.height = 0 > b[1] ? Math.max(Math.abs(b[1]), c.height - Math.abs(b[1])) : Math.max(Math.abs(b[1]), c.height);\n            this.tracker ? this.tracker.attr(f) : (this.tracker = d.renderer.rect(f).addClass(\"highcharts-tracker\").add(d), a.styledMode || this.tracker.attr({\n              fill: \"rgba(0,0,0,0)\"\n            }));\n          }\n        } else this.tracker && (this.tracker = this.tracker.destroy());\n      }\n      styledModeFormat(a) {\n        return a.replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}\"');\n      }\n      tooltipFooterHeaderFormatter(a, d) {\n        const b = a.series,\n          f = b.tooltipOptions;\n        var c = b.xAxis;\n        const n = c && c.dateTime;\n        c = {\n          isFooter: d,\n          labelConfig: a\n        };\n        let k = f.xDateFormat,\n          g = f[d ? \"footerFormat\" : \"headerFormat\"];\n        h(this, \"headerFormatter\", c, function (c) {\n          n && !k && e(a.key) && (k = n.getXDateFormat(a.key, f.dateTimeLabelFormats));\n          n && k && (a.point && a.point.tooltipDateKeys || [\"key\"]).forEach(function (b) {\n            g = g.replace(\"{point.\" + b + \"}\", \"{point.\" + b + \":\" + k + \"}\");\n          });\n          b.chart.styledMode && (g = this.styledModeFormat(g));\n          c.text = x(g, {\n            point: a,\n            series: b\n          }, this.chart);\n        });\n        return c.text;\n      }\n      update(a) {\n        this.destroy();\n        this.init(this.chart, E(!0, this.options, a));\n      }\n      updatePosition(a) {\n        const {\n          chart: d,\n          distance: b,\n          options: f\n        } = this;\n        var c = d.pointer;\n        const n = this.getLabel(),\n          {\n            left: k,\n            top: e,\n            scaleX: g,\n            scaleY: h\n          } = c.getChartPosition();\n        c = (f.positioner || this.getPosition).call(this, n.width, n.height, a);\n        let q = (a.plotX || 0) + d.plotLeft;\n        a = (a.plotY || 0) + d.plotTop;\n        let r;\n        if (this.outside) {\n          f.positioner && (c.x += k - b, c.y += e - b);\n          r = (f.borderWidth || 0) + 2 * b;\n          this.renderer.setSize(n.width + r, n.height + r, !1);\n          if (1 !== g || 1 !== h) p(this.container, {\n            transform: `scale(${g}, ${h})`\n          }), q *= g, a *= h;\n          q += k - c.x;\n          a += e - c.y;\n        }\n        this.move(Math.round(c.x), Math.round(c.y || 0), q, a);\n      }\n    }\n    (function (a) {\n      const d = [];\n      a.compose = function (b) {\n        C.pushUnique(d, b) && v(b, \"afterInit\", function () {\n          const b = this.chart;\n          b.options.tooltip && (b.tooltip = new a(b, b.options.tooltip));\n        });\n      };\n    })(r || (r = {}));\n    \"\";\n    return r;\n  });\n  M(a, \"Core/Series/Point.js\", [a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Templating.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C) {\n    const {\n        animObject: x\n      } = y,\n      {\n        defaultOptions: H\n      } = I,\n      {\n        format: B\n      } = L,\n      {\n        addEvent: u,\n        defined: v,\n        erase: l,\n        extend: p,\n        fireEvent: t,\n        getNestedProperty: m,\n        isArray: h,\n        isFunction: g,\n        isNumber: e,\n        isObject: w,\n        merge: E,\n        objectEach: F,\n        pick: d,\n        syncTimeout: k,\n        removeEvent: r,\n        uniqueKey: q\n      } = C;\n    class G {\n      constructor() {\n        this.category = void 0;\n        this.destroyed = !1;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.shapeArgs = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n      animateBeforeDestroy() {\n        const b = this,\n          a = {\n            x: b.startXPos,\n            opacity: 0\n          },\n          c = b.getGraphicalProps();\n        c.singular.forEach(function (c) {\n          b[c] = b[c].animate(\"dataLabel\" === c ? {\n            x: b[c].startXPos,\n            y: b[c].startYPos,\n            opacity: 0\n          } : a);\n        });\n        c.plural.forEach(function (c) {\n          b[c].forEach(function (c) {\n            c.element && c.animate(p({\n              x: b.startXPos\n            }, c.startYPos ? {\n              x: c.startXPos,\n              y: c.startYPos\n            } : {}));\n          });\n        });\n      }\n      applyOptions(b, a) {\n        const c = this.series,\n          f = c.options.pointValKey || c.pointValKey;\n        b = G.prototype.optionsToObject.call(this, b);\n        p(this, b);\n        this.options = this.options ? p(this.options, b) : b;\n        b.group && delete this.group;\n        b.dataLabels && delete this.dataLabels;\n        f && (this.y = G.prototype.getNestedProperty.call(this, f));\n        this.formatPrefix = (this.isNull = this.isValid && !this.isValid()) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof a && c.xAxis && c.xAxis.hasNames && (this.x = c.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && c ? this.x = \"undefined\" === typeof a ? c.autoIncrement() : a : e(b.x) && c.options.relativeXValue && (this.x = c.autoIncrement(b.x));\n        return this;\n      }\n      destroy() {\n        if (!this.destroyed) {\n          const a = this;\n          var b = a.series;\n          const c = b.chart;\n          b = b.options.dataSorting;\n          const d = c.hoverPoints,\n            e = x(a.series.chart.renderer.globalAnimation),\n            g = () => {\n              if (a.graphic || a.graphics || a.dataLabel || a.dataLabels) r(a), a.destroyElements();\n              for (const b in a) delete a[b];\n            };\n          a.legendItem && c.legend.destroyItem(a);\n          d && (a.setState(), l(d, a), d.length || (c.hoverPoints = null));\n          if (a === c.hoverPoint) a.onMouseOut();\n          b && b.enabled ? (this.animateBeforeDestroy(), k(g, e.duration)) : g();\n          c.pointCount--;\n        }\n        this.destroyed = !0;\n      }\n      destroyElements(b) {\n        const a = this;\n        b = a.getGraphicalProps(b);\n        b.singular.forEach(function (b) {\n          a[b] = a[b].destroy();\n        });\n        b.plural.forEach(function (b) {\n          a[b].forEach(function (b) {\n            b && b.element && b.destroy();\n          });\n          delete a[b];\n        });\n      }\n      firePointEvent(b, a, c) {\n        const f = this,\n          d = this.series.options;\n        (d.point.events[b] || f.options && f.options.events && f.options.events[b]) && f.importEvents();\n        \"click\" === b && d.allowPointSelect && (c = function (b) {\n          f.select && f.select(null, b.ctrlKey || b.metaKey || b.shiftKey);\n        });\n        t(f, b, a, c);\n      }\n      getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      }\n      getGraphicalProps(b) {\n        const a = this,\n          c = [],\n          d = {\n            singular: [],\n            plural: []\n          };\n        let k, e;\n        b = b || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        b.graphic && c.push(\"graphic\");\n        b.dataLabel && c.push(\"dataLabel\", \"dataLabelPath\", \"dataLabelUpper\", \"connector\");\n        for (e = c.length; e--;) k = c[e], a[k] && d.singular.push(k);\n        [\"graphic\", \"dataLabel\", \"connector\"].forEach(function (c) {\n          const f = c + \"s\";\n          b[c] && a[f] && d.plural.push(f);\n        });\n        return d;\n      }\n      getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      }\n      getNestedProperty(b) {\n        if (b) return 0 === b.indexOf(\"custom.\") ? m(b, this.options) : this[b];\n      }\n      getZone() {\n        var b = this.series;\n        const a = b.zones;\n        b = b.zoneAxis || \"y\";\n        let c,\n          d = 0;\n        for (c = a[d]; this[b] >= c.value;) c = a[++d];\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;\n        return c;\n      }\n      hasNewShapeType() {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      }\n      init(b, a, c) {\n        this.series = b;\n        this.applyOptions(a, c);\n        this.id = v(this.id) ? this.id : q();\n        this.resolveColor();\n        b.chart.pointCount++;\n        t(this, \"afterInit\");\n        return this;\n      }\n      isValid() {\n        return null !== this.x && e(this.y);\n      }\n      optionsToObject(b) {\n        var a = this.series;\n        const c = a.options.keys,\n          d = c || a.pointArrayMap || [\"y\"],\n          k = d.length;\n        let g = {},\n          q = 0,\n          r = 0;\n        if (e(b) || null === b) g[d[0]] = b;else if (h(b)) for (!c && b.length > k && (a = typeof b[0], \"string\" === a ? g.name = b[0] : \"number\" === a && (g.x = b[0]), q++); r < k;) c && \"undefined\" === typeof b[q] || (0 < d[r].indexOf(\".\") ? G.prototype.setNestedProperty(g, b[q], d[r]) : g[d[r]] = b[q]), q++, r++;else \"object\" === typeof b && (g = b, b.dataLabels && (a._hasPointLabels = !0), b.marker && (a._hasPointMarkers = !0));\n        return g;\n      }\n      pos(b, a = this.plotY) {\n        if (!this.destroyed) {\n          const {\n              plotX: c,\n              series: f\n            } = this,\n            {\n              chart: d,\n              xAxis: k,\n              yAxis: g\n            } = f;\n          let h = 0,\n            q = 0;\n          if (e(c) && e(a)) return b && (h = k ? k.pos : d.plotLeft, q = g ? g.pos : d.plotTop), d.inverted && k && g ? [g.len - a + q, k.len - c + h] : [c + h, a + q];\n        }\n      }\n      resolveColor() {\n        const b = this.series;\n        var a = b.chart.styledMode;\n        let c;\n        var k = b.chart.options.chart.colorCount;\n        delete this.nonZonedColor;\n        b.options.colorByPoint ? (a || (k = b.options.colors || b.chart.options.colors, c = k[b.colorCounter], k = k.length), a = b.colorCounter, b.colorCounter++, b.colorCounter === k && (b.colorCounter = 0)) : (a || (c = b.color), a = b.colorIndex);\n        this.colorIndex = d(this.options.colorIndex, a);\n        this.color = d(this.options.color, c);\n      }\n      setNestedProperty(b, a, c) {\n        c.split(\".\").reduce(function (b, c, f, d) {\n          b[c] = d.length - 1 === f ? a : w(b[c], !0) ? b[c] : {};\n          return b[c];\n        }, b);\n        return b;\n      }\n      shouldDraw() {\n        return !this.isNull;\n      }\n      tooltipFormatter(b) {\n        const a = this.series,\n          c = a.tooltipOptions,\n          k = d(c.valueDecimals, \"\"),\n          e = c.valuePrefix || \"\",\n          g = c.valueSuffix || \"\";\n        a.chart.styledMode && (b = a.chart.tooltip.styledModeFormat(b));\n        (a.pointArrayMap || [\"y\"]).forEach(function (c) {\n          c = \"{point.\" + c;\n          if (e || g) b = b.replace(RegExp(c + \"}\", \"g\"), e + c + \"}\" + g);\n          b = b.replace(RegExp(c + \"}\", \"g\"), c + \":,.\" + k + \"f}\");\n        });\n        return B(b, {\n          point: this,\n          series: this.series\n        }, a.chart);\n      }\n      update(b, a, c, k) {\n        function f() {\n          n.applyOptions(b);\n          var f = g && n.hasMockGraphic;\n          f = null === n.y ? !f : f;\n          g && f && (n.graphic = g.destroy(), delete n.hasMockGraphic);\n          w(b, !0) && (g && g.element && b && b.marker && \"undefined\" !== typeof b.marker.symbol && (n.graphic = g.destroy()), b && b.dataLabels && n.dataLabel && (n.dataLabel = n.dataLabel.destroy()), n.connector && (n.connector = n.connector.destroy()));\n          r = n.index;\n          e.updateParallelArrays(n, r);\n          q.data[r] = w(q.data[r], !0) || w(b, !0) ? n.options : d(b, q.data[r]);\n          e.isDirty = e.isDirtyData = !0;\n          !e.fixedBox && e.hasCartesianSeries && (h.isDirtyBox = !0);\n          \"point\" === q.legendType && (h.isDirtyLegend = !0);\n          a && h.redraw(c);\n        }\n        const n = this,\n          e = n.series,\n          g = n.graphic,\n          h = e.chart,\n          q = e.options;\n        let r;\n        a = d(a, !0);\n        !1 === k ? f() : n.firePointEvent(\"update\", {\n          options: b\n        }, f);\n      }\n      remove(b, a) {\n        this.series.removePoint(this.series.data.indexOf(this), b, a);\n      }\n      select(b, a) {\n        const c = this,\n          f = c.series,\n          k = f.chart;\n        this.selectedStaging = b = d(b, !c.selected);\n        c.firePointEvent(b ? \"select\" : \"unselect\", {\n          accumulate: a\n        }, function () {\n          c.selected = c.options.selected = b;\n          f.options.data[f.data.indexOf(c)] = c.options;\n          c.setState(b && \"select\");\n          a || k.getSelectedPoints().forEach(function (b) {\n            const a = b.series;\n            b.selected && b !== c && (b.selected = b.options.selected = !1, a.options.data[a.data.indexOf(b)] = b.options, b.setState(k.hoverPoints && a.options.inactiveOtherPoints ? \"inactive\" : \"\"), b.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      }\n      onMouseOver(b) {\n        const a = this.series.chart,\n          c = a.pointer;\n        b = b ? c.normalize(b) : c.getChartCoordinatesFromPoint(this, a.inverted);\n        c.runPointActions(b, this);\n      }\n      onMouseOut() {\n        const b = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function (b) {\n          b.setState();\n        });\n        b.hoverPoints = b.hoverPoint = null;\n      }\n      importEvents() {\n        if (!this.hasImportedEvents) {\n          const b = this,\n            a = E(b.series.options.point, b.options).events;\n          b.events = a;\n          F(a, function (c, a) {\n            g(c) && u(b, a, c);\n          });\n          this.hasImportedEvents = !0;\n        }\n      }\n      setState(b, f) {\n        const c = this.series;\n        var k = this.state,\n          g = c.options.states[b || \"normal\"] || {},\n          h = H.plotOptions[c.type].marker && c.options.marker;\n        const q = h && !1 === h.enabled,\n          r = h && h.states && h.states[b || \"normal\"] || {},\n          l = !1 === r.enabled,\n          m = this.marker || {},\n          w = c.chart,\n          v = h && c.markerAttribs;\n        let G = c.halo;\n        var u;\n        let x;\n        var E = c.stateMarkerGraphic;\n        b = b || \"\";\n        if (!(b === this.state && !f || this.selected && \"select\" !== b || !1 === g.enabled || b && (l || q && !1 === r.enabled) || b && m.states && m.states[b] && !1 === m.states[b].enabled)) {\n          this.state = b;\n          v && (u = c.markerAttribs(this, b));\n          if (this.graphic && !this.hasMockGraphic) {\n            k && this.graphic.removeClass(\"highcharts-point-\" + k);\n            b && this.graphic.addClass(\"highcharts-point-\" + b);\n            if (!w.styledMode) {\n              k = c.pointAttribs(this, b);\n              x = d(w.options.chart.animation, g.animation);\n              const a = k.opacity;\n              c.options.inactiveOtherPoints && e(a) && ((this.dataLabels || []).forEach(function (b) {\n                b && !b.hasClass(\"highcharts-data-label-hidden\") && b.animate({\n                  opacity: a\n                }, x);\n              }), this.connector && this.connector.animate({\n                opacity: a\n              }, x));\n              this.graphic.animate(k, x);\n            }\n            u && this.graphic.animate(u, d(w.options.chart.animation, r.animation, h.animation));\n            E && E.hide();\n          } else {\n            if (b && r) {\n              h = m.symbol || c.symbol;\n              E && E.currentSymbol !== h && (E = E.destroy());\n              if (u) if (E) E[f ? \"animate\" : \"attr\"]({\n                x: u.x,\n                y: u.y\n              });else h && (c.stateMarkerGraphic = E = w.renderer.symbol(h, u.x, u.y, u.width, u.height).add(c.markerGroup), E.currentSymbol = h);\n              !w.styledMode && E && \"inactive\" !== this.state && E.attr(c.pointAttribs(this, b));\n            }\n            E && (E[b && this.isInside ? \"show\" : \"hide\"](), E.element.point = this, E.addClass(this.getClassName(), !0));\n          }\n          g = g.halo;\n          u = (E = this.graphic || E) && E.visibility || \"inherit\";\n          g && g.size && E && \"hidden\" !== u && !this.isCluster ? (G || (c.halo = G = w.renderer.path().add(E.parentGroup)), G.show()[f ? \"animate\" : \"attr\"]({\n            d: this.haloPath(g.size)\n          }), G.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + d(this.colorIndex, c.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: u,\n            zIndex: -1\n          }), G.point = this, w.styledMode || G.attr(p({\n            fill: this.color || c.color,\n            \"fill-opacity\": g.opacity\n          }, a.filterUserAttributes(g.attributes || {})))) : G && G.point && G.point.haloPath && G.animate({\n            d: G.point.haloPath(0)\n          }, null, G.hide);\n          t(this, \"afterSetState\", {\n            state: b\n          });\n        }\n      }\n      haloPath(b) {\n        const a = this.pos();\n        return a ? this.series.chart.renderer.symbols.circle(Math.floor(a[0]) - b, a[1] - b, 2 * b, 2 * b) : [];\n      }\n    }\n    \"\";\n    return G;\n  });\n  M(a, \"Core/Pointer.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        parse: x\n      } = a,\n      {\n        charts: C,\n        noop: z\n      } = y,\n      {\n        addEvent: H,\n        attr: B,\n        css: u,\n        defined: v,\n        extend: l,\n        find: p,\n        fireEvent: t,\n        isNumber: m,\n        isObject: h,\n        objectEach: g,\n        offset: e,\n        pick: w,\n        splat: E\n      } = I;\n    class F {\n      constructor(a, k) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.eventsToUnbind = [];\n        this.chart = a;\n        this.hasDragged = !1;\n        this.options = k;\n        this.init(a, k);\n      }\n      applyInactiveState(a) {\n        let d = [],\n          e;\n        (a || []).forEach(function (a) {\n          e = a.series;\n          d.push(e);\n          e.linkedParent && d.push(e.linkedParent);\n          e.linkedSeries && (d = d.concat(e.linkedSeries));\n          e.navigatorSeries && d.push(e.navigatorSeries);\n        });\n        this.chart.series.forEach(function (a) {\n          -1 === d.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n        });\n      }\n      destroy() {\n        const a = this;\n        this.eventsToUnbind.forEach(a => a());\n        this.eventsToUnbind = [];\n        y.chartCount || (F.unbindDocumentMouseUp && (F.unbindDocumentMouseUp = F.unbindDocumentMouseUp()), F.unbindDocumentTouchEnd && (F.unbindDocumentTouchEnd = F.unbindDocumentTouchEnd()));\n        clearInterval(a.tooltipTimeout);\n        g(a, function (d, e) {\n          a[e] = void 0;\n        });\n      }\n      getSelectionMarkerAttrs(a, k) {\n        const d = {\n          args: {\n            chartX: a,\n            chartY: k\n          },\n          attrs: {},\n          shapeType: \"rect\"\n        };\n        t(this, \"getSelectionMarkerAttrs\", d, d => {\n          const {\n            chart: e,\n            mouseDownX: b = 0,\n            mouseDownY: f = 0,\n            zoomHor: c,\n            zoomVert: n\n          } = this;\n          d = d.attrs;\n          let g;\n          d.x = e.plotLeft;\n          d.y = e.plotTop;\n          d.width = c ? 1 : e.plotWidth;\n          d.height = n ? 1 : e.plotHeight;\n          c && (g = a - b, d.width = Math.abs(g), d.x = (0 < g ? 0 : g) + b);\n          n && (g = k - f, d.height = Math.abs(g), d.y = (0 < g ? 0 : g) + f);\n        });\n        return d;\n      }\n      drag(a) {\n        const d = this.chart,\n          e = d.options.chart;\n        var g = d.plotLeft;\n        const l = d.plotTop,\n          b = d.plotWidth,\n          f = d.plotHeight,\n          c = this.mouseDownX || 0,\n          n = this.mouseDownY || 0,\n          m = h(e.panning) ? e.panning && e.panning.enabled : e.panning,\n          p = e.panKey && a[e.panKey + \"Key\"];\n        let t = a.chartX,\n          w = a.chartY,\n          v = this.selectionMarker;\n        if (!v || !v.touch) if (t < g ? t = g : t > g + b && (t = g + b), w < l ? w = l : w > l + f && (w = l + f), this.hasDragged = Math.sqrt(Math.pow(c - t, 2) + Math.pow(n - w, 2)), 10 < this.hasDragged) {\n          g = d.isInsidePlot(c - g, n - l, {\n            visiblePlotOnly: !0\n          });\n          const {\n            shapeType: b,\n            attrs: f\n          } = this.getSelectionMarkerAttrs(t, w);\n          !d.hasCartesianSeries && !d.mapView || !this.zoomX && !this.zoomY || !g || p || v || (this.selectionMarker = v = d.renderer[b](), v.attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), d.styledMode || v.attr({\n            fill: e.selectionMarkerFill || x(\"#334eff\").setOpacity(.25).get()\n          }));\n          v && v.attr(f);\n          g && !v && m && d.pan(a, e.panning);\n        }\n      }\n      dragStart(a) {\n        const d = this.chart;\n        d.mouseIsDown = a.type;\n        d.cancelClick = !1;\n        d.mouseDownX = this.mouseDownX = a.chartX;\n        d.mouseDownY = this.mouseDownY = a.chartY;\n      }\n      getSelectionBox(a) {\n        const d = {\n          args: {\n            marker: a\n          },\n          result: {}\n        };\n        t(this, \"getSelectionBox\", d, d => {\n          d.result = {\n            x: a.attr ? +a.attr(\"x\") : a.x,\n            y: a.attr ? +a.attr(\"y\") : a.y,\n            width: a.attr ? a.attr(\"width\") : a.width,\n            height: a.attr ? a.attr(\"height\") : a.height\n          };\n        });\n        return d.result;\n      }\n      drop(a) {\n        const d = this,\n          e = this.chart,\n          g = this.hasPinched;\n        if (this.selectionMarker) {\n          const {\n              x: k,\n              y: b,\n              width: f,\n              height: c\n            } = this.getSelectionBox(this.selectionMarker),\n            n = {\n              originalEvent: a,\n              xAxis: [],\n              yAxis: [],\n              x: k,\n              y: b,\n              width: f,\n              height: c\n            };\n          let h = !!e.mapView;\n          if (this.hasDragged || g) e.axes.forEach(function (e) {\n            if (e.zoomEnabled && v(e.min) && (g || d[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[e.coll]]) && m(k) && m(b) && m(f) && m(c)) {\n              var q = e.horiz;\n              const d = \"touchend\" === a.type ? e.minPixelPadding : 0,\n                g = e.toValue((q ? k : b) + d);\n              q = e.toValue((q ? k + f : b + c) - d);\n              n[e.coll].push({\n                axis: e,\n                min: Math.min(g, q),\n                max: Math.max(g, q)\n              });\n              h = !0;\n            }\n          }), h && t(e, \"selection\", n, function (b) {\n            e.zoom(l(b, g ? {\n              animation: !1\n            } : null));\n          });\n          m(e.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          g && this.scaleGroups();\n        }\n        e && m(e.index) && (u(e.container, {\n          cursor: e._cursor\n        }), e.cancelClick = 10 < this.hasDragged, e.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      }\n      findNearestKDPoint(a, k, e) {\n        let d;\n        a.forEach(function (a) {\n          var b = !(a.noSharedTooltip && k) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(e, b);\n          if ((b = h(a, !0) && a.series) && !(b = !h(d, !0))) {\n            {\n              b = d.distX - a.distX;\n              const f = d.dist - a.dist,\n                c = (a.series.group && a.series.group.zIndex) - (d.series.group && d.series.group.zIndex);\n              b = 0 !== b && k ? b : 0 !== f ? f : 0 !== c ? c : d.series.index > a.series.index ? -1 : 1;\n            }\n            b = 0 < b;\n          }\n          b && (d = a);\n        });\n        return d;\n      }\n      getChartCoordinatesFromPoint(a, k) {\n        var d = a.series;\n        const e = d.xAxis;\n        d = d.yAxis;\n        const g = a.shapeArgs;\n        if (e && d) {\n          let b = w(a.clientX, a.plotX),\n            f = a.plotY || 0;\n          a.isNode && g && m(g.x) && m(g.y) && (b = g.x, f = g.y);\n          return k ? {\n            chartX: d.len + d.pos - f,\n            chartY: e.len + e.pos - b\n          } : {\n            chartX: b + e.pos,\n            chartY: f + d.pos\n          };\n        }\n        if (g && g.x && g.y) return {\n          chartX: g.x,\n          chartY: g.y\n        };\n      }\n      getChartPosition() {\n        if (this.chartPosition) return this.chartPosition;\n        var {\n          container: a\n        } = this.chart;\n        const k = e(a);\n        this.chartPosition = {\n          left: k.left,\n          top: k.top,\n          scaleX: 1,\n          scaleY: 1\n        };\n        const g = a.offsetWidth;\n        a = a.offsetHeight;\n        2 < g && 2 < a && (this.chartPosition.scaleX = k.width / g, this.chartPosition.scaleY = k.height / a);\n        return this.chartPosition;\n      }\n      getCoordinates(a) {\n        const d = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (k) {\n          d[k.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: k,\n            value: k.toValue(a[k.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return d;\n      }\n      getHoverData(a, k, e, g, l, b) {\n        const f = [];\n        g = !(!g || !a);\n        const c = function (b) {\n          return b.visible && !(!l && b.directTouch) && w(b.options.enableMouseTracking, !0);\n        };\n        let d,\n          q = {\n            chartX: b ? b.chartX : void 0,\n            chartY: b ? b.chartY : void 0,\n            shared: l\n          };\n        t(this, \"beforeGetHoverData\", q);\n        d = k && !k.stickyTracking ? [k] : e.filter(b => b.stickyTracking && (q.filter || c)(b));\n        const r = g || !b ? a : this.findNearestKDPoint(d, l, b);\n        k = r && r.series;\n        r && (l && !k.noSharedTooltip ? (d = e.filter(function (b) {\n          return q.filter ? q.filter(b) : c(b) && !b.noSharedTooltip;\n        }), d.forEach(function (b) {\n          let c = p(b.points, function (b) {\n            return b.x === r.x && !b.isNull;\n          });\n          h(c) && (b.boosted && b.boost && (c = b.boost.getPoint(c)), f.push(c));\n        })) : f.push(r));\n        q = {\n          hoverPoint: r\n        };\n        t(this, \"afterGetHoverData\", q);\n        return {\n          hoverPoint: q.hoverPoint,\n          hoverSeries: k,\n          hoverPoints: f\n        };\n      }\n      getPointFromEvent(a) {\n        a = a.target;\n        let d;\n        for (; a && !d;) d = a.point, a = a.parentNode;\n        return d;\n      }\n      onTrackerMouseOut(a) {\n        a = a.relatedTarget;\n        const d = this.chart.hoverSeries;\n        this.isDirectTouch = !1;\n        if (!(!d || !a || d.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + d.index) && this.inClass(a, \"highcharts-tracker\"))) d.onMouseOut();\n      }\n      inClass(a, k) {\n        let d;\n        for (; a;) {\n          if (d = B(a, \"class\")) {\n            if (-1 !== d.indexOf(k)) return !0;\n            if (-1 !== d.indexOf(\"highcharts-container\")) return !1;\n          }\n          a = a.parentElement;\n        }\n      }\n      init(a, k) {\n        this.options = k;\n        this.chart = a;\n        this.runChartClick = !(!k.chart.events || !k.chart.events.click);\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        this.setDOMEvents();\n        t(this, \"afterInit\");\n      }\n      normalize(a, k) {\n        var d = a.touches,\n          e = d ? d.length ? d.item(0) : w(d.changedTouches, a.changedTouches)[0] : a;\n        k || (k = this.getChartPosition());\n        d = e.pageX - k.left;\n        e = e.pageY - k.top;\n        d /= k.scaleX;\n        e /= k.scaleY;\n        return l(a, {\n          chartX: Math.round(d),\n          chartY: Math.round(e)\n        });\n      }\n      onContainerClick(a) {\n        const d = this.chart,\n          e = d.hoverPoint;\n        a = this.normalize(a);\n        const g = d.plotLeft,\n          h = d.plotTop;\n        d.cancelClick || (e && this.inClass(a.target, \"highcharts-tracker\") ? (t(e.series, \"click\", l(a, {\n          point: e\n        })), d.hoverPoint && e.firePointEvent(\"click\", a)) : (l(a, this.getCoordinates(a)), d.isInsidePlot(a.chartX - g, a.chartY - h, {\n          visiblePlotOnly: !0\n        }) && t(d, \"click\", a)));\n      }\n      onContainerMouseDown(a) {\n        const d = 1 === ((a.buttons || a.button) & 1);\n        a = this.normalize(a);\n        if (y.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);\n        if (\"undefined\" === typeof a.button || d) this.zoomOption(a), d && a.preventDefault && a.preventDefault(), this.dragStart(a);\n      }\n      onContainerMouseLeave(a) {\n        const d = C[w(F.hoverChartIndex, -1)];\n        a = this.normalize(a);\n        d && a.relatedTarget && !this.inClass(a.relatedTarget, \"highcharts-tooltip\") && (d.pointer.reset(), d.pointer.chartPosition = void 0);\n      }\n      onContainerMouseEnter(a) {\n        delete this.chartPosition;\n      }\n      onContainerMouseMove(a) {\n        const d = this.chart,\n          e = d.tooltip;\n        a = this.normalize(a);\n        this.setHoverChartIndex();\n        (\"mousedown\" === d.mouseIsDown || this.touchSelect(a)) && this.drag(a);\n        d.openMenu || !this.inClass(a.target, \"highcharts-tracker\") && !d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop, {\n          visiblePlotOnly: !0\n        }) || e && e.shouldStickOnContact(a) || (this.inClass(a.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(a));\n      }\n      onDocumentTouchEnd(a) {\n        const d = C[w(F.hoverChartIndex, -1)];\n        d && d.pointer.drop(a);\n      }\n      onContainerTouchMove(a) {\n        if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);\n      }\n      onContainerTouchStart(a) {\n        if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);\n      }\n      onDocumentMouseMove(a) {\n        const d = this.chart,\n          e = d.tooltip,\n          g = this.chartPosition;\n        a = this.normalize(a, g);\n        !g || d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop, {\n          visiblePlotOnly: !0\n        }) || e && e.shouldStickOnContact(a) || this.inClass(a.target, \"highcharts-tracker\") || this.reset();\n      }\n      onDocumentMouseUp(a) {\n        const d = C[w(F.hoverChartIndex, -1)];\n        d && d.pointer.drop(a);\n      }\n      pinch(a) {\n        const d = this,\n          e = d.chart,\n          g = d.pinchDown,\n          h = a.touches || [],\n          b = h.length,\n          f = d.lastValidTouch,\n          c = d.hasZoom,\n          n = {},\n          m = 1 === b && (d.inClass(a.target, \"highcharts-tracker\") && e.runTrackerClick || d.runChartClick),\n          p = {};\n        var v = d.chart.tooltip;\n        v = 1 === b && w(v && v.options.followTouchMove, !0);\n        let u = d.selectionMarker;\n        1 < b ? d.initiated = !0 : v && (d.initiated = !1);\n        c && d.initiated && !m && !1 !== a.cancelable && a.preventDefault();\n        [].map.call(h, function (b) {\n          return d.normalize(b);\n        });\n        \"touchstart\" === a.type ? ([].forEach.call(h, function (b, a) {\n          g[a] = {\n            chartX: b.chartX,\n            chartY: b.chartY\n          };\n        }), f.x = [g[0].chartX, g[1] && g[1].chartX], f.y = [g[0].chartY, g[1] && g[1].chartY], e.axes.forEach(function (b) {\n          if (b.zoomEnabled) {\n            const a = e.bounds[b.horiz ? \"h\" : \"v\"],\n              c = b.minPixelPadding,\n              f = b.toPixels(Math.min(w(b.options.min, b.dataMin), b.dataMin)),\n              d = b.toPixels(Math.max(w(b.options.max, b.dataMax), b.dataMax)),\n              n = Math.max(f, d);\n            a.min = Math.min(b.pos, Math.min(f, d) - c);\n            a.max = Math.max(b.pos + b.len, n + c);\n          }\n        }), d.res = !0) : v ? this.runPointActions(d.normalize(a)) : g.length && (t(e, \"touchpan\", {\n          originalEvent: a\n        }, () => {\n          u || (d.selectionMarker = u = l({\n            destroy: z,\n            touch: !0\n          }, e.plotBox));\n          d.pinchTranslate(g, h, n, u, p, f);\n          d.hasPinched = c;\n          d.scaleGroups(n, p);\n        }), d.res && (d.res = !1, this.reset(!1, 0)));\n      }\n      pinchTranslate(a, e, g, h, l, b) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, e, g, h, l, b);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, e, g, h, l, b);\n      }\n      pinchTranslateDirection(a, e, g, h, l, b, f, c) {\n        const d = this.chart,\n          k = a ? \"x\" : \"y\",\n          q = a ? \"X\" : \"Y\",\n          m = \"chart\" + q,\n          r = a ? \"width\" : \"height\",\n          p = d[\"plot\" + (a ? \"Left\" : \"Top\")],\n          t = d.inverted,\n          w = d.bounds[a ? \"h\" : \"v\"],\n          v = 1 === e.length,\n          u = e[0][m],\n          x = !v && e[1][m];\n        e = function () {\n          \"number\" === typeof N && 20 < Math.abs(u - x) && (F = c || Math.abs(J - N) / Math.abs(u - x));\n          E = (p - J) / F + u;\n          G = d[\"plot\" + (a ? \"Width\" : \"Height\")] / F;\n        };\n        let G,\n          E,\n          F = c || 1,\n          J = g[0][m],\n          N = !v && g[1][m],\n          O;\n        e();\n        g = E;\n        g < w.min ? (g = w.min, O = !0) : g + G > w.max && (g = w.max - G, O = !0);\n        O ? (J -= .8 * (J - f[k][0]), \"number\" === typeof N && (N -= .8 * (N - f[k][1])), e()) : f[k] = [J, N];\n        t || (b[k] = E - p, b[r] = G);\n        b = t ? 1 / F : F;\n        l[r] = G;\n        l[k] = g;\n        h[t ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + q] = F;\n        h[\"translate\" + q] = b * p + (J - b * u);\n      }\n      reset(a, e) {\n        const d = this.chart,\n          k = d.hoverSeries,\n          g = d.hoverPoint,\n          b = d.hoverPoints,\n          f = d.tooltip,\n          c = f && f.shared ? b : g;\n        a && c && E(c).forEach(function (b) {\n          b.series.isCartesian && \"undefined\" === typeof b.plotX && (a = !1);\n        });\n        if (a) f && c && E(c).length && (f.refresh(c), f.shared && b ? b.forEach(function (b) {\n          b.setState(b.state, !0);\n          b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));\n        }) : g && (g.setState(g.state, !0), d.axes.forEach(function (b) {\n          b.crosshair && g.series[b.coll] === b && b.drawCrosshair(null, g);\n        })));else {\n          if (g) g.onMouseOut();\n          b && b.forEach(function (b) {\n            b.setState();\n          });\n          if (k) k.onMouseOut();\n          f && f.hide(e);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          d.axes.forEach(function (b) {\n            b.hideCrosshair();\n          });\n          this.hoverX = d.hoverPoints = d.hoverPoint = null;\n        }\n      }\n      runPointActions(a, e, g) {\n        const d = this.chart,\n          k = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0,\n          b = k ? k.shared : !1;\n        let f = e || d.hoverPoint,\n          c = f && f.series || d.hoverSeries;\n        e = this.getHoverData(f, c, d.series, (!a || \"touchmove\" !== a.type) && (!!e || c && c.directTouch && this.isDirectTouch), b, a);\n        f = e.hoverPoint;\n        c = e.hoverSeries;\n        const n = e.hoverPoints;\n        e = c && c.tooltipOptions.followPointer && !c.tooltipOptions.split;\n        const h = b && c && !c.noSharedTooltip;\n        if (f && (g || f !== d.hoverPoint || k && k.isHidden)) {\n          (d.hoverPoints || []).forEach(function (b) {\n            -1 === n.indexOf(b) && b.setState();\n          });\n          if (d.hoverSeries !== c) c.onMouseOver();\n          this.applyInactiveState(n);\n          (n || []).forEach(function (b) {\n            b.setState(\"hover\");\n          });\n          d.hoverPoint && d.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!f.series) return;\n          d.hoverPoints = n;\n          d.hoverPoint = f;\n          f.firePointEvent(\"mouseOver\", void 0, () => {\n            k && f && k.refresh(h ? n : f, a);\n          });\n        } else e && k && !k.isHidden && (g = k.getAnchor([{}], a), d.isInsidePlot(g[0], g[1], {\n          visiblePlotOnly: !0\n        }) && k.updatePosition({\n          plotX: g[0],\n          plotY: g[1]\n        }));\n        this.unDocMouseMove || (this.unDocMouseMove = H(d.container.ownerDocument, \"mousemove\", function (b) {\n          const a = C[F.hoverChartIndex];\n          if (a) a.pointer.onDocumentMouseMove(b);\n        }), this.eventsToUnbind.push(this.unDocMouseMove));\n        d.axes.forEach(function (b) {\n          const c = w((b.crosshair || {}).snap, !0);\n          let f;\n          c && ((f = d.hoverPoint) && f.series[b.coll] === b || (f = p(n, a => a.series && a.series[b.coll] === b)));\n          f || !c ? b.drawCrosshair(a, f) : b.hideCrosshair();\n        });\n      }\n      scaleGroups(a, e) {\n        const d = this.chart;\n        d.series.forEach(function (k) {\n          const g = a || k.getPlotBox();\n          k.group && (k.xAxis && k.xAxis.zoomEnabled || d.mapView) && (k.group.attr(g), k.markerGroup && (k.markerGroup.attr(g), k.markerGroup.clip(e ? d.clipRect : null)), k.dataLabelsGroup && k.dataLabelsGroup.attr(g));\n        });\n        d.clipRect.attr(e || d.clipBox);\n      }\n      setDOMEvents() {\n        const a = this.chart.container,\n          e = a.ownerDocument;\n        a.onmousedown = this.onContainerMouseDown.bind(this);\n        a.onmousemove = this.onContainerMouseMove.bind(this);\n        a.onclick = this.onContainerClick.bind(this);\n        this.eventsToUnbind.push(H(a, \"mouseenter\", this.onContainerMouseEnter.bind(this)));\n        this.eventsToUnbind.push(H(a, \"mouseleave\", this.onContainerMouseLeave.bind(this)));\n        F.unbindDocumentMouseUp || (F.unbindDocumentMouseUp = H(e, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n        let g = this.chart.renderTo.parentElement;\n        for (; g && \"BODY\" !== g.tagName;) this.eventsToUnbind.push(H(g, \"scroll\", () => {\n          delete this.chartPosition;\n        })), g = g.parentElement;\n        y.hasTouch && (this.eventsToUnbind.push(H(a, \"touchstart\", this.onContainerTouchStart.bind(this), {\n          passive: !1\n        })), this.eventsToUnbind.push(H(a, \"touchmove\", this.onContainerTouchMove.bind(this), {\n          passive: !1\n        })), F.unbindDocumentTouchEnd || (F.unbindDocumentTouchEnd = H(e, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n          passive: !1\n        })));\n      }\n      setHoverChartIndex() {\n        const a = this.chart,\n          e = y.charts[w(F.hoverChartIndex, -1)];\n        if (e && e !== a) e.pointer.onContainerMouseLeave({\n          relatedTarget: a.container\n        });\n        e && e.mouseIsDown || (F.hoverChartIndex = a.index);\n      }\n      touch(a, e) {\n        const d = this.chart;\n        let g, k;\n        this.setHoverChartIndex();\n        1 === a.touches.length ? (a = this.normalize(a), (k = d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop, {\n          visiblePlotOnly: !0\n        })) && !d.openMenu ? (e && this.runPointActions(a), \"touchmove\" === a.type && (e = this.pinchDown, g = e[0] ? 4 <= Math.sqrt(Math.pow(e[0].chartX - a.chartX, 2) + Math.pow(e[0].chartY - a.chartY, 2)) : !1), w(g, !0) && this.pinch(a)) : e && this.reset()) : 2 === a.touches.length && this.pinch(a);\n      }\n      touchSelect(a) {\n        return !(!this.chart.zooming.singleTouch || !a.touches || 1 !== a.touches.length);\n      }\n      zoomOption(a) {\n        const d = this.chart,\n          e = d.inverted;\n        var g = d.zooming.type || \"\";\n        /touch/.test(a.type) && (g = w(d.zooming.pinchType, g));\n        this.zoomX = a = /x/.test(g);\n        this.zoomY = g = /y/.test(g);\n        this.zoomHor = a && !e || g && e;\n        this.zoomVert = g && !e || a && e;\n        this.hasZoom = a || g;\n      }\n    }\n    (function (a) {\n      const d = [],\n        e = [];\n      a.compose = function (d) {\n        I.pushUnique(e, d) && H(d, \"beforeRender\", function () {\n          this.pointer = new a(this, this.options);\n        });\n      };\n      a.dissolve = function () {\n        for (let a = 0, e = d.length; a < e; ++a) d[a]();\n        d.length = 0;\n      };\n    })(F || (F = {}));\n    \"\";\n    return F;\n  });\n  M(a, \"Core/Legend/Legend.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Templating.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z) {\n    const {\n        animObject: x,\n        setAnimation: B\n      } = a,\n      {\n        format: u\n      } = y,\n      {\n        marginNames: v\n      } = I,\n      {\n        distribute: l\n      } = C,\n      {\n        addEvent: p,\n        createElement: t,\n        css: m,\n        defined: h,\n        discardElement: g,\n        find: e,\n        fireEvent: w,\n        isNumber: E,\n        merge: F,\n        pick: d,\n        relativeLength: k,\n        stableSort: r,\n        syncTimeout: q\n      } = z;\n    class G {\n      constructor(b, a) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = void 0;\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = b;\n        this.init(b, a);\n      }\n      init(b, a) {\n        this.chart = b;\n        this.setOptions(a);\n        a.enabled && (this.render(), p(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), p(this.chart, \"render\", () => {\n          this.proximate && (this.proximatePositions(), this.positionItems());\n        }));\n      }\n      setOptions(b) {\n        const a = d(b.padding, 8);\n        this.options = b;\n        this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = F(this.itemStyle, b.itemHiddenStyle));\n        this.itemMarginTop = b.itemMarginTop;\n        this.itemMarginBottom = b.itemMarginBottom;\n        this.padding = a;\n        this.initialItemY = a - 5;\n        this.symbolWidth = d(b.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === b.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      }\n      update(b, a) {\n        const c = this.chart;\n        this.setOptions(F(!0, this.options, b));\n        this.destroy();\n        c.isDirtyLegend = c.isDirtyBox = !0;\n        d(a, !0) && c.redraw();\n        w(this, \"afterUpdate\");\n      }\n      colorizeItem(b, a) {\n        const {\n          group: c,\n          label: f,\n          line: d,\n          symbol: e\n        } = b.legendItem || {};\n        if (c) c[a ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n        if (!this.chart.styledMode) {\n          const {\n              itemHiddenStyle: c\n            } = this,\n            g = c.color,\n            k = a ? b.color || g : g,\n            n = b.options && b.options.marker;\n          let h = {\n            fill: k\n          };\n          null === f || void 0 === f ? void 0 : f.css(F(a ? this.itemStyle : c));\n          null === d || void 0 === d ? void 0 : d.attr({\n            stroke: k\n          });\n          e && (n && e.isMarker && (h = b.pointAttribs(), a || (h.stroke = h.fill = g)), e.attr(h));\n        }\n        w(this, \"afterColorizeItem\", {\n          item: b,\n          visible: a\n        });\n      }\n      positionItems() {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      }\n      positionItem(b) {\n        const {\n          group: a,\n          x: c = 0,\n          y: d = 0\n        } = b.legendItem || {};\n        var e = this.options,\n          g = e.symbolPadding;\n        const k = !e.rtl;\n        e = b.checkbox;\n        a && a.element && (g = {\n          translateX: k ? c : this.legendWidth - c - 2 * g - 4,\n          translateY: d\n        }, a[h(a.translateY) ? \"animate\" : \"attr\"](g, void 0, () => {\n          w(this, \"afterPositionItem\", {\n            item: b\n          });\n        }));\n        e && (e.x = c, e.y = d);\n      }\n      destroyItem(b) {\n        const a = b.checkbox,\n          c = b.legendItem || {};\n        for (const b of [\"group\", \"label\", \"line\", \"symbol\"]) c[b] && (c[b] = c[b].destroy());\n        a && g(a);\n        b.legendItem = void 0;\n      }\n      destroy() {\n        for (const b of this.getAllItems()) this.destroyItem(b);\n        for (const b of \"clipRect up down pager nav box title group\".split(\" \")) this[b] && (this[b] = this[b].destroy());\n        this.display = null;\n      }\n      positionCheckboxes() {\n        const b = this.group && this.group.alignAttr,\n          a = this.clipHeight || this.legendHeight,\n          c = this.titleHeight;\n        let d;\n        b && (d = b.translateY, this.allItems.forEach(function (f) {\n          const e = f.checkbox;\n          let g;\n          e && (g = d + c + e.y + (this.scrollOffset || 0) + 3, m(e, {\n            left: b.translateX + f.checkboxOffset + e.x - 20 + \"px\",\n            top: g + \"px\",\n            display: this.proximate || g > d - 6 && g < d + a - 6 ? \"\" : \"none\"\n          }));\n        }, this));\n      }\n      renderTitle() {\n        var b = this.options;\n        const a = this.padding,\n          c = b.title;\n        let d = 0;\n        c.text && (this.title || (this.title = this.chart.renderer.label(c.text, a - 3, a - 4, void 0, void 0, void 0, b.useHTML, void 0, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), b = this.title.getBBox(), d = b.height, this.offsetWidth = b.width, this.contentGroup.attr({\n          translateY: d\n        }));\n        this.titleHeight = d;\n      }\n      setText(b) {\n        const a = this.options;\n        b.legendItem.label.attr({\n          text: a.labelFormat ? u(a.labelFormat, b, this.chart) : a.labelFormatter.call(b)\n        });\n      }\n      renderItem(b) {\n        const a = b.legendItem = b.legendItem || {};\n        var c = this.chart,\n          e = c.renderer;\n        const g = this.options,\n          k = this.symbolWidth,\n          h = g.symbolPadding || 0,\n          l = this.itemStyle,\n          m = this.itemHiddenStyle,\n          q = \"horizontal\" === g.layout ? d(g.itemDistance, 20) : 0,\n          r = !g.rtl,\n          p = !b.series,\n          t = !p && b.series.drawLegendSymbol ? b.series : b;\n        var w = t.options;\n        const v = this.createCheckboxForItem && w && w.showCheckbox,\n          u = g.useHTML,\n          x = b.options.className;\n        let J = a.label;\n        w = k + h + q + (v ? 20 : 0);\n        J || (a.group = e.g(\"legend-item\").addClass(\"highcharts-\" + t.type + \"-series highcharts-color-\" + b.colorIndex + (x ? \" \" + x : \"\") + (p ? \" highcharts-series-\" + b.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.label = J = e.text(\"\", r ? k + h : -h, this.baseline || 0, u), c.styledMode || J.css(F(b.visible ? l : m)), J.attr({\n          align: r ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.group), this.baseline || (this.fontMetrics = e.fontMetrics(J), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, J.attr(\"y\", this.baseline), this.symbolHeight = d(g.symbolHeight, this.fontMetrics.f), g.squareSymbol && (this.symbolWidth = d(g.symbolWidth, Math.max(this.symbolHeight, 16)), w = this.symbolWidth + h + q + (v ? 20 : 0), r && J.attr(\"x\", this.symbolWidth + h))), t.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, J, u));\n        v && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);\n        this.colorizeItem(b, b.visible);\n        !c.styledMode && l.width || J.css({\n          width: (g.itemWidth || this.widthOption || c.spacingBox.width) - w + \"px\"\n        });\n        this.setText(b);\n        c = J.getBBox();\n        e = this.fontMetrics && this.fontMetrics.h || 0;\n        b.itemWidth = b.checkboxOffset = g.itemWidth || a.labelWidth || c.width + w;\n        this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);\n        this.totalItemWidth += b.itemWidth;\n        this.itemHeight = b.itemHeight = Math.round(a.labelHeight || (c.height > 1.5 * e ? c.height : e));\n      }\n      layoutItem(b) {\n        var a = this.options;\n        const c = this.padding,\n          e = \"horizontal\" === a.layout,\n          g = b.itemHeight,\n          k = this.itemMarginBottom,\n          h = this.itemMarginTop,\n          l = e ? d(a.itemDistance, 20) : 0,\n          m = this.maxLegendWidth;\n        a = a.alignColumns && this.totalItemWidth > m ? this.maxItemWidth : b.itemWidth;\n        const q = b.legendItem || {};\n        e && this.itemX - c + a > m && (this.itemX = c, this.lastLineHeight && (this.itemY += h + this.lastLineHeight + k), this.lastLineHeight = 0);\n        this.lastItemY = h + this.itemY + k;\n        this.lastLineHeight = Math.max(g, this.lastLineHeight);\n        q.x = this.itemX;\n        q.y = this.itemY;\n        e ? this.itemX += a : (this.itemY += h + g + k, this.lastLineHeight = g);\n        this.offsetWidth = this.widthOption || Math.max((e ? this.itemX - c - (b.checkbox ? 0 : l) : a) + c, this.offsetWidth);\n      }\n      getAllItems() {\n        let b = [];\n        this.chart.series.forEach(function (a) {\n          const c = a && a.options;\n          a && d(c.showInLegend, h(c.linkedTo) ? !1 : void 0, !0) && (b = b.concat((a.legendItem || {}).labels || (\"point\" === c.legendType ? a.data : a)));\n        });\n        w(this, \"afterGetAllItems\", {\n          allItems: b\n        });\n        return b;\n      }\n      getAlignment() {\n        const b = this.options;\n        return this.proximate ? b.align.charAt(0) + \"tv\" : b.floating ? \"\" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);\n      }\n      adjustMargins(b, a) {\n        const c = this.chart,\n          f = this.options,\n          e = this.getAlignment();\n        e && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (g, k) {\n          g.test(e) && !h(b[k]) && (c[v[k]] = Math.max(c[v[k]], c.legend[(k + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][k] * f[k % 2 ? \"x\" : \"y\"] + d(f.margin, 12) + a[k] + (c.titleOffset[k] || 0)));\n        });\n      }\n      proximatePositions() {\n        const b = this.chart,\n          a = [],\n          c = \"left\" === this.options.align;\n        this.allItems.forEach(function (d) {\n          var f;\n          var g = c;\n          let k;\n          d.yAxis && (d.xAxis.options.reversed && (g = !g), d.points && (f = e(g ? d.points : d.points.slice(0).reverse(), function (b) {\n            return E(b.plotY);\n          })), g = this.itemMarginTop + d.legendItem.label.getBBox().height + this.itemMarginBottom, k = d.yAxis.top - b.plotTop, d.visible ? (f = f ? f.plotY : d.yAxis.height, f += k - .3 * g) : f = k + d.yAxis.height, a.push({\n            target: f,\n            size: g,\n            item: d\n          }));\n        }, this);\n        let d;\n        for (const c of l(a, b.plotHeight)) d = c.item.legendItem || {}, E(c.pos) && (d.y = b.plotTop - b.spacing[0] + c.pos);\n      }\n      render() {\n        const b = this.chart,\n          a = b.renderer,\n          c = this.options,\n          d = this.padding;\n        var e = this.getAllItems();\n        let g,\n          h = this.group,\n          l = this.box;\n        this.itemX = d;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = k(c.width, b.spacingBox.width - d);\n        var m = b.spacingBox.width - 2 * d - c.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (m /= 2);\n        this.maxLegendWidth = this.widthOption || m;\n        h || (this.group = h = a.g(\"legend\").addClass(c.className || \"\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = a.g().attr({\n          zIndex: 1\n        }).add(h), this.scrollGroup = a.g().add(this.contentGroup));\n        this.renderTitle();\n        r(e, (b, a) => (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0));\n        c.reversed && e.reverse();\n        this.allItems = e;\n        this.display = m = !!e.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        e.forEach(this.renderItem, this);\n        e.forEach(this.layoutItem, this);\n        e = (this.widthOption || this.offsetWidth) + d;\n        g = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        g = this.handleOverflow(g);\n        g += d;\n        l || (this.box = l = a.rect().addClass(\"highcharts-legend-box\").attr({\n          r: c.borderRadius\n        }).add(h));\n        b.styledMode || l.attr({\n          stroke: c.borderColor,\n          \"stroke-width\": c.borderWidth || 0,\n          fill: c.backgroundColor || \"none\"\n        }).shadow(c.shadow);\n        if (0 < e && 0 < g) l[l.placed ? \"animate\" : \"attr\"](l.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: e,\n          height: g\n        }, l.strokeWidth()));\n        h[m ? \"show\" : \"hide\"]();\n        b.styledMode && \"none\" === h.getStyle(\"display\") && (e = g = 0);\n        this.legendWidth = e;\n        this.legendHeight = g;\n        m && this.align();\n        this.proximate || this.positionItems();\n        w(this, \"afterRender\");\n      }\n      align(b = this.chart.spacingBox) {\n        const a = this.chart,\n          c = this.options;\n        let d = b.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? d += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (d -= a.titleOffset[2]);\n        d !== b.y && (b = F(b, {\n          y: d\n        }));\n        a.hasRendered || (this.group.placed = !1);\n        this.group.align(F(c, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : c.verticalAlign\n        }), !0, b);\n      }\n      handleOverflow(b) {\n        const a = this,\n          c = this.chart,\n          e = c.renderer,\n          g = this.options;\n        var k = g.y;\n        const h = \"top\" === g.verticalAlign,\n          l = this.padding,\n          m = g.maxHeight,\n          q = g.navigation,\n          r = d(q.animation, !0),\n          p = q.arrowSize || 12,\n          t = this.pages,\n          w = this.allItems,\n          v = function (b) {\n            \"number\" === typeof b ? E.attr({\n              height: b\n            }) : E && (a.clipRect = E.destroy(), a.contentGroup.clip());\n            a.contentGroup.div && (a.contentGroup.div.style.clip = b ? \"rect(\" + l + \"px,9999px,\" + (l + b) + \"px,0)\" : \"auto\");\n          },\n          u = function (b) {\n            a[b] = e.circle(0, 0, 1.3 * p).translate(p / 2, p / 2).add(O);\n            c.styledMode || a[b].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n            return a[b];\n          };\n        let x, J, N;\n        k = c.spacingBox.height + (h ? -k : k) - l;\n        let O = this.nav,\n          E = this.clipRect;\n        \"horizontal\" !== g.layout || \"middle\" === g.verticalAlign || g.floating || (k /= 2);\n        m && (k = Math.min(k, m));\n        t.length = 0;\n        b && 0 < k && b > k && !1 !== q.enabled ? (this.clipHeight = x = Math.max(k - 20 - this.titleHeight - l, 0), this.currentPage = d(this.currentPage, 1), this.fullHeight = b, w.forEach((b, a) => {\n          N = b.legendItem || {};\n          b = N.y || 0;\n          const c = Math.round(N.label.getBBox().height);\n          let d = t.length;\n          if (!d || b - t[d - 1] > x && (J || b) !== t[d - 1]) t.push(J || b), d++;\n          N.pageIx = d - 1;\n          J && ((w[a - 1].legendItem || {}).pageIx = d - 1);\n          a === w.length - 1 && b + c - t[d - 1] > x && b > t[d - 1] && (t.push(b), N.pageIx = d);\n          b !== J && (J = b);\n        }), E || (E = a.clipRect = e.clipRect(0, l - 2, 9999, 0), a.contentGroup.clip(E)), v(x), O || (this.nav = O = e.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = e.symbol(\"triangle\", 0, 0, p, p).add(O), u(\"upTracker\").on(\"click\", function () {\n          a.scroll(-1, r);\n        }), this.pager = e.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !c.styledMode && q.style && this.pager.css(q.style), this.pager.add(O), this.down = e.symbol(\"triangle-down\", 0, 0, p, p).add(O), u(\"downTracker\").on(\"click\", function () {\n          a.scroll(1, r);\n        })), a.scroll(0), b = k) : O && (v(), this.nav = O.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return b;\n      }\n      scroll(b, a) {\n        const c = this.chart,\n          f = this.pages,\n          e = f.length,\n          g = this.clipHeight,\n          k = this.options.navigation,\n          h = this.pager,\n          l = this.padding;\n        let m = this.currentPage + b;\n        m > e && (m = e);\n        0 < m && (\"undefined\" !== typeof a && B(a, c), this.nav.attr({\n          translateX: l,\n          translateY: g + this.padding + 7 + this.titleHeight,\n          visibility: \"inherit\"\n        }), [this.up, this.upTracker].forEach(function (b) {\n          b.attr({\n            \"class\": 1 === m ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), h.attr({\n          text: m + \"/\" + e\n        }), [this.down, this.downTracker].forEach(function (b) {\n          b.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": m === e ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), c.styledMode || (this.up.attr({\n          fill: 1 === m ? k.inactiveColor : k.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === m ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: m === e ? k.inactiveColor : k.activeColor\n        }), this.downTracker.css({\n          cursor: m === e ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -f[m - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = m, this.positionCheckboxes(), b = x(d(a, c.renderer.globalAnimation, !0)), q(() => {\n          w(this, \"afterScroll\", {\n            currentPage: m\n          });\n        }, b.duration));\n      }\n      setItemEvents(b, a, c) {\n        const d = this,\n          f = b.legendItem || {},\n          e = d.chart.renderer.boxWrapper,\n          g = b instanceof L,\n          k = \"highcharts-legend-\" + (g ? \"point\" : \"series\") + \"-active\",\n          h = d.chart.styledMode;\n        c = c ? [a, f.symbol] : [f.group];\n        const l = a => {\n          d.allItems.forEach(c => {\n            b !== c && [c].concat(c.linkedSeries || []).forEach(b => {\n              b.setState(a, !g);\n            });\n          });\n        };\n        for (const f of c) if (f) f.on(\"mouseover\", function () {\n          b.visible && l(\"inactive\");\n          b.setState(\"hover\");\n          b.visible && e.addClass(k);\n          h || a.css(d.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          d.chart.styledMode || a.css(F(b.visible ? d.itemStyle : d.itemHiddenStyle));\n          l(\"\");\n          e.removeClass(k);\n          b.setState();\n        }).on(\"click\", function (a) {\n          const c = function () {\n            b.setVisible && b.setVisible();\n            l(b.visible ? \"inactive\" : \"\");\n          };\n          e.removeClass(k);\n          a = {\n            browserEvent: a\n          };\n          b.firePointEvent ? b.firePointEvent(\"legendItemClick\", a, c) : w(b, \"legendItemClick\", a, c);\n        });\n      }\n      createCheckboxForItem(b) {\n        b.checkbox = t(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: b.selected,\n          defaultChecked: b.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        p(b.checkbox, \"click\", function (a) {\n          w(b.series || b, \"checkboxClick\", {\n            checked: a.target.checked,\n            item: b\n          }, function () {\n            b.select();\n          });\n        });\n      }\n    }\n    (function (b) {\n      const a = [];\n      b.compose = function (c) {\n        z.pushUnique(a, c) && p(c, \"beforeMargins\", function () {\n          this.legend = new b(this, this.options.legend);\n        });\n      };\n    })(G || (G = {}));\n    \"\";\n    return G;\n  });\n  M(a, \"Core/Legend/LegendSymbol.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      extend: x,\n      merge: I,\n      pick: L\n    } = a;\n    var C;\n    (function (a) {\n      a.lineMarker = function (a, B) {\n        B = this.legendItem = this.legendItem || {};\n        var u = this.options;\n        const v = a.symbolWidth,\n          l = a.symbolHeight,\n          p = l / 2,\n          t = this.chart.renderer,\n          m = B.group;\n        a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n        let h = {},\n          g = u.marker,\n          e = 0;\n        this.chart.styledMode || (h = {\n          \"stroke-width\": Math.min(u.lineWidth || 0, 24)\n        }, u.dashStyle ? h.dashstyle = u.dashStyle : \"square\" !== u.linecap && (h[\"stroke-linecap\"] = \"round\"));\n        B.line = t.path().addClass(\"highcharts-graph\").attr(h).add(m);\n        h[\"stroke-linecap\"] && (e = Math.min(B.line.strokeWidth(), v) / 2);\n        v && B.line.attr({\n          d: [[\"M\", e, a], [\"L\", v - e, a]]\n        });\n        g && !1 !== g.enabled && v && (u = Math.min(L(g.radius, p), p), 0 === this.symbol.indexOf(\"url\") && (g = I(g, {\n          width: l,\n          height: l\n        }), u = 0), B.symbol = B = t.symbol(this.symbol, v / 2 - u, a - u, 2 * u, 2 * u, x({\n          context: \"legend\"\n        }, g)).addClass(\"highcharts-point\").add(m), B.isMarker = !0);\n      };\n      a.rectangle = function (a, x) {\n        x = x.legendItem || {};\n        const u = a.symbolHeight,\n          v = a.options.squareSymbol;\n        x.symbol = this.chart.renderer.rect(v ? (a.symbolWidth - u) / 2 : 0, a.baseline - u + 1, v ? u : a.symbolWidth, u, L(a.options.symbolRadius, u / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(x.group);\n      };\n    })(C || (C = {}));\n    return C;\n  });\n  M(a, \"Core/Series/SeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 1,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      enableMouseTracking: !0,\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 150\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        borderWidth: 0,\n        defer: !0,\n        formatter: function () {\n          const {\n            numberFormatter: a\n          } = this.series.chart;\n          return \"number\" !== typeof this.y ? \"\" : a(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"0.7em\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 150\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 150\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    };\n  });\n  M(a, \"Core/Series/SeriesRegistry.js\", [a[\"Core/Globals.js\"], a[\"Core/Defaults.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L) {\n    const {\n        defaultOptions: x\n      } = y,\n      {\n        extendClass: z,\n        merge: H\n      } = L;\n    var B;\n    (function (u) {\n      function v(a, p) {\n        const l = x.plotOptions || {},\n          m = p.defaultOptions,\n          h = p.prototype;\n        h.type = a;\n        h.pointClass || (h.pointClass = I);\n        m && (l[a] = m);\n        u.seriesTypes[a] = p;\n      }\n      u.seriesTypes = a.seriesTypes;\n      u.registerSeriesType = v;\n      u.seriesType = function (a, p, t, m, h) {\n        const g = x.plotOptions || {};\n        p = p || \"\";\n        g[a] = H(g[p], t);\n        v(a, z(u.seriesTypes[p] || function () {}, m));\n        u.seriesTypes[a].prototype.type = a;\n        h && (u.seriesTypes[a].prototype.pointClass = z(I, h));\n        return u.seriesTypes[a];\n      };\n    })(B || (B = {}));\n    return B;\n  });\n  M(a, \"Core/Series/Series.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Legend/LegendSymbol.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Series/SeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z, H, B, u, v) {\n    const {\n        animObject: l,\n        setAnimation: p\n      } = a,\n      {\n        defaultOptions: t\n      } = y,\n      {\n        registerEventOptions: m\n      } = I,\n      {\n        hasTouch: h,\n        svg: g,\n        win: e\n      } = L,\n      {\n        seriesTypes: w\n      } = B,\n      {\n        arrayMax: x,\n        arrayMin: F,\n        clamp: d,\n        correctFloat: k,\n        defined: r,\n        diffObjects: q,\n        erase: G,\n        error: b,\n        extend: f,\n        find: c,\n        fireEvent: n,\n        getClosestDistance: P,\n        getNestedProperty: D,\n        insertItem: K,\n        isArray: X,\n        isNumber: T,\n        isString: Z,\n        merge: V,\n        objectEach: Y,\n        pick: A,\n        removeEvent: M,\n        splat: ia,\n        syncTimeout: ba\n      } = v;\n    class aa {\n      constructor() {\n        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;\n      }\n      init(b, a) {\n        n(this, \"init\", {\n          options: a\n        });\n        const c = this,\n          d = b.series;\n        this.eventsToUnbind = [];\n        c.chart = b;\n        c.options = c.setOptions(a);\n        a = c.options;\n        c.linkedSeries = [];\n        c.bindAxes();\n        f(c, {\n          name: a.name,\n          state: \"\",\n          visible: !1 !== a.visible,\n          selected: !0 === a.selected\n        });\n        m(this, a);\n        const e = a.events;\n        if (e && e.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) b.runTrackerClick = !0;\n        c.getColor();\n        c.getSymbol();\n        c.parallelArrays.forEach(function (b) {\n          c[b + \"Data\"] || (c[b + \"Data\"] = []);\n        });\n        c.isCartesian && (b.hasCartesianSeries = !0);\n        let g;\n        d.length && (g = d[d.length - 1]);\n        c._i = A(g && g._i, -1) + 1;\n        c.opacity = c.options.opacity;\n        b.orderItems(\"series\", K(this, d));\n        a.dataSorting && a.dataSorting.enabled ? c.setDataSortingOptions() : c.points || c.data || c.setData(a.data, !1);\n        n(this, \"afterInit\");\n      }\n      is(b) {\n        return w[b] && this instanceof w[b];\n      }\n      bindAxes() {\n        const a = this,\n          c = a.options,\n          d = a.chart;\n        let f;\n        n(this, \"bindAxes\", null, function () {\n          (a.axisTypes || []).forEach(function (e) {\n            d[e].forEach(function (b) {\n              f = b.options;\n              if (A(c[e], 0) === b.index || \"undefined\" !== typeof c[e] && c[e] === f.id) K(a, b.series), a[e] = b, b.isDirty = !0;\n            });\n            a[e] || a.optionalAxis === e || b(18, !0, d);\n          });\n        });\n        n(this, \"afterBindAxes\");\n      }\n      updateParallelArrays(b, a, c) {\n        const d = b.series,\n          f = T(a) ? function (c) {\n            const f = \"y\" === c && d.toYData ? d.toYData(b) : b[c];\n            d[c + \"Data\"][a] = f;\n          } : function (b) {\n            Array.prototype[a].apply(d[b + \"Data\"], c);\n          };\n        d.parallelArrays.forEach(f);\n      }\n      hasData() {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      }\n      autoIncrement(b) {\n        var a = this.options;\n        const c = a.pointIntervalUnit,\n          d = a.relativeXValue,\n          f = this.chart.time;\n        let e = this.xIncrement,\n          g;\n        e = A(e, a.pointStart, 0);\n        this.pointInterval = g = A(this.pointInterval, a.pointInterval, 1);\n        d && T(b) && (g *= b);\n        c && (a = new f.Date(e), \"day\" === c ? f.set(\"Date\", a, f.get(\"Date\", a) + g) : \"month\" === c ? f.set(\"Month\", a, f.get(\"Month\", a) + g) : \"year\" === c && f.set(\"FullYear\", a, f.get(\"FullYear\", a) + g), g = a.getTime() - e);\n        if (d && T(b)) return e + g;\n        this.xIncrement = e + g;\n        return e;\n      }\n      setDataSortingOptions() {\n        const b = this.options;\n        f(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        r(b.pointRange) || (b.pointRange = 1);\n      }\n      setOptions(b) {\n        var a, c;\n        const d = this.chart;\n        var f = d.options.plotOptions,\n          e = d.userOptions || {};\n        const g = V(b);\n        b = d.styledMode;\n        const k = {\n          plotOptions: f,\n          userOptions: g\n        };\n        n(this, \"setOptions\", k);\n        const h = k.plotOptions[this.type];\n        e = e.plotOptions || {};\n        const l = e.series || {},\n          m = t.plotOptions[this.type] || {},\n          q = e[this.type] || {};\n        this.userOptions = k.userOptions;\n        f = V(h, f.series, q, g);\n        this.tooltipOptions = V(t.tooltip, null === (a = t.plotOptions.series) || void 0 === a ? void 0 : a.tooltip, null === m || void 0 === m ? void 0 : m.tooltip, d.userOptions.tooltip, null === (c = e.series) || void 0 === c ? void 0 : c.tooltip, q.tooltip, g.tooltip);\n        this.stickyTracking = A(g.stickyTracking, q.stickyTracking, l.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);\n        null === h.marker && delete f.marker;\n        this.zoneAxis = f.zoneAxis;\n        c = this.zones = (f.zones || []).slice();\n        !f.negativeColor && !f.negativeFillColor || f.zones || (a = {\n          value: f[this.zoneAxis + \"Threshold\"] || f.threshold || 0,\n          className: \"highcharts-negative\"\n        }, b || (a.color = f.negativeColor, a.fillColor = f.negativeFillColor), c.push(a));\n        c.length && r(c[c.length - 1].value) && c.push(b ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        n(this, \"afterSetOptions\", {\n          options: f\n        });\n        return f;\n      }\n      getName() {\n        return A(this.options.name, \"Series \" + (this.index + 1));\n      }\n      getCyclic(b, a, c) {\n        const d = this.chart,\n          f = `${b}Index`,\n          e = `${b}Counter`,\n          g = (null === c || void 0 === c ? void 0 : c.length) || d.options.chart.colorCount;\n        if (!a) {\n          var k = A(\"color\" === b ? this.options.colorIndex : void 0, this[f]);\n          r(k) || (d.series.length || (d[e] = 0), k = d[e] % g, d[e] += 1);\n          c && (a = c[k]);\n        }\n        \"undefined\" !== typeof k && (this[f] = k);\n        this[b] = a;\n      }\n      getColor() {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || t.plotOptions[this.type].color, this.chart.options.colors);\n      }\n      getPointsCollection() {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      }\n      getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      }\n      findPointIndex(b, a) {\n        const d = b.id,\n          f = b.x,\n          e = this.points;\n        var g = this.options.dataSorting,\n          k;\n        let h, n;\n        if (d) g = this.chart.get(d), g instanceof z && (k = g);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (k = a => !a.touched && a.index === b.index, g && g.matchByName ? k = a => !a.touched && a.name === b.name : this.options.relativeXValue && (k = a => !a.touched && a.options.x === b.x), k = c(e, k), !k) return;\n        k && (n = k && k.index, \"undefined\" !== typeof n && (h = !0));\n        \"undefined\" === typeof n && T(f) && (n = this.xData.indexOf(f, a));\n        -1 !== n && \"undefined\" !== typeof n && this.cropped && (n = n >= this.cropStart ? n - this.cropStart : n);\n        !h && T(n) && e[n] && e[n].touched && (n = void 0);\n        return n;\n      }\n      updateData(b, a) {\n        const c = this.options,\n          d = c.dataSorting,\n          f = this.points,\n          e = [],\n          g = this.requireSorting,\n          k = b.length === f.length;\n        let n,\n          h,\n          l,\n          m = !0;\n        this.xIncrement = null;\n        b.forEach(function (b, a) {\n          var h = r(b) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, b) || {};\n          const m = h.x;\n          if (h.id || T(m)) {\n            if (h = this.findPointIndex(h, l), -1 === h || \"undefined\" === typeof h ? e.push(b) : f[h] && b !== c.data[h] ? (f[h].update(b, !1, null, !1), f[h].touched = !0, g && (l = h + 1)) : f[h] && (f[h].touched = !0), !k || a !== h || d && d.enabled || this.hasDerivedData) n = !0;\n          } else e.push(b);\n        }, this);\n        if (n) for (b = f.length; b--;) (h = f[b]) && !h.touched && h.remove && h.remove(!1, a);else !k || d && d.enabled ? m = !1 : (b.forEach(function (b, a) {\n          b === f[a].y || f[a].destroyed || f[a].update(b, !1, null, !1);\n        }), e.length = 0);\n        f.forEach(function (b) {\n          b && (b.touched = !1);\n        });\n        if (!m) return !1;\n        e.forEach(function (b) {\n          this.addPoint(b, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = x(this.xData), this.autoIncrement());\n        return !0;\n      }\n      setData(a, c = !0, d, f) {\n        var e;\n        const g = this,\n          k = g.points,\n          h = k && k.length || 0,\n          n = g.options,\n          l = g.chart,\n          m = n.dataSorting,\n          q = g.xAxis,\n          p = n.turboThreshold,\n          r = this.xData,\n          t = this.yData;\n        var w = g.pointArrayMap;\n        w = w && w.length;\n        const J = n.keys;\n        let v,\n          u = 0,\n          O = 1,\n          x = null;\n        if (!l.options.chart.allowMutatingData) {\n          n.data && delete g.options.data;\n          g.userOptions.data && delete g.userOptions.data;\n          var N = V(!0, a);\n        }\n        a = N || a || [];\n        N = a.length;\n        m && m.enabled && (a = this.sortData(a));\n        l.options.chart.allowMutatingData && !1 !== f && N && h && !g.cropped && !g.hasGroupedData && g.visible && !g.boosted && (v = this.updateData(a, d));\n        if (!v) {\n          g.xIncrement = null;\n          g.colorCounter = 0;\n          this.parallelArrays.forEach(function (b) {\n            g[b + \"Data\"].length = 0;\n          });\n          if (p && N > p) {\n            if (x = g.getFirstValidPoint(a), T(x)) for (d = 0; d < N; d++) r[d] = this.autoIncrement(), t[d] = a[d];else if (X(x)) {\n              if (w) {\n                if (x.length === w) for (d = 0; d < N; d++) r[d] = this.autoIncrement(), t[d] = a[d];else for (d = 0; d < N; d++) f = a[d], r[d] = f[0], t[d] = f.slice(1, w + 1);\n              } else if (J && (u = J.indexOf(\"x\"), O = J.indexOf(\"y\"), u = 0 <= u ? u : 0, O = 0 <= O ? O : 1), 1 === x.length && (O = 0), u === O) for (d = 0; d < N; d++) r[d] = this.autoIncrement(), t[d] = a[d][O];else for (d = 0; d < N; d++) f = a[d], r[d] = f[u], t[d] = f[O];\n            } else b(12, !1, l);\n          } else for (d = 0; d < N; d++) f = {\n            series: g\n          }, g.pointClass.prototype.applyOptions.apply(f, [a[d]]), g.updateParallelArrays(f, d);\n          t && Z(t[0]) && b(14, !0, l);\n          g.data = [];\n          g.options.data = g.userOptions.data = a;\n          for (d = h; d--;) null === (e = k[d]) || void 0 === e ? void 0 : e.destroy();\n          q && (q.minRange = q.userMinRange);\n          g.isDirty = l.isDirtyBox = !0;\n          g.isDirtyData = !!k;\n          d = !1;\n        }\n        \"point\" === n.legendType && (this.processData(), this.generatePoints());\n        c && l.redraw(d);\n      }\n      sortData(b) {\n        const a = this,\n          c = a.options.dataSorting.sortKey || \"y\",\n          d = function (b, a) {\n            return r(a) && b.pointClass.prototype.optionsToObject.call({\n              series: b\n            }, a) || {};\n          };\n        b.forEach(function (c, f) {\n          b[f] = d(a, c);\n          b[f].index = f;\n        }, this);\n        b.concat().sort((b, a) => {\n          b = D(c, b);\n          a = D(c, a);\n          return a < b ? -1 : a > b ? 1 : 0;\n        }).forEach(function (b, a) {\n          b.x = a;\n        }, this);\n        a.linkedSeries && a.linkedSeries.forEach(function (a) {\n          const c = a.options,\n            f = c.data;\n          c.dataSorting && c.dataSorting.enabled || !f || (f.forEach(function (c, e) {\n            f[e] = d(a, c);\n            b[e] && (f[e].x = b[e].x, f[e].index = e);\n          }), a.setData(f, !1));\n        });\n        return b;\n      }\n      getProcessedData(a) {\n        const c = this;\n        var d = c.xAxis,\n          f = c.options;\n        const e = f.cropThreshold,\n          g = a || c.getExtremesFromAll || f.getExtremesFromAll,\n          k = null === d || void 0 === d ? void 0 : d.logarithmic,\n          h = c.isCartesian;\n        let n = 0;\n        let l;\n        a = c.xData;\n        f = c.yData;\n        let m = !1;\n        const q = a.length;\n        if (d) {\n          var r = d.getExtremes();\n          l = r.min;\n          r = r.max;\n          m = !(!d.categories || d.names.length);\n        }\n        if (h && c.sorted && !g && (!e || q > e || c.forceCrop)) if (a[q - 1] < l || a[0] > r) a = [], f = [];else if (c.yData && (a[0] < l || a[q - 1] > r)) {\n          var p = this.cropData(c.xData, c.yData, l, r);\n          a = p.xData;\n          f = p.yData;\n          n = p.start;\n          p = !0;\n        }\n        d = P([k ? a.map(k.log2lin) : a], () => c.requireSorting && !m && b(15, !1, c.chart));\n        return {\n          xData: a,\n          yData: f,\n          cropped: p,\n          cropStart: n,\n          closestPointRange: d\n        };\n      }\n      processData(b) {\n        const a = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !b) return !1;\n        b = this.getProcessedData();\n        this.cropped = b.cropped;\n        this.cropStart = b.cropStart;\n        this.processedXData = b.xData;\n        this.processedYData = b.yData;\n        this.closestPointRange = this.basePointRange = b.closestPointRange;\n        n(this, \"afterProcessData\");\n      }\n      cropData(b, a, c, d, f) {\n        const e = b.length;\n        let g,\n          k = 0,\n          h = e;\n        f = A(f, this.cropShoulder);\n        for (g = 0; g < e; g++) if (b[g] >= c) {\n          k = Math.max(0, g - f);\n          break;\n        }\n        for (c = g; c < e; c++) if (b[c] > d) {\n          h = c + f;\n          break;\n        }\n        return {\n          xData: b.slice(k, h),\n          yData: a.slice(k, h),\n          start: k,\n          end: h\n        };\n      }\n      generatePoints() {\n        var b = this.options;\n        const a = this.processedData || b.data,\n          c = this.processedXData,\n          d = this.processedYData,\n          e = this.pointClass,\n          g = c.length,\n          k = this.cropStart || 0,\n          h = this.hasGroupedData,\n          l = b.keys,\n          m = [];\n        b = b.dataGrouping && b.dataGrouping.groupAll ? k : 0;\n        let q;\n        let r,\n          p,\n          t = this.data;\n        if (!t && !h) {\n          var w = [];\n          w.length = a.length;\n          t = this.data = w;\n        }\n        l && h && (this.options.keys = !1);\n        for (p = 0; p < g; p++) w = k + p, h ? (r = new e().init(this, [c[p]].concat(ia(d[p]))), r.dataGroup = this.groupMap[b + p], r.dataGroup.options && (r.options = r.dataGroup.options, f(r, r.dataGroup.options), delete r.dataLabels)) : (r = t[w]) || \"undefined\" === typeof a[w] || (t[w] = r = new e().init(this, a[w], c[p])), r && (r.index = h ? b + p : w, m[p] = r);\n        this.options.keys = l;\n        if (t && (g !== (q = t.length) || h)) for (p = 0; p < q; p++) p !== k || h || (p += g), t[p] && (t[p].destroyElements(), t[p].plotX = void 0);\n        this.data = t;\n        this.points = m;\n        n(this, \"afterGeneratePoints\");\n      }\n      getXExtremes(b) {\n        return {\n          min: F(b),\n          max: x(b)\n        };\n      }\n      getExtremes(b, a) {\n        const c = this.xAxis;\n        var d = this.yAxis;\n        const f = this.processedXData || this.xData,\n          e = [],\n          g = this.requireSorting ? this.cropShoulder : 0;\n        d = d ? d.positiveValuesOnly : !1;\n        let k,\n          h = 0,\n          l = 0,\n          m = 0;\n        b = b || this.stackedYData || this.processedYData || [];\n        const q = b.length;\n        if (c) {\n          var p = c.getExtremes();\n          h = p.min;\n          l = p.max;\n        }\n        for (k = 0; k < q; k++) {\n          var r = f[k];\n          p = b[k];\n          var t = (T(p) || X(p)) && (p.length || 0 < p || !d);\n          r = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c || (f[k + g] || r) >= h && (f[k - g] || r) <= l;\n          if (t && r) if (t = p.length) for (; t--;) T(p[t]) && (e[m++] = p[t]);else e[m++] = p;\n        }\n        b = {\n          activeYData: e,\n          dataMin: F(e),\n          dataMax: x(e)\n        };\n        n(this, \"afterGetExtremes\", {\n          dataExtremes: b\n        });\n        return b;\n      }\n      applyExtremes() {\n        const b = this.getExtremes();\n        this.dataMin = b.dataMin;\n        this.dataMax = b.dataMax;\n        return b;\n      }\n      getFirstValidPoint(b) {\n        const a = b.length;\n        let c = 0,\n          d = null;\n        for (; null === d && c < a;) d = b[c], c++;\n        return d;\n      }\n      translate() {\n        var b;\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options;\n        const c = a.stacking,\n          f = this.xAxis,\n          e = f.categories,\n          g = this.enabledDataSorting,\n          h = this.yAxis,\n          l = this.points,\n          m = l.length,\n          q = this.pointPlacementToXValue(),\n          p = !!q,\n          t = a.threshold;\n        a = a.startFromThreshold ? t : 0;\n        let w,\n          v,\n          u,\n          x,\n          D = Number.MAX_VALUE;\n        for (w = 0; w < m; w++) {\n          const n = l[w],\n            m = n.x;\n          let J,\n            Q,\n            R = n.y,\n            O = n.low;\n          const E = c && (null === (b = h.stacking) || void 0 === b ? void 0 : b.stacks[(this.negStacks && R < (a ? 0 : t) ? \"-\" : \"\") + this.stackKey]);\n          v = f.translate(m, !1, !1, !1, !0, q);\n          n.plotX = T(v) ? k(d(v, -1E5, 1E5)) : void 0;\n          c && this.visible && E && E[m] && (x = this.getStackIndicator(x, m, this.index), !n.isNull && x.key && (J = E[m], Q = J.points[x.key]), J && X(Q) && (O = Q[0], R = Q[1], O === a && x.key === E[m].base && (O = A(T(t) ? t : h.min)), h.positiveValuesOnly && r(O) && 0 >= O && (O = void 0), n.total = n.stackTotal = A(J.total), n.percentage = r(n.y) && J.total ? n.y / J.total * 100 : void 0, n.stackY = R, this.irregularWidths || J.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis)));\n          n.yBottom = r(O) ? d(h.translate(O, !1, !0, !1, !0), -1E5, 1E5) : void 0;\n          this.dataModify && (R = this.dataModify.modifyValue(R, w));\n          let N;\n          T(R) && void 0 !== n.plotX && (N = h.translate(R, !1, !0, !1, !0), N = T(N) ? d(N, -1E5, 1E5) : void 0);\n          n.plotY = N;\n          n.isInside = this.isPointInside(n);\n          n.clientX = p ? k(f.translate(m, !1, !1, !1, !0, q)) : v;\n          n.negative = (n.y || 0) < (t || 0);\n          n.category = A(e && e[n.x], n.x);\n          n.isNull || !1 === n.visible || (\"undefined\" !== typeof u && (D = Math.min(D, Math.abs(v - u))), u = v);\n          n.zone = this.zones.length ? n.getZone() : void 0;\n          !n.graphic && this.group && g && (n.isNew = !0);\n        }\n        this.closestPointRangePx = D;\n        n(this, \"afterTranslate\");\n      }\n      getValidPoints(b, a, c) {\n        const d = this.chart;\n        return (b || this.points || []).filter(function (b) {\n          const {\n            plotX: f,\n            plotY: e\n          } = b;\n          return !c && (b.isNull || !T(e)) || a && !d.isInsidePlot(f, e, {\n            inverted: d.inverted\n          }) ? !1 : !1 !== b.visible;\n        });\n      }\n      getClipBox() {\n        const {\n            chart: b,\n            xAxis: a,\n            yAxis: c\n          } = this,\n          d = V(b.clipBox);\n        a && a.len !== b.plotSizeX && (d.width = a.len);\n        c && c.len !== b.plotSizeY && (d.height = c.len);\n        return d;\n      }\n      getSharedClipKey() {\n        return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0);\n      }\n      setClip() {\n        const {\n            chart: b,\n            group: a,\n            markerGroup: c\n          } = this,\n          d = b.sharedClips,\n          f = b.renderer,\n          e = this.getClipBox(),\n          g = this.getSharedClipKey();\n        let k = d[g];\n        k ? k.animate(e) : d[g] = k = f.clipRect(e);\n        a && a.clip(!1 === this.options.clip ? void 0 : k);\n        c && c.clip();\n      }\n      animate(b) {\n        const {\n            chart: a,\n            group: c,\n            markerGroup: d\n          } = this,\n          f = a.inverted;\n        var e = l(this.options.animation),\n          g = [this.getSharedClipKey(), e.duration, e.easing, e.defer].join();\n        let k = a.sharedClips[g],\n          n = a.sharedClips[g + \"m\"];\n        if (b && c) e = this.getClipBox(), k ? k.attr(\"height\", e.height) : (e.width = 0, f && (e.x = a.plotHeight), k = a.renderer.clipRect(e), a.sharedClips[g] = k, n = a.renderer.clipRect({\n          x: -99,\n          y: -99,\n          width: f ? a.plotWidth + 199 : 99,\n          height: f ? 99 : a.plotHeight + 199\n        }), a.sharedClips[g + \"m\"] = n), c.clip(k), d && d.clip(n);else if (k && !k.hasClass(\"highcharts-animating\")) {\n          g = this.getClipBox();\n          const b = e.step;\n          d && d.element.childNodes.length && (e.step = function (a, c) {\n            b && b.apply(c, arguments);\n            \"width\" === c.prop && n && n.element && n.attr(f ? \"height\" : \"width\", a + 99);\n          });\n          k.addClass(\"highcharts-animating\").animate(g, e);\n        }\n      }\n      afterAnimate() {\n        this.setClip();\n        Y(this.chart.sharedClips, (b, a, c) => {\n          b && !this.chart.container.querySelector(`[clip-path=\"url(#${b.id})\"]`) && (b.destroy(), delete c[a]);\n        });\n        this.finishedAnimating = !0;\n        n(this, \"afterAnimate\");\n      }\n      drawPoints(b = this.points) {\n        const a = this.chart,\n          c = a.styledMode,\n          {\n            colorAxis: d,\n            options: f\n          } = this,\n          e = f.marker,\n          g = this[this.specialGroup || \"markerGroup\"],\n          k = this.xAxis,\n          n = A(e.enabled, !k || k.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius);\n        let h, l, m, q;\n        let p, r;\n        if (!1 !== e.enabled || this._hasPointMarkers) for (h = 0; h < b.length; h++) {\n          l = b[h];\n          q = (m = l.graphic) ? \"animate\" : \"attr\";\n          var t = l.marker || {};\n          p = !!l.marker;\n          if ((n && \"undefined\" === typeof t.enabled || t.enabled) && !l.isNull && !1 !== l.visible) {\n            const b = A(t.symbol, this.symbol, \"rect\");\n            r = this.markerAttribs(l, l.selected && \"select\");\n            this.enabledDataSorting && (l.startXPos = k.reversed ? -(r.width || 0) : k.width);\n            const f = !1 !== l.isInside;\n            !m && f && (0 < (r.width || 0) || l.hasImage) && (l.graphic = m = a.renderer.symbol(b, r.x, r.y, r.width, r.height, p ? t : e).add(g), this.enabledDataSorting && a.hasRendered && (m.attr({\n              x: l.startXPos\n            }), q = \"animate\"));\n            m && \"animate\" === q && m[f ? \"show\" : \"hide\"](f).animate(r);\n            if (m) if (t = this.pointAttribs(l, c || !l.selected ? void 0 : \"select\"), c) d && m.css({\n              fill: t.fill\n            });else m[q](t);\n            m && m.addClass(l.getClassName(), !0);\n          } else m && (l.graphic = m.destroy());\n        }\n      }\n      markerAttribs(b, a) {\n        const c = this.options;\n        var d = c.marker;\n        const f = b.marker || {},\n          e = f.symbol || d.symbol,\n          g = {};\n        let k = A(f.radius, d && d.radius);\n        a && (d = d.states[a], a = f.states && f.states[a], k = A(a && a.radius, d && d.radius, k && k + (d && d.radiusPlus || 0)));\n        b.hasImage = e && 0 === e.indexOf(\"url\");\n        b.hasImage && (k = 0);\n        b = b.pos();\n        T(k) && b && (g.x = b[0] - k, g.y = b[1] - k, c.crisp && (g.x = Math.floor(g.x)));\n        k && (g.width = g.height = 2 * k);\n        return g;\n      }\n      pointAttribs(b, a) {\n        var c = this.options.marker,\n          d = b && b.options;\n        const f = d && d.marker || {};\n        var e = d && d.color,\n          g = b && b.color;\n        const k = b && b.zone && b.zone.color;\n        let n = this.color;\n        b = A(f.lineWidth, c.lineWidth);\n        d = 1;\n        n = e || k || g || n;\n        e = f.fillColor || c.fillColor || n;\n        g = f.lineColor || c.lineColor || n;\n        a = a || \"normal\";\n        c = c.states[a] || {};\n        a = f.states && f.states[a] || {};\n        b = A(a.lineWidth, c.lineWidth, b + A(a.lineWidthPlus, c.lineWidthPlus, 0));\n        e = a.fillColor || c.fillColor || e;\n        g = a.lineColor || c.lineColor || g;\n        d = A(a.opacity, c.opacity, d);\n        return {\n          stroke: g,\n          \"stroke-width\": b,\n          fill: e,\n          opacity: d\n        };\n      }\n      destroy(b) {\n        const a = this,\n          c = a.chart,\n          d = /AppleWebKit\\/533/.test(e.navigator.userAgent),\n          f = a.data || [];\n        let g, k, h, l;\n        n(a, \"destroy\", {\n          keepEventsForUpdate: b\n        });\n        this.removeEvents(b);\n        (a.axisTypes || []).forEach(function (b) {\n          (l = a[b]) && l.series && (G(l.series, a), l.isDirty = l.forceRedraw = !0);\n        });\n        a.legendItem && a.chart.legend.destroyItem(a);\n        for (k = f.length; k--;) (h = f[k]) && h.destroy && h.destroy();\n        a.clips && a.clips.forEach(b => b.destroy());\n        v.clearTimeout(a.animationTimeout);\n        Y(a, function (b, a) {\n          b instanceof u && !b.survive && (g = d && \"group\" === a ? \"hide\" : \"destroy\", b[g]());\n        });\n        c.hoverSeries === a && (c.hoverSeries = void 0);\n        G(c.series, a);\n        c.orderItems(\"series\");\n        Y(a, function (c, d) {\n          b && \"hcEvents\" === d || delete a[d];\n        });\n      }\n      applyZones() {\n        const b = this,\n          a = this.chart,\n          c = a.renderer,\n          f = this.zones,\n          e = this.clips || [],\n          g = this.graph,\n          k = this.area,\n          n = Math.max(a.plotWidth, a.plotHeight),\n          h = this[(this.zoneAxis || \"y\") + \"Axis\"],\n          l = a.inverted;\n        let m,\n          q,\n          p,\n          r,\n          t,\n          w,\n          v,\n          u,\n          x,\n          D,\n          E,\n          G = !1;\n        f.length && (g || k) && h && \"undefined\" !== typeof h.min ? (t = h.reversed, w = h.horiz, g && !this.showLine && g.hide(), k && k.hide(), r = h.getExtremes(), f.forEach(function (f, Q) {\n          m = t ? w ? a.plotWidth : 0 : w ? 0 : h.toPixels(r.min) || 0;\n          m = d(A(q, m), 0, n);\n          q = d(Math.round(h.toPixels(A(f.value, r.max), !0) || 0), 0, n);\n          G && (m = q = h.toPixels(r.max));\n          v = Math.abs(m - q);\n          u = Math.min(m, q);\n          x = Math.max(m, q);\n          h.isXAxis ? (p = {\n            x: l ? x : u,\n            y: 0,\n            width: v,\n            height: n\n          }, w || (p.x = a.plotHeight - p.x)) : (p = {\n            x: 0,\n            y: l ? x : u,\n            width: n,\n            height: v\n          }, w && (p.y = a.plotWidth - p.y));\n          e[Q] ? e[Q].animate(p) : e[Q] = c.clipRect(p);\n          D = b[\"zone-area-\" + Q];\n          E = b[\"zone-graph-\" + Q];\n          g && E && E.clip(e[Q]);\n          k && D && D.clip(e[Q]);\n          G = f.value > r.max;\n          b.resetZones && 0 === q && (q = void 0);\n        }), this.clips = e) : b.visible && (g && g.show(), k && k.show());\n      }\n      plotGroup(b, a, c, d, f) {\n        let e = this[b];\n        const g = !e;\n        c = {\n          visibility: c,\n          zIndex: d || .1\n        };\n        \"undefined\" === typeof this.opacity || this.chart.styledMode || \"inactive\" === this.state || (c.opacity = this.opacity);\n        g && (this[b] = e = this.chart.renderer.g().add(f));\n        e.addClass(\"highcharts-\" + a + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (r(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (e.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        e.attr(c)[g ? \"attr\" : \"animate\"](this.getPlotBox(a));\n        return e;\n      }\n      getPlotBox(b) {\n        let a = this.xAxis,\n          c = this.yAxis;\n        const d = this.chart;\n        b = d.inverted && !d.polar && a && !1 !== this.invertible && \"series\" === b;\n        d.inverted && (a = c, c = this.xAxis);\n        return {\n          translateX: a ? a.left : d.plotLeft,\n          translateY: c ? c.top : d.plotTop,\n          rotation: b ? 90 : 0,\n          rotationOriginX: b ? (a.len - c.len) / 2 : 0,\n          rotationOriginY: b ? (a.len + c.len) / 2 : 0,\n          scaleX: b ? -1 : 1,\n          scaleY: 1\n        };\n      }\n      removeEvents(b) {\n        b || M(this);\n        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {\n          b();\n        }), this.eventsToUnbind.length = 0);\n      }\n      render() {\n        const b = this;\n        var a = b.chart;\n        const c = b.options,\n          d = l(c.animation),\n          f = b.visible ? \"inherit\" : \"hidden\",\n          e = c.zIndex,\n          g = b.hasRendered;\n        a = a.seriesGroup;\n        let k = b.finishedAnimating ? 0 : d.duration;\n        n(this, \"render\");\n        b.plotGroup(\"group\", \"series\", f, e, a);\n        b.markerGroup = b.plotGroup(\"markerGroup\", \"markers\", f, e, a);\n        !1 !== c.clip && b.setClip();\n        b.animate && k && b.animate(!0);\n        b.drawGraph && (b.drawGraph(), b.applyZones());\n        b.visible && b.drawPoints();\n        b.drawDataLabels && b.drawDataLabels();\n        b.redrawPoints && b.redrawPoints();\n        b.drawTracker && c.enableMouseTracking && b.drawTracker();\n        b.animate && k && b.animate();\n        g || (k && d.defer && (k += d.defer), b.animationTimeout = ba(function () {\n          b.afterAnimate();\n        }, k || 0));\n        b.isDirty = !1;\n        b.hasRendered = !0;\n        n(b, \"afterRender\");\n      }\n      redraw() {\n        const b = this.isDirty || this.isDirtyData;\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      }\n      searchPoint(b, a) {\n        const c = this.xAxis,\n          d = this.yAxis,\n          f = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: f ? c.len - b.chartY + c.pos : b.chartX - c.pos,\n          plotY: f ? d.len - b.chartX + d.pos : b.chartY - d.pos\n        }, a, b);\n      }\n      buildKDTree(b) {\n        function a(b, d, f) {\n          var e = b && b.length;\n          let g;\n          if (e) return g = c.kdAxisArray[d % f], b.sort(function (b, a) {\n            return b[g] - a[g];\n          }), e = Math.floor(e / 2), {\n            point: b[e],\n            left: a(b.slice(0, e), d + 1, f),\n            right: a(b.slice(e + 1), d + 1, f)\n          };\n        }\n        this.buildingKdTree = !0;\n        const c = this,\n          d = -1 < c.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete c.kdTree;\n        ba(function () {\n          c.kdTree = a(c.getValidPoints(null, !c.directTouch), d, d);\n          c.buildingKdTree = !1;\n        }, c.options.kdNow || b && \"touchstart\" === b.type ? 0 : 1);\n      }\n      searchKDTree(b, a, c) {\n        function d(b, a, c, n) {\n          const h = a.point;\n          var l = f.kdAxisArray[c % n];\n          let m = h;\n          var q = r(b[e]) && r(h[e]) ? Math.pow(b[e] - h[e], 2) : null;\n          var p = r(b[g]) && r(h[g]) ? Math.pow(b[g] - h[g], 2) : null;\n          p = (q || 0) + (p || 0);\n          h.dist = r(p) ? Math.sqrt(p) : Number.MAX_VALUE;\n          h.distX = r(q) ? Math.sqrt(q) : Number.MAX_VALUE;\n          l = b[l] - h[l];\n          p = 0 > l ? \"left\" : \"right\";\n          q = 0 > l ? \"right\" : \"left\";\n          a[p] && (p = d(b, a[p], c + 1, n), m = p[k] < m[k] ? p : h);\n          a[q] && Math.sqrt(l * l) < m[k] && (b = d(b, a[q], c + 1, n), m = b[k] < m[k] ? b : m);\n          return m;\n        }\n        const f = this,\n          e = this.kdAxisArray[0],\n          g = this.kdAxisArray[1],\n          k = a ? \"distX\" : \"dist\";\n        a = -1 < f.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(c);\n        if (this.kdTree) return d(b, this.kdTree, a, a);\n      }\n      pointPlacementToXValue() {\n        const {\n          options: {\n            pointPlacement: b,\n            pointRange: a\n          },\n          xAxis: c\n        } = this;\n        let d = b;\n        \"between\" === d && (d = c.reversed ? -.5 : .5);\n        return T(d) ? d * (a || c.pointRange) : 0;\n      }\n      isPointInside(b) {\n        const {\n          chart: a,\n          xAxis: c,\n          yAxis: d\n        } = this;\n        return \"undefined\" !== typeof b.plotY && \"undefined\" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= (d ? d.len : a.plotHeight) && 0 <= b.plotX && b.plotX <= (c ? c.len : a.plotWidth);\n      }\n      drawTracker() {\n        const b = this,\n          a = b.options,\n          c = a.trackByArea,\n          d = [].concat(c ? b.areaPath : b.graphPath),\n          f = b.chart,\n          e = f.pointer,\n          k = f.renderer,\n          l = f.options.tooltip.snap,\n          m = b.tracker,\n          q = function (c) {\n            if (a.enableMouseTracking && f.hoverSeries !== b) b.onMouseOver();\n          },\n          p = \"rgba(192,192,192,\" + (g ? .0001 : .002) + \")\";\n        m ? m.attr({\n          d\n        }) : b.graph && (b.tracker = k.path(d).attr({\n          visibility: b.visible ? \"inherit\" : \"hidden\",\n          zIndex: 2\n        }).addClass(c ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(b.group), f.styledMode || b.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: p,\n          fill: c ? p : \"none\",\n          \"stroke-width\": b.graph.strokeWidth() + (c ? 0 : 2 * l)\n        }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {\n          if (b && (b.addClass(\"highcharts-tracker\").on(\"mouseover\", q).on(\"mouseout\", function (b) {\n            e.onTrackerMouseOut(b);\n          }), a.cursor && !f.styledMode && b.css({\n            cursor: a.cursor\n          }), h)) b.on(\"touchstart\", q);\n        }));\n        n(this, \"afterDrawTracker\");\n      }\n      addPoint(b, a, c, d, f) {\n        const e = this.options,\n          g = this.data,\n          k = this.chart;\n        var h = this.xAxis;\n        h = h && h.hasNames && h.names;\n        const l = e.data,\n          m = this.xData;\n        let q, p;\n        a = A(a, !0);\n        const r = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(r, [b]);\n        const t = r.x;\n        p = m.length;\n        if (this.requireSorting && t < m[p - 1]) for (q = !0; p && m[p - 1] > t;) p--;\n        this.updateParallelArrays(r, \"splice\", [p, 0, 0]);\n        this.updateParallelArrays(r, p);\n        h && r.name && (h[t] = r.name);\n        l.splice(p, 0, b);\n        if (q || this.processedData) this.data.splice(p, 0, null), this.processData();\n        \"point\" === e.legendType && this.generatePoints();\n        c && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), this.updateParallelArrays(r, \"shift\"), l.shift()));\n        !1 !== f && n(this, \"addPoint\", {\n          point: r\n        });\n        this.isDirtyData = this.isDirty = !0;\n        a && k.redraw(d);\n      }\n      removePoint(b, a, c) {\n        const d = this,\n          f = d.data,\n          e = f[b],\n          g = d.points,\n          k = d.chart,\n          h = function () {\n            g && g.length === f.length && g.splice(b, 1);\n            f.splice(b, 1);\n            d.options.data.splice(b, 1);\n            d.updateParallelArrays(e || {\n              series: d\n            }, \"splice\", [b, 1]);\n            e && e.destroy();\n            d.isDirty = !0;\n            d.isDirtyData = !0;\n            a && k.redraw();\n          };\n        p(c, k);\n        a = A(a, !0);\n        e ? e.firePointEvent(\"remove\", null, h) : h();\n      }\n      remove(b, a, c, d) {\n        function f() {\n          e.destroy(d);\n          g.isDirtyLegend = g.isDirtyBox = !0;\n          g.linkSeries(d);\n          A(b, !0) && g.redraw(a);\n        }\n        const e = this,\n          g = e.chart;\n        !1 !== c ? n(e, \"remove\", null, f) : f();\n      }\n      update(a, c) {\n        a = q(a, this.userOptions);\n        n(this, \"update\", {\n          options: a\n        });\n        const d = this,\n          e = d.chart;\n        var g = d.userOptions;\n        const k = d.initialType || d.type;\n        var h = e.options.plotOptions;\n        const l = w[k].prototype;\n        var m = d.finishedAnimating && {\n          animation: !1\n        };\n        const p = {};\n        let r,\n          t = [\"colorIndex\", \"eventOptions\", \"navigatorSeries\", \"symbolIndex\", \"baseSeries\"],\n          v = a.type || g.type || e.options.chart.type;\n        const u = !(this.hasDerivedData || v && v !== this.type || \"undefined\" !== typeof a.pointStart || \"undefined\" !== typeof a.pointInterval || \"undefined\" !== typeof a.relativeXValue || a.joinBy || a.mapData || d.hasOptionChanged(\"dataGrouping\") || d.hasOptionChanged(\"pointStart\") || d.hasOptionChanged(\"pointInterval\") || d.hasOptionChanged(\"pointIntervalUnit\") || d.hasOptionChanged(\"keys\"));\n        v = v || k;\n        u && (t.push(\"data\", \"isDirtyData\", \"points\", \"processedData\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"clips\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== a.visible && t.push(\"area\", \"graph\"), d.parallelArrays.forEach(function (b) {\n          t.push(b + \"Data\");\n        }), a.data && (a.dataSorting && f(d.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));\n        a = V(g, m, {\n          index: \"undefined\" === typeof g.index ? d.index : g.index,\n          pointStart: A(h && h.series && h.series.pointStart, g.pointStart, d.xData[0])\n        }, !u && {\n          data: d.options.data\n        }, a);\n        u && a.data && (a.data = d.options.data);\n        t = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(t);\n        t.forEach(function (b) {\n          t[b] = d[b];\n          delete d[b];\n        });\n        h = !1;\n        if (w[v]) {\n          if (h = v !== d.type, d.remove(!1, !1, !1, !0), h) if (Object.setPrototypeOf) Object.setPrototypeOf(d, w[v].prototype);else {\n            m = Object.hasOwnProperty.call(d, \"hcEvents\") && d.hcEvents;\n            for (r in l) d[r] = void 0;\n            f(d, w[v].prototype);\n            m ? d.hcEvents = m : delete d.hcEvents;\n          }\n        } else b(17, !0, e, {\n          missingModuleFor: v\n        });\n        t.forEach(function (b) {\n          d[b] = t[b];\n        });\n        d.init(e, a);\n        if (u && this.points) {\n          a = d.options;\n          if (!1 === a.visible) p.graphic = 1, p.dataLabel = 1;else if (!d._hasPointLabels) {\n            const {\n              marker: b,\n              dataLabels: c\n            } = a;\n            g = g.marker || {};\n            !b || !1 !== b.enabled && g.symbol === b.symbol && g.height === b.height && g.width === b.width || (p.graphic = 1);\n            c && !1 === c.enabled && (p.dataLabel = 1);\n          }\n          for (const b of this.points) b && b.series && (b.resolveColor(), Object.keys(p).length && b.destroyElements(p), !1 === a.showInLegend && b.legendItem && e.legend.destroyItem(b));\n        }\n        d.initialType = k;\n        e.linkSeries();\n        h && d.linkedSeries.length && (d.isDirtyData = !0);\n        n(this, \"afterUpdate\");\n        A(c, !0) && e.redraw(u ? void 0 : !1);\n      }\n      setName(b) {\n        this.name = this.options.name = this.userOptions.name = b;\n        this.chart.isDirtyLegend = !0;\n      }\n      hasOptionChanged(b) {\n        const a = this.options[b],\n          c = this.chart.options.plotOptions,\n          d = this.userOptions[b];\n        return d ? a !== d : a !== A(c && c[this.type] && c[this.type][b], c && c.series && c.series[b], a);\n      }\n      onMouseOver() {\n        const b = this.chart,\n          a = b.hoverSeries;\n        b.pointer.setHoverChartIndex();\n        if (a && a !== this) a.onMouseOut();\n        this.options.events.mouseOver && n(this, \"mouseOver\");\n        this.setState(\"hover\");\n        b.hoverSeries = this;\n      }\n      onMouseOut() {\n        const b = this.options,\n          a = this.chart,\n          c = a.tooltip,\n          d = a.hoverPoint;\n        a.hoverSeries = null;\n        if (d) d.onMouseOut();\n        this && b.events.mouseOut && n(this, \"mouseOut\");\n        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();\n        a.series.forEach(function (b) {\n          b.setState(\"\", !0);\n        });\n      }\n      setState(b, a) {\n        const c = this;\n        var d = c.options;\n        const f = c.graph,\n          e = d.inactiveOtherPoints,\n          g = d.states,\n          k = A(g[b || \"normal\"] && g[b || \"normal\"].animation, c.chart.options.chart.animation);\n        let h = d.lineWidth,\n          n = 0,\n          l = d.opacity;\n        b = b || \"\";\n        if (c.state !== b && ([c.group, c.markerGroup, c.dataLabelsGroup].forEach(function (a) {\n          a && (c.state && a.removeClass(\"highcharts-series-\" + c.state), b && a.addClass(\"highcharts-series-\" + b));\n        }), c.state = b, !c.chart.styledMode)) {\n          if (g[b] && !1 === g[b].enabled) return;\n          b && (h = g[b].lineWidth || h + (g[b].lineWidthPlus || 0), l = A(g[b].opacity, l));\n          if (f && !f.dashstyle && T(h)) for (d = {\n            \"stroke-width\": h\n          }, f.animate(d, k); c[\"zone-graph-\" + n];) c[\"zone-graph-\" + n].animate(d, k), n += 1;\n          e || [c.group, c.markerGroup, c.dataLabelsGroup, c.labelBySeries].forEach(function (b) {\n            b && b.animate({\n              opacity: l\n            }, k);\n          });\n        }\n        a && e && c.points && c.setAllPointsToState(b || void 0);\n      }\n      setAllPointsToState(b) {\n        this.points.forEach(function (a) {\n          a.setState && a.setState(b);\n        });\n      }\n      setVisible(b, a) {\n        const c = this,\n          d = c.chart,\n          f = d.options.chart.ignoreHiddenSeries,\n          e = c.visible,\n          g = (c.visible = b = c.options.visible = c.userOptions.visible = \"undefined\" === typeof b ? !e : b) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (b) {\n          if (c[b]) c[b][g]();\n        });\n        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();\n        c.legendItem && d.legend.colorizeItem(c, b);\n        c.isDirty = !0;\n        c.options.stacking && d.series.forEach(function (b) {\n          b.options.stacking && b.visible && (b.isDirty = !0);\n        });\n        c.linkedSeries.forEach(function (a) {\n          a.setVisible(b, !1);\n        });\n        f && (d.isDirtyBox = !0);\n        n(c, g);\n        !1 !== a && d.redraw();\n      }\n      show() {\n        this.setVisible(!0);\n      }\n      hide() {\n        this.setVisible(!1);\n      }\n      select(b) {\n        this.selected = b = this.options.selected = \"undefined\" === typeof b ? !this.selected : b;\n        this.checkbox && (this.checkbox.checked = b);\n        n(this, b ? \"select\" : \"unselect\");\n      }\n      shouldShowTooltip(b, a, c = {}) {\n        c.series = this;\n        c.visiblePlotOnly = !0;\n        return this.chart.isInsidePlot(b, a, c);\n      }\n      drawLegendSymbol(b, a) {\n        var c;\n        null === (c = C[this.options.legendSymbol || \"rectangle\"]) || void 0 === c ? void 0 : c.call(this, b, a);\n      }\n    }\n    aa.defaultOptions = H;\n    aa.types = B.seriesTypes;\n    aa.registerType = B.registerSeriesType;\n    f(aa.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: z,\n      requireSorting: !0,\n      sorted: !0\n    });\n    B.series = aa;\n    \"\";\n    \"\";\n    return aa;\n  });\n  M(a, \"Core/Chart/Chart.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Defaults.js\"], a[\"Core/Templating.js\"], a[\"Core/Foundation.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Time.js\"], a[\"Core/Utilities.js\"], a[\"Core/Renderer/HTML/AST.js\"]], function (a, y, I, L, C, z, H, B, u, v, l, p, t) {\n    const {\n        animate: m,\n        animObject: h,\n        setAnimation: g\n      } = a,\n      {\n        defaultOptions: e,\n        defaultTime: w\n      } = I,\n      {\n        numberFormat: x\n      } = L,\n      {\n        registerEventOptions: F\n      } = C,\n      {\n        charts: d,\n        doc: k,\n        marginNames: r,\n        svg: q,\n        win: G\n      } = z,\n      {\n        seriesTypes: b\n      } = u,\n      {\n        addEvent: f,\n        attr: c,\n        createElement: n,\n        css: P,\n        defined: D,\n        diffObjects: K,\n        discardElement: X,\n        erase: T,\n        error: Z,\n        extend: V,\n        find: Y,\n        fireEvent: A,\n        getStyle: M,\n        isArray: ia,\n        isNumber: ba,\n        isObject: aa,\n        isString: J,\n        merge: N,\n        objectEach: O,\n        pick: S,\n        pInt: W,\n        relativeLength: ha,\n        removeEvent: da,\n        splat: fa,\n        syncTimeout: ka,\n        uniqueKey: ca\n      } = p;\n    class ea {\n      static chart(b, a, c) {\n        return new ea(b, a, c);\n      }\n      constructor(b, a, c) {\n        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.sharedClips = {};\n        this.zooming = this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;\n        this.getArgs(b, a, c);\n      }\n      getArgs(b, a, c) {\n        J(b) || b.nodeName ? (this.renderTo = b, this.init(a, c)) : this.init(b, a);\n      }\n      setZoomOptions() {\n        const b = this.options.chart,\n          a = b.zooming;\n        this.zooming = Object.assign(Object.assign({}, a), {\n          type: S(b.zoomType, a.type),\n          key: S(b.zoomKey, a.key),\n          pinchType: S(b.pinchType, a.pinchType),\n          singleTouch: S(b.zoomBySingleTouch, a.singleTouch, !1),\n          resetButton: N(a.resetButton, b.resetZoomButton)\n        });\n      }\n      init(b, a) {\n        A(this, \"init\", {\n          args: arguments\n        }, function () {\n          const c = N(e, b),\n            f = c.chart;\n          this.userOptions = V({}, b);\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = a;\n          this.isResizing = 0;\n          this.options = c;\n          this.axes = [];\n          this.series = [];\n          this.time = b.time && Object.keys(b.time).length ? new l(b.time) : z.time;\n          this.numberFormatter = f.numberFormatter || x;\n          this.styledMode = f.styledMode;\n          this.hasCartesianSeries = f.showAxes;\n          this.index = d.length;\n          d.push(this);\n          z.chartCount++;\n          F(this, f);\n          this.xAxis = [];\n          this.yAxis = [];\n          this.pointCount = this.colorCounter = this.symbolCounter = 0;\n          this.setZoomOptions();\n          A(this, \"afterInit\");\n          this.firstRender();\n        });\n      }\n      initSeries(a) {\n        var c = this.options.chart;\n        c = a.type || c.type;\n        const d = b[c];\n        d || Z(17, !0, this, {\n          missingModuleFor: c\n        });\n        c = new d();\n        \"function\" === typeof c.init && c.init(this, a);\n        return c;\n      }\n      setSeriesData() {\n        this.getSeriesOrderByLinks().forEach(function (b) {\n          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);\n        });\n      }\n      getSeriesOrderByLinks() {\n        return this.series.concat().sort(function (b, a) {\n          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;\n        });\n      }\n      orderItems(b, a = 0) {\n        const c = this[b],\n          d = this.options[b] = fa(this.options[b]).slice();\n        b = this.userOptions[b] = this.userOptions[b] ? fa(this.userOptions[b]).slice() : [];\n        this.hasRendered && (d.splice(a), b.splice(a));\n        if (c) for (let f = a, e = c.length; f < e; ++f) if (a = c[f]) a.index = f, a instanceof B && (a.name = a.getName()), a.options.isInternal || (d[f] = a.options, b[f] = a.userOptions);\n      }\n      isInsidePlot(b, a, c = {}) {\n        const {\n          inverted: d,\n          plotBox: f,\n          plotLeft: e,\n          plotTop: g,\n          scrollablePlotBox: k\n        } = this;\n        var h = 0;\n        let n = 0;\n        c.visiblePlotOnly && this.scrollingContainer && ({\n          scrollLeft: h,\n          scrollTop: n\n        } = this.scrollingContainer);\n        const l = c.series,\n          m = c.visiblePlotOnly && k || f;\n        var q = c.inverted ? a : b;\n        a = c.inverted ? b : a;\n        b = {\n          x: q,\n          y: a,\n          isInsidePlot: !0,\n          options: c\n        };\n        if (!c.ignoreX) {\n          const a = l && (d && !this.polar ? l.yAxis : l.xAxis) || {\n            pos: e,\n            len: Infinity\n          };\n          q = c.paneCoordinates ? a.pos + q : e + q;\n          q >= Math.max(h + e, a.pos) && q <= Math.min(h + e + m.width, a.pos + a.len) || (b.isInsidePlot = !1);\n        }\n        !c.ignoreY && b.isInsidePlot && (h = !d && c.axis && !c.axis.isXAxis && c.axis || l && (d ? l.xAxis : l.yAxis) || {\n          pos: g,\n          len: Infinity\n        }, c = c.paneCoordinates ? h.pos + a : g + a, c >= Math.max(n + g, h.pos) && c <= Math.min(n + g + m.height, h.pos + h.len) || (b.isInsidePlot = !1));\n        A(this, \"afterIsInsidePlot\", b);\n        return b.isInsidePlot;\n      }\n      redraw(b) {\n        A(this, \"beforeRedraw\");\n        const a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n          c = this.series,\n          d = this.pointer,\n          f = this.legend,\n          e = this.userOptions.legend,\n          k = this.renderer,\n          h = k.isHidden(),\n          n = [];\n        let l,\n          m,\n          q = this.isDirtyBox,\n          p = this.isDirtyLegend,\n          r;\n        k.rootFontSize = k.boxWrapper.getStyle(\"font-size\");\n        this.setResponsive && this.setResponsive(!1);\n        g(this.hasRendered ? b : !1, this);\n        h && this.temporaryDisplay();\n        this.layOutTitles(!1);\n        for (b = c.length; b--;) if (r = c[b], r.options.stacking || r.options.centerInCategory) if (m = !0, r.isDirty) {\n          l = !0;\n          break;\n        }\n        if (l) for (b = c.length; b--;) r = c[b], r.options.stacking && (r.isDirty = !0);\n        c.forEach(function (b) {\n          b.isDirty && (\"point\" === b.options.legendType ? (\"function\" === typeof b.updateTotals && b.updateTotals(), p = !0) : e && (e.labelFormatter || e.labelFormat) && (p = !0));\n          b.isDirtyData && A(b, \"updatedData\");\n        });\n        p && f && f.options.enabled && (f.render(), this.isDirtyLegend = !1);\n        m && this.getStacks();\n        a.forEach(function (b) {\n          b.updateNames();\n          b.setScale();\n        });\n        this.getMargins();\n        a.forEach(function (b) {\n          b.isDirty && (q = !0);\n        });\n        a.forEach(function (b) {\n          const a = b.min + \",\" + b.max;\n          b.extKey !== a && (b.extKey = a, n.push(function () {\n            A(b, \"afterSetExtremes\", V(b.eventArgs, b.getExtremes()));\n            delete b.eventArgs;\n          }));\n          (q || m) && b.redraw();\n        });\n        q && this.drawChartBox();\n        A(this, \"predraw\");\n        c.forEach(function (b) {\n          (q || b.isDirty) && b.visible && b.redraw();\n          b.isDirtyData = !1;\n        });\n        d && d.reset(!0);\n        k.draw();\n        A(this, \"redraw\");\n        A(this, \"render\");\n        h && this.temporaryDisplay(!0);\n        n.forEach(function (b) {\n          b.call();\n        });\n      }\n      get(b) {\n        function a(a) {\n          return a.id === b || a.options && a.options.id === b;\n        }\n        const c = this.series;\n        let d = Y(this.axes, a) || Y(this.series, a);\n        for (let b = 0; !d && b < c.length; b++) d = Y(c[b].points || [], a);\n        return d;\n      }\n      getAxes() {\n        const b = this.options;\n        A(this, \"getAxes\");\n        for (const a of [\"xAxis\", \"yAxis\"]) {\n          const c = b[a] = fa(b[a] || {});\n          for (const b of c) new y(this, b, a);\n        }\n        A(this, \"afterGetAxes\");\n      }\n      getSelectedPoints() {\n        return this.series.reduce((b, a) => {\n          a.getPointsCollection().forEach(a => {\n            S(a.selectedStaging, a.selected) && b.push(a);\n          });\n          return b;\n        }, []);\n      }\n      getSelectedSeries() {\n        return this.series.filter(function (b) {\n          return b.selected;\n        });\n      }\n      setTitle(b, a, c) {\n        this.applyDescription(\"title\", b);\n        this.applyDescription(\"subtitle\", a);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(c);\n      }\n      applyDescription(b, a) {\n        const c = this,\n          d = this.options[b] = N(this.options[b], a);\n        let f = this[b];\n        f && a && (this[b] = f = f.destroy());\n        d && !f && (f = this.renderer.text(d.text, 0, 0, d.useHTML).attr({\n          align: d.align,\n          \"class\": \"highcharts-\" + b,\n          zIndex: d.zIndex || 4\n        }).add(), f.update = function (a, d) {\n          c.applyDescription(b, a);\n          c.layOutTitles(d);\n        }, this.styledMode || f.css(V(\"title\" === b ? {\n          fontSize: this.options.isStock ? \"1em\" : \"1.2em\"\n        } : {}, d.style)), this[b] = f);\n      }\n      layOutTitles(b = !0) {\n        const a = [0, 0, 0],\n          c = this.renderer,\n          d = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (b) {\n          const f = this[b],\n            e = this.options[b],\n            g = e.verticalAlign || \"top\";\n          b = \"title\" === b ? \"top\" === g ? -3 : 0 : \"top\" === g ? a[0] + 2 : 0;\n          if (f) {\n            f.css({\n              width: (e.width || d.width + (e.widthAdjust || 0)) + \"px\"\n            });\n            const k = c.fontMetrics(f).b,\n              h = Math.round(f.getBBox(e.useHTML).height);\n            f.align(V({\n              y: \"bottom\" === g ? k : b + k,\n              height: h\n            }, e), !1, \"spacingBox\");\n            e.floating || (\"top\" === g ? a[0] = Math.ceil(a[0] + h) : \"bottom\" === g && (a[2] = Math.ceil(a[2] + h)));\n          }\n        }, this);\n        a[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (a[0] += this.options.title.margin);\n        a[2] && \"bottom\" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);\n        const f = !this.titleOffset || this.titleOffset.join(\",\") !== a.join(\",\");\n        this.titleOffset = a;\n        A(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && f && (this.isDirtyBox = this.isDirtyLegend = f, this.hasRendered && b && this.isDirtyBox && this.redraw());\n      }\n      getContainerBox() {\n        return {\n          width: M(this.renderTo, \"width\", !0) || 0,\n          height: M(this.renderTo, \"height\", !0) || 0\n        };\n      }\n      getChartSize() {\n        var b = this.options.chart;\n        const a = b.width;\n        b = b.height;\n        const c = this.getContainerBox();\n        this.chartWidth = Math.max(0, a || c.width || 600);\n        this.chartHeight = Math.max(0, ha(b, this.chartWidth) || (1 < c.height ? c.height : 400));\n        this.containerBox = c;\n      }\n      temporaryDisplay(b) {\n        let a = this.renderTo;\n        if (b) for (; a && a.style;) a.hcOrigStyle && (P(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (k.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {\n          k.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, k.body.appendChild(a));\n          if (\"none\" === M(a, \"display\", !1) || a.hcOricDetached) a.hcOrigStyle = {\n            display: a.style.display,\n            height: a.style.height,\n            overflow: a.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, a !== this.renderTo && (b.height = 0), P(a, b), a.offsetWidth || a.style.setProperty(\"display\", \"block\", \"important\");\n          a = a.parentNode;\n          if (a === k.body) break;\n        }\n      }\n      setClassName(b) {\n        this.container.className = \"highcharts-container \" + (b || \"\");\n      }\n      getContainer() {\n        const b = this.options,\n          a = b.chart;\n        var f = ca();\n        let e,\n          h = this.renderTo;\n        h || (this.renderTo = h = a.renderTo);\n        J(h) && (this.renderTo = h = k.getElementById(h));\n        h || Z(13, !0, this);\n        var l = W(c(h, \"data-highcharts-chart\"));\n        ba(l) && d[l] && d[l].hasRendered && d[l].destroy();\n        c(h, \"data-highcharts-chart\", this.index);\n        h.innerHTML = t.emptyHTML;\n        a.skipClone || h.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        l = this.chartWidth;\n        const m = this.chartHeight;\n        P(h, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (e = V({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: l + \"px\",\n          height: m + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\",\n          \"touch-action\": \"manipulation\",\n          outline: \"none\"\n        }, a.style || {}));\n        this.container = f = n(\"div\", {\n          id: f\n        }, e, h);\n        this._cursor = f.style.cursor;\n        this.renderer = new (a.renderer || !q ? H.getRendererType(a.renderer) : v)(f, l, m, void 0, a.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);\n        this.containerBox = this.getContainerBox();\n        g(void 0, this);\n        this.setClassName(a.className);\n        if (this.styledMode) for (const a in b.defs) this.renderer.definition(b.defs[a]);else this.renderer.setStyle(a.style);\n        this.renderer.chartIndex = this.index;\n        A(this, \"afterGetContainer\");\n      }\n      getMargins(b) {\n        const {\n          spacing: a,\n          margin: c,\n          titleOffset: d\n        } = this;\n        this.resetMargins();\n        d[0] && !D(c[0]) && (this.plotTop = Math.max(this.plotTop, d[0] + a[0]));\n        d[2] && !D(c[2]) && (this.marginBottom = Math.max(this.marginBottom, d[2] + a[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(c, a);\n        A(this, \"getMargins\");\n        b || this.getAxisMargins();\n      }\n      getAxisMargins() {\n        const b = this,\n          a = b.axisOffset = [0, 0, 0, 0],\n          c = b.colorAxis,\n          d = b.margin,\n          f = function (b) {\n            b.forEach(function (b) {\n              b.visible && b.getOffset();\n            });\n          };\n        b.hasCartesianSeries ? f(b.axes) : c && c.length && f(c);\n        r.forEach(function (c, f) {\n          D(d[f]) || (b[c] += a[f]);\n        });\n        b.setChartSize();\n      }\n      getOptions() {\n        return K(this.userOptions, e);\n      }\n      reflow(b) {\n        const a = this;\n        var c = a.options.chart;\n        c = D(c.width) && D(c.height);\n        const d = a.containerBox,\n          f = a.getContainerBox();\n        delete a.pointer.chartPosition;\n        if (!c && !a.isPrinting && d && f.width) {\n          if (f.width !== d.width || f.height !== d.height) p.clearTimeout(a.reflowTimeout), a.reflowTimeout = ka(function () {\n            a.container && a.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          a.containerBox = f;\n        }\n      }\n      setReflow() {\n        const b = this;\n        var a = a => {\n          var c;\n          (null === (c = b.options) || void 0 === c ? 0 : c.chart.reflow) && b.hasLoaded && b.reflow(a);\n        };\n        \"function\" === typeof ResizeObserver ? new ResizeObserver(a).observe(b.renderTo) : (a = f(G, \"resize\", a), f(this, \"destroy\", a));\n      }\n      setSize(b, a, c) {\n        const d = this,\n          f = d.renderer;\n        d.isResizing += 1;\n        g(c, d);\n        c = f.globalAnimation;\n        d.oldChartHeight = d.chartHeight;\n        d.oldChartWidth = d.chartWidth;\n        \"undefined\" !== typeof b && (d.options.chart.width = b);\n        \"undefined\" !== typeof a && (d.options.chart.height = a);\n        d.getChartSize();\n        d.styledMode || (c ? m : P)(d.container, {\n          width: d.chartWidth + \"px\",\n          height: d.chartHeight + \"px\"\n        }, c);\n        d.setChartSize(!0);\n        f.setSize(d.chartWidth, d.chartHeight, c);\n        d.axes.forEach(function (b) {\n          b.isDirty = !0;\n          b.setScale();\n        });\n        d.isDirtyLegend = !0;\n        d.isDirtyBox = !0;\n        d.layOutTitles();\n        d.getMargins();\n        d.redraw(c);\n        d.oldChartHeight = null;\n        A(d, \"resize\");\n        ka(function () {\n          d && A(d, \"endResize\", null, function () {\n            --d.isResizing;\n          });\n        }, h(c).duration);\n      }\n      setChartSize(b) {\n        var a = this.inverted;\n        const c = this.renderer;\n        var d = this.chartWidth,\n          f = this.chartHeight;\n        const e = this.options.chart,\n          g = this.spacing,\n          k = this.clipOffset;\n        let h, n, l, m;\n        this.plotLeft = h = Math.round(this.plotLeft);\n        this.plotTop = n = Math.round(this.plotTop);\n        this.plotWidth = l = Math.max(0, Math.round(d - h - this.marginRight));\n        this.plotHeight = m = Math.max(0, Math.round(f - n - this.marginBottom));\n        this.plotSizeX = a ? m : l;\n        this.plotSizeY = a ? l : m;\n        this.plotBorderWidth = e.plotBorderWidth || 0;\n        this.spacingBox = c.spacingBox = {\n          x: g[3],\n          y: g[0],\n          width: d - g[3] - g[1],\n          height: f - g[0] - g[2]\n        };\n        this.plotBox = c.plotBox = {\n          x: h,\n          y: n,\n          width: l,\n          height: m\n        };\n        a = 2 * Math.floor(this.plotBorderWidth / 2);\n        d = Math.ceil(Math.max(a, k[3]) / 2);\n        f = Math.ceil(Math.max(a, k[0]) / 2);\n        this.clipBox = {\n          x: d,\n          y: f,\n          width: Math.floor(this.plotSizeX - Math.max(a, k[1]) / 2 - d),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, k[2]) / 2 - f))\n        };\n        b || (this.axes.forEach(function (b) {\n          b.setAxisSize();\n          b.setAxisTranslation();\n        }), c.alignElements());\n        A(this, \"afterSetChartSize\", {\n          skipAxes: b\n        });\n      }\n      resetMargins() {\n        A(this, \"resetMargins\");\n        const b = this,\n          a = b.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (c) {\n          const d = a[c],\n            f = aa(d) ? d : [d, d, d, d];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (d, e) {\n            b[c][e] = S(a[c + d], f[e]);\n          });\n        });\n        r.forEach(function (a, c) {\n          b[a] = S(b.margin[c], b.spacing[c]);\n        });\n        b.axisOffset = [0, 0, 0, 0];\n        b.clipOffset = [0, 0, 0, 0];\n      }\n      drawChartBox() {\n        const b = this.options.chart,\n          a = this.renderer,\n          c = this.chartWidth,\n          d = this.chartHeight,\n          f = this.styledMode,\n          e = this.plotBGImage;\n        var g = b.backgroundColor;\n        const k = b.plotBackgroundColor,\n          h = b.plotBackgroundImage,\n          n = this.plotLeft,\n          l = this.plotTop,\n          m = this.plotWidth,\n          q = this.plotHeight,\n          p = this.plotBox,\n          r = this.clipRect,\n          t = this.clipBox;\n        let w = this.chartBackground,\n          v = this.plotBackground,\n          u = this.plotBorder,\n          x,\n          D,\n          E = \"animate\";\n        w || (this.chartBackground = w = a.rect().addClass(\"highcharts-background\").add(), E = \"attr\");\n        if (f) x = D = w.strokeWidth();else {\n          x = b.borderWidth || 0;\n          D = x + (b.shadow ? 8 : 0);\n          g = {\n            fill: g || \"none\"\n          };\n          if (x || w[\"stroke-width\"]) g.stroke = b.borderColor, g[\"stroke-width\"] = x;\n          w.attr(g).shadow(b.shadow);\n        }\n        w[E]({\n          x: D / 2,\n          y: D / 2,\n          width: c - D - x % 2,\n          height: d - D - x % 2,\n          r: b.borderRadius\n        });\n        E = \"animate\";\n        v || (E = \"attr\", this.plotBackground = v = a.rect().addClass(\"highcharts-plot-background\").add());\n        v[E](p);\n        f || (v.attr({\n          fill: k || \"none\"\n        }).shadow(b.plotShadow), h && (e ? (h !== e.attr(\"href\") && e.attr(\"href\", h), e.animate(p)) : this.plotBGImage = a.image(h, n, l, m, q).add()));\n        r ? r.animate({\n          width: t.width,\n          height: t.height\n        }) : this.clipRect = a.clipRect(t);\n        E = \"animate\";\n        u || (E = \"attr\", this.plotBorder = u = a.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        f || u.attr({\n          stroke: b.plotBorderColor,\n          \"stroke-width\": b.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        u[E](u.crisp({\n          x: n,\n          y: l,\n          width: m,\n          height: q\n        }, -u.strokeWidth()));\n        this.isDirtyBox = !1;\n        A(this, \"afterDrawChartBox\");\n      }\n      propFromSeries() {\n        const a = this,\n          c = a.options.chart,\n          d = a.options.series;\n        let f, e, g;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (k) {\n          e = b[c.type];\n          g = c[k] || e && e.prototype[k];\n          for (f = d && d.length; !g && f--;) (e = b[d[f].type]) && e.prototype[k] && (g = !0);\n          a[k] = g;\n        });\n      }\n      linkSeries(b) {\n        const a = this,\n          c = a.series;\n        c.forEach(function (b) {\n          b.linkedSeries.length = 0;\n        });\n        c.forEach(function (b) {\n          let c = b.options.linkedTo;\n          J(c) && (c = \":previous\" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, c.enabledDataSorting && b.setDataSortingOptions(), b.visible = S(b.options.visible, c.options.visible, b.visible));\n        });\n        A(this, \"afterLinkSeries\", {\n          isUpdating: b\n        });\n      }\n      renderSeries() {\n        this.series.forEach(function (b) {\n          b.translate();\n          b.render();\n        });\n      }\n      render() {\n        const b = this.axes,\n          a = this.colorAxis,\n          c = this.renderer,\n          d = function (b) {\n            b.forEach(function (b) {\n              b.visible && b.render();\n            });\n          };\n        let f = 0;\n        this.setTitle();\n        A(this, \"beforeMargins\");\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        const e = this.plotWidth;\n        b.some(function (b) {\n          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return f = 21, !0;\n        });\n        const g = this.plotHeight = Math.max(this.plotHeight - f, 0);\n        b.forEach(function (b) {\n          b.setScale();\n        });\n        this.getAxisMargins();\n        const k = 1.1 < e / this.plotWidth,\n          h = 1.05 < g / this.plotHeight;\n        if (k || h) b.forEach(function (b) {\n          (b.horiz && k || !b.horiz && h) && b.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? d(b) : a && a.length && d(a);\n        this.seriesGroup || (this.seriesGroup = c.g(\"series-group\").attr({\n          zIndex: 3\n        }).shadow(this.options.chart.seriesGroupShadow).add());\n        this.renderSeries();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      }\n      addCredits(b) {\n        const a = this,\n          c = N(!0, this.options.credits, b);\n        c.enabled && !this.credits && (this.credits = this.renderer.text(c.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          c.href && (G.location.href = c.href);\n        }).attr({\n          align: c.position.align,\n          zIndex: 8\n        }), a.styledMode || this.credits.css(c.style), this.credits.add().align(c.position), this.credits.update = function (b) {\n          a.credits = a.credits.destroy();\n          a.addCredits(b);\n        });\n      }\n      destroy() {\n        const b = this,\n          a = b.axes,\n          c = b.series,\n          f = b.container,\n          e = f && f.parentNode;\n        let g;\n        A(b, \"destroy\");\n        b.renderer.forExport ? T(d, b) : d[b.index] = void 0;\n        z.chartCount--;\n        b.renderTo.removeAttribute(\"data-highcharts-chart\");\n        da(b);\n        for (g = a.length; g--;) a[g] = a[g].destroy();\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n        for (g = c.length; g--;) c[g] = c[g].destroy();\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (a) {\n          const c = b[a];\n          c && c.destroy && (b[a] = c.destroy());\n        });\n        f && (f.innerHTML = t.emptyHTML, da(f), e && X(f));\n        O(b, function (a, c) {\n          delete b[c];\n        });\n      }\n      firstRender() {\n        const b = this,\n          a = b.options;\n        b.getContainer();\n        b.resetMargins();\n        b.setChartSize();\n        b.propFromSeries();\n        b.getAxes();\n        const c = ia(a.series) ? a.series : [];\n        a.series = [];\n        c.forEach(function (a) {\n          b.initSeries(a);\n        });\n        b.linkSeries();\n        b.setSeriesData();\n        A(b, \"beforeRender\");\n        b.render();\n        b.pointer.getChartPosition();\n        if (!b.renderer.imgCount && !b.hasLoaded) b.onload();\n        b.temporaryDisplay(!0);\n      }\n      onload() {\n        this.callbacks.concat([this.callback]).forEach(function (b) {\n          b && \"undefined\" !== typeof this.index && b.apply(this, [this]);\n        }, this);\n        A(this, \"load\");\n        A(this, \"render\");\n        D(this.index) && this.setReflow();\n        this.warnIfA11yModuleNotLoaded();\n        this.hasLoaded = !0;\n      }\n      warnIfA11yModuleNotLoaded() {\n        const {\n          options: b,\n          title: a\n        } = this;\n        b && !this.accessibility && (this.renderer.boxWrapper.attr({\n          role: \"img\",\n          \"aria-label\": (a && a.element.textContent || \"\").replace(/</g, \"&lt;\")\n        }), b.accessibility && !1 === b.accessibility.enabled || Z('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n      }\n      addSeries(b, a, c) {\n        const d = this;\n        let f;\n        b && (a = S(a, !0), A(d, \"addSeries\", {\n          options: b\n        }, function () {\n          f = d.initSeries(b);\n          d.isDirtyLegend = !0;\n          d.linkSeries();\n          f.enabledDataSorting && f.setData(b.data, !1);\n          A(d, \"afterAddSeries\", {\n            series: f\n          });\n          a && d.redraw(c);\n        }));\n        return f;\n      }\n      addAxis(b, a, c, d) {\n        return this.createAxis(a ? \"xAxis\" : \"yAxis\", {\n          axis: b,\n          redraw: c,\n          animation: d\n        });\n      }\n      addColorAxis(b, a, c) {\n        return this.createAxis(\"colorAxis\", {\n          axis: b,\n          redraw: a,\n          animation: c\n        });\n      }\n      createAxis(b, a) {\n        b = new y(this, a.axis, b);\n        S(a.redraw, !0) && this.redraw(a.animation);\n        return b;\n      }\n      showLoading(b) {\n        const a = this,\n          c = a.options,\n          d = c.loading,\n          e = function () {\n            g && P(g, {\n              left: a.plotLeft + \"px\",\n              top: a.plotTop + \"px\",\n              width: a.plotWidth + \"px\",\n              height: a.plotHeight + \"px\"\n            });\n          };\n        let g = a.loadingDiv,\n          k = a.loadingSpan;\n        g || (a.loadingDiv = g = n(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, a.container));\n        k || (a.loadingSpan = k = n(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, g), f(a, \"redraw\", e));\n        g.className = \"highcharts-loading\";\n        t.setElementHTML(k, S(b, c.lang.loading, \"\"));\n        a.styledMode || (P(g, V(d.style, {\n          zIndex: 10\n        })), P(k, d.labelStyle), a.loadingShown || (P(g, {\n          opacity: 0,\n          display: \"\"\n        }), m(g, {\n          opacity: d.style.opacity || .5\n        }, {\n          duration: d.showDuration || 0\n        })));\n        a.loadingShown = !0;\n        e();\n      }\n      hideLoading() {\n        const b = this.options,\n          a = this.loadingDiv;\n        a && (a.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || m(a, {\n          opacity: 0\n        }, {\n          duration: b.loading.hideDuration || 100,\n          complete: function () {\n            P(a, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      }\n      update(b, a, c, d) {\n        const f = this,\n          e = {\n            credits: \"addCredits\",\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          },\n          g = b.isResponsiveOptions,\n          k = [];\n        let h, n;\n        A(f, \"update\", {\n          options: b\n        });\n        g || f.setResponsive(!1, !0);\n        b = K(b, f.options);\n        f.userOptions = N(f.userOptions, b);\n        var m = b.chart;\n        if (m) {\n          N(!0, f.options.chart, m);\n          this.setZoomOptions();\n          \"className\" in m && f.setClassName(m.className);\n          if (\"inverted\" in m || \"polar\" in m || \"type\" in m) {\n            f.propFromSeries();\n            var q = !0;\n          }\n          \"alignTicks\" in m && (q = !0);\n          \"events\" in m && F(this, m);\n          O(m, function (b, a) {\n            -1 !== f.propsRequireUpdateSeries.indexOf(\"chart.\" + a) && (h = !0);\n            -1 !== f.propsRequireDirtyBox.indexOf(a) && (f.isDirtyBox = !0);\n            -1 !== f.propsRequireReflow.indexOf(a) && (g ? f.isDirtyBox = !0 : n = !0);\n          });\n          !f.styledMode && m.style && f.renderer.setStyle(f.options.chart.style || {});\n        }\n        !f.styledMode && b.colors && (this.options.colors = b.colors);\n        b.time && (this.time === w && (this.time = new l(b.time)), N(!0, f.options.time, b.time));\n        O(b, function (a, c) {\n          if (f[c] && \"function\" === typeof f[c].update) f[c].update(a, !1);else if (\"function\" === typeof f[e[c]]) f[e[c]](a);else \"colors\" !== c && -1 === f.collectionsWithUpdate.indexOf(c) && N(!0, f.options[c], b[c]);\n          \"chart\" !== c && -1 !== f.propsRequireUpdateSeries.indexOf(c) && (h = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (a) {\n          b[a] && (fa(b[a]).forEach(function (b, d) {\n            const e = D(b.id);\n            let g;\n            e && (g = f.get(b.id));\n            !g && f[a] && (g = f[a][S(b.index, d)]) && (e && D(g.options.id) || g.options.isInternal) && (g = void 0);\n            g && g.coll === a && (g.update(b, !1), c && (g.touched = !0));\n            !g && c && f.collectionsWithInit[a] && (f.collectionsWithInit[a][0].apply(f, [b].concat(f.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);\n          }), c && f[a].forEach(function (b) {\n            b.touched || b.options.isInternal ? delete b.touched : k.push(b);\n          }));\n        });\n        k.forEach(function (b) {\n          b.chart && b.remove && b.remove(!1);\n        });\n        q && f.axes.forEach(function (b) {\n          b.update({}, !1);\n        });\n        h && f.getSeriesOrderByLinks().forEach(function (b) {\n          b.chart && b.update({}, !1);\n        }, this);\n        q = m && m.width;\n        m = m && (J(m.height) ? ha(m.height, q || f.chartWidth) : m.height);\n        n || ba(q) && q !== f.chartWidth || ba(m) && m !== f.chartHeight ? f.setSize(q, m, d) : S(a, !0) && f.redraw(d);\n        A(f, \"afterUpdate\", {\n          options: b,\n          redraw: a,\n          animation: d\n        });\n      }\n      setSubtitle(b, a) {\n        this.applyDescription(\"subtitle\", b);\n        this.layOutTitles(a);\n      }\n      setCaption(b, a) {\n        this.applyDescription(\"caption\", b);\n        this.layOutTitles(a);\n      }\n      showResetZoom() {\n        function b() {\n          a.zoomOut();\n        }\n        const a = this,\n          c = e.lang,\n          d = a.zooming.resetButton,\n          f = d.theme,\n          g = \"chart\" === d.relativeTo || \"spacingBox\" === d.relativeTo ? null : \"scrollablePlotBox\";\n        A(this, \"beforeShowResetZoom\", null, function () {\n          a.resetZoomButton = a.renderer.button(c.resetZoom, null, null, b, f).attr({\n            align: d.position.align,\n            title: c.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(d.position, !1, g);\n        });\n        A(this, \"afterShowResetZoom\");\n      }\n      zoomOut() {\n        A(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      }\n      zoom(b) {\n        const a = this,\n          c = a.pointer;\n        let d = !1,\n          f;\n        !b || b.resetSelection ? (a.axes.forEach(function (b) {\n          f = b.zoom();\n        }), c.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {\n          const e = b.axis;\n          if (c[e.isXAxis ? \"zoomX\" : \"zoomY\"] && D(c.mouseDownX) && D(c.mouseDownY) && a.isInsidePlot(c.mouseDownX - a.plotLeft, c.mouseDownY - a.plotTop, {\n            axis: e\n          }) || !D(a.inverted ? c.mouseDownX : c.mouseDownY)) f = e.zoom(b.min, b.max), e.displayBtn && (d = !0);\n        });\n        const e = a.resetZoomButton;\n        d && !e ? a.showResetZoom() : !d && aa(e) && (a.resetZoomButton = e.destroy());\n        f && a.redraw(S(a.options.chart.animation, b && b.animation, 100 > a.pointCount));\n      }\n      pan(b, a) {\n        const c = this,\n          d = c.hoverPoints;\n        a = \"object\" === typeof a ? a : {\n          enabled: a,\n          type: \"x\"\n        };\n        const f = c.options.chart;\n        f && f.panning && (f.panning = a);\n        const e = a.type;\n        let g;\n        A(this, \"pan\", {\n          originalEvent: b\n        }, function () {\n          d && d.forEach(function (b) {\n            b.setState();\n          });\n          let a = c.xAxis;\n          \"xy\" === e ? a = a.concat(c.yAxis) : \"y\" === e && (a = c.yAxis);\n          const f = {};\n          a.forEach(function (a) {\n            if (a.options.panningEnabled && !a.options.isInternal) {\n              var d = a.horiz,\n                k = b[d ? \"chartX\" : \"chartY\"];\n              d = d ? \"mouseDownX\" : \"mouseDownY\";\n              var h = c[d],\n                n = a.minPointOffset || 0,\n                l = a.reversed && !c.inverted || !a.reversed && c.inverted ? -1 : 1,\n                m = a.getExtremes(),\n                q = a.toValue(h - k, !0) + n * l,\n                p = a.toValue(h + a.len - k, !0) - (n * l || a.isXAxis && a.pointRangePadding || 0),\n                r = p < q;\n              l = a.hasVerticalPanning();\n              h = r ? p : q;\n              q = r ? q : p;\n              var t = a.panningState;\n              !l || a.isXAxis || t && !t.isDirty || a.series.forEach(function (b) {\n                var a = b.getProcessedData(!0);\n                a = b.getExtremes(a.yData, !0);\n                t || (t = {\n                  startMin: Number.MAX_VALUE,\n                  startMax: -Number.MAX_VALUE\n                });\n                ba(a.dataMin) && ba(a.dataMax) && (t.startMin = Math.min(S(b.options.threshold, Infinity), a.dataMin, t.startMin), t.startMax = Math.max(S(b.options.threshold, -Infinity), a.dataMax, t.startMax));\n              });\n              l = Math.min(S(t && t.startMin, m.dataMin), n ? m.min : a.toValue(a.toPixels(m.min) - a.minPixelPadding));\n              p = Math.max(S(t && t.startMax, m.dataMax), n ? m.max : a.toValue(a.toPixels(m.max) + a.minPixelPadding));\n              a.panningState = t;\n              a.isOrdinal || (n = l - h, 0 < n && (q += n, h = l), n = q - p, 0 < n && (q = p, h -= n), a.series.length && h !== m.min && q !== m.max && h >= l && q <= p && (a.setExtremes(h, q, !1, !1, {\n                trigger: \"pan\"\n              }), !c.resetZoomButton && h !== l && q !== p && e.match(\"y\") && (c.showResetZoom(), a.displayBtn = !1), g = !0), f[d] = k);\n            }\n          });\n          O(f, (b, a) => {\n            c[a] = b;\n          });\n          g && c.redraw(!1);\n          P(c.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    }\n    V(ea.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [ea.prototype.addAxis, [!0]],\n        yAxis: [ea.prototype.addAxis, [!1]],\n        series: [ea.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \")\n    });\n    \"\";\n    return ea;\n  });\n  M(a, \"Extensions/ScrollablePlotArea.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z) {\n    const {\n        stop: x\n      } = a,\n      {\n        addEvent: B,\n        createElement: u,\n        defined: v,\n        merge: l,\n        pick: p\n      } = z;\n    B(I, \"afterSetChartSize\", function (a) {\n      var m = this.options.chart.scrollablePlotArea,\n        h = m && m.minWidth;\n      m = m && m.minHeight;\n      let g;\n      if (!this.renderer.forExport) {\n        if (h) {\n          if (this.scrollablePixelsX = h = Math.max(0, h - this.chartWidth)) this.scrollablePlotBox = this.renderer.scrollablePlotBox = l(this.plotBox), this.plotBox.width = this.plotWidth += h, this.inverted ? this.clipBox.height += h : this.clipBox.width += h, g = {\n            1: {\n              name: \"right\",\n              value: h\n            }\n          };\n        } else m && (this.scrollablePixelsY = h = Math.max(0, m - this.chartHeight), v(h) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = l(this.plotBox), this.plotBox.height = this.plotHeight += h, this.inverted ? this.clipBox.width += h : this.clipBox.height += h, g = {\n          2: {\n            name: \"bottom\",\n            value: h\n          }\n        }));\n        g && !a.skipAxes && this.axes.forEach(function (a) {\n          g[a.side] ? a.getPlotLinePath = function () {\n            let e = g[a.side].name,\n              h = this[e],\n              l;\n            this[e] = h - g[a.side].value;\n            l = y.prototype.getPlotLinePath.apply(this, arguments);\n            this[e] = h;\n            return l;\n          } : (a.setAxisSize(), a.setAxisTranslation());\n        });\n      }\n    });\n    B(I, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n    I.prototype.setUpScrolling = function () {\n      const a = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (a.overflowX = \"auto\");\n      this.scrollablePixelsY && (a.overflowY = \"auto\");\n      this.scrollingParent = u(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo);\n      this.scrollingContainer = u(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, a, this.scrollingParent);\n      let l;\n      B(this.scrollingContainer, \"scroll\", () => {\n        this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (l = this.hoverPoint), this.pointer.runPointActions(void 0, l, !0));\n      });\n      this.innerContainer = u(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n    I.prototype.moveFixedElements = function () {\n      let a = this.container,\n        l = this.fixedRenderer,\n        h = \".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n        g;\n      this.scrollablePixelsX && !this.inverted ? g = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? g = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? g = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (g = \".highcharts-yaxis\");\n      g && h.push(`${g}:not(.highcharts-radial-axis)`, `${g}-labels:not(.highcharts-radial-axis-labels)`);\n      h.forEach(function (e) {\n        [].forEach.call(a.querySelectorAll(e), function (a) {\n          (a.namespaceURI === l.SVG_NS ? l.box : l.box.parentNode).appendChild(a);\n          a.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n    I.prototype.applyFixed = function () {\n      var a = !this.fixedDiv,\n        l = this.options.chart,\n        h = l.scrollablePlotArea,\n        g = C.getRendererType();\n      a ? (this.fixedDiv = u(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: (l.style && l.style.zIndex || 0) + 2,\n        top: 0\n      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = l = new g(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = l.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": p(h.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), B(this, \"afterShowResetZoom\", this.moveFixedElements), B(this, \"afterApplyDrilldown\", this.moveFixedElements), B(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();\n      l = this.chartWidth + (this.scrollablePixelsX || 0);\n      g = this.chartHeight + (this.scrollablePixelsY || 0);\n      x(this.container);\n      this.container.style.width = l + \"px\";\n      this.container.style.height = g + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: l,\n        height: g,\n        viewBox: [0, 0, l, g].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: l,\n        height: g\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      a && (h.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * h.scrollPositionX), h.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * h.scrollPositionY));\n      g = this.axisOffset;\n      a = this.plotTop - g[0] - 1;\n      h = this.plotLeft - g[3] - 1;\n      l = this.plotTop + this.plotHeight + g[2] + 1;\n      g = this.plotLeft + this.plotWidth + g[1] + 1;\n      let e = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n        w = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      a = this.scrollablePixelsX ? [[\"M\", 0, a], [\"L\", this.plotLeft - 1, a], [\"L\", this.plotLeft - 1, l], [\"L\", 0, l], [\"Z\"], [\"M\", e, a], [\"L\", this.chartWidth, a], [\"L\", this.chartWidth, l], [\"L\", e, l], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", h, 0], [\"L\", h, this.plotTop - 1], [\"L\", g, this.plotTop - 1], [\"L\", g, 0], [\"Z\"], [\"M\", h, w], [\"L\", h, this.chartHeight], [\"L\", g, this.chartHeight], [\"L\", g, w], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: a\n      });\n    };\n    B(y, \"afterInit\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    B(L, \"show\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    \"\";\n  });\n  M(a, \"Core/Axis/Stacking/StackItem.js\", [a[\"Core/Templating.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        format: x\n      } = a,\n      {\n        series: C\n      } = y,\n      {\n        destroyObjectProperties: z,\n        fireEvent: H,\n        isNumber: B,\n        pick: u\n      } = I;\n    class v {\n      constructor(a, p, t, m, h) {\n        const g = a.chart.inverted,\n          e = a.reversed;\n        this.axis = a;\n        a = this.isNegative = !!t !== !!e;\n        this.options = p = p || {};\n        this.x = m;\n        this.cumulative = this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = h;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: p.align || (g ? a ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: p.verticalAlign || (g ? \"middle\" : a ? \"bottom\" : \"top\"),\n          y: p.y,\n          x: p.x\n        };\n        this.textAlign = p.textAlign || (g ? a ? \"right\" : \"left\" : \"center\");\n      }\n      destroy() {\n        z(this, this.axis);\n      }\n      render(a) {\n        const l = this.axis.chart,\n          t = this.options;\n        var m = t.format;\n        m = m ? x(m, this, l) : t.formatter.call(this);\n        this.label ? this.label.attr({\n          text: m,\n          visibility: \"hidden\"\n        }) : (this.label = l.renderer.label(m, null, void 0, t.shape, void 0, void 0, t.useHTML, !1, \"stack-labels\"), m = {\n          r: t.borderRadius || 0,\n          text: m,\n          padding: u(t.padding, 5),\n          visibility: \"hidden\"\n        }, l.styledMode || (m.fill = t.backgroundColor, m.stroke = t.borderColor, m[\"stroke-width\"] = t.borderWidth, this.label.css(t.style || {})), this.label.attr(m), this.label.added || this.label.add(a));\n        this.label.labelrank = l.plotSizeY;\n        H(this, \"afterRender\");\n      }\n      setOffset(a, p, t, m, h, g) {\n        const {\n            alignOptions: e,\n            axis: l,\n            label: v,\n            options: x,\n            textAlign: d\n          } = this,\n          k = l.chart;\n        t = this.getStackBox({\n          xOffset: a,\n          width: p,\n          boxBottom: t,\n          boxTop: m,\n          defaultX: h,\n          xAxis: g\n        });\n        var {\n          verticalAlign: r\n        } = e;\n        if (v && t) {\n          m = v.getBBox();\n          h = v.padding;\n          g = \"justify\" === u(x.overflow, \"justify\");\n          e.x = x.x || 0;\n          e.y = x.y || 0;\n          const {\n            x: a,\n            y: p\n          } = this.adjustStackPosition({\n            labelBox: m,\n            verticalAlign: r,\n            textAlign: d\n          });\n          t.x -= a;\n          t.y -= p;\n          v.align(e, !1, t);\n          (r = k.isInsidePlot(v.alignAttr.x + e.x + a, v.alignAttr.y + e.y + p)) || (g = !1);\n          g && C.prototype.justifyDataLabel.call(l, v, e, v.alignAttr, m, t);\n          v.attr({\n            x: v.alignAttr.x,\n            y: v.alignAttr.y,\n            rotation: x.rotation,\n            rotationOriginX: m.width / 2,\n            rotationOriginY: m.height / 2\n          });\n          u(!g && x.crop, !0) && (r = B(v.x) && B(v.y) && k.isInsidePlot(v.x - h + v.width, v.y) && k.isInsidePlot(v.x + h, v.y));\n          v[r ? \"show\" : \"hide\"]();\n        }\n        H(this, \"afterSetOffset\", {\n          xOffset: a,\n          width: p\n        });\n      }\n      adjustStackPosition({\n        labelBox: a,\n        verticalAlign: p,\n        textAlign: t\n      }) {\n        const l = {\n          bottom: 0,\n          middle: 1,\n          top: 2,\n          right: 1,\n          center: 0,\n          left: -1\n        };\n        return {\n          x: a.width / 2 + a.width / 2 * l[t],\n          y: a.height / 2 * l[p]\n        };\n      }\n      getStackBox(a) {\n        var l = this.axis;\n        const t = l.chart,\n          {\n            boxTop: m,\n            defaultX: h,\n            xOffset: g,\n            width: e,\n            boxBottom: w\n          } = a;\n        var v = l.stacking.usePercentage ? 100 : u(m, this.total, 0);\n        v = l.toPixels(v);\n        a = a.xAxis || t.xAxis[0];\n        const x = u(h, a.translate(this.x)) + g;\n        l = l.toPixels(w || B(l.min) && l.logarithmic && l.logarithmic.lin2log(l.min) || 0);\n        l = Math.abs(v - l);\n        const d = this.isNegative;\n        return t.inverted ? {\n          x: (d ? v : v - l) - t.plotLeft,\n          y: a.height - x - e,\n          width: l,\n          height: e\n        } : {\n          x: x + a.transB - t.plotLeft,\n          y: (d ? v - l : v) - t.plotTop,\n          width: e,\n          height: l\n        };\n      }\n    }\n    \"\";\n    return v;\n  });\n  M(a, \"Core/Axis/Stacking/StackingAxis.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C) {\n    function x() {\n      const b = this,\n        a = b.inverted;\n      b.yAxis.forEach(b => {\n        b.stacking && b.stacking.stacks && b.hasVisibleSeries && (b.stacking.oldStacks = b.stacking.stacks);\n      });\n      b.series.forEach(c => {\n        const d = c.xAxis && c.xAxis.options || {};\n        !c.options.stacking || !0 !== c.visible && !1 !== b.options.chart.ignoreHiddenSeries || (c.stackKey = [c.type, q(c.options.stack, \"\"), a ? d.top : d.left, a ? d.height : d.width].join());\n      });\n    }\n    function H() {\n      const b = this.stacking;\n      if (b) {\n        var a = b.stacks;\n        r(a, function (b, c) {\n          E(b);\n          a[c] = null;\n        });\n        b && b.stackTotalGroup && b.stackTotalGroup.destroy();\n      }\n    }\n    function B() {\n      \"yAxis\" !== this.coll || this.stacking || (this.stacking = new G(this));\n    }\n    function u(b, a, d, e) {\n      !w(b) || b.x !== a || e && b.stackKey !== e ? b = {\n        x: a,\n        index: 0,\n        key: e,\n        stackKey: e\n      } : b.index++;\n      b.key = [d, a, b.index].join();\n      return b;\n    }\n    function v() {\n      const b = this,\n        a = b.stackKey,\n        d = b.yAxis.stacking.stacks,\n        e = b.processedXData,\n        g = b[b.options.stacking + \"Stacker\"];\n      let k;\n      g && [a, \"-\" + a].forEach(a => {\n        let c = e.length;\n        let f;\n        for (; c--;) {\n          var h = e[c];\n          k = b.getStackIndicator(k, h, b.index, a);\n          (f = (h = d[a] && d[a][h]) && h.points[k.key]) && g.call(b, f, h, c);\n        }\n      });\n    }\n    function l(b, a, d) {\n      a = a.total ? 100 / a.total : 0;\n      b[0] = e(b[0] * a);\n      b[1] = e(b[1] * a);\n      this.stackedYData[d] = b[1];\n    }\n    function p() {\n      const b = this.yAxis.stacking;\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length ? h.setStackedPoints.call(this, \"group\") : b && r(b.stacks, (a, d) => {\n        \"group\" === d.slice(-5) && (r(a, b => b.destroy()), delete b.stacks[d]);\n      });\n    }\n    function t(b) {\n      var a = this.chart;\n      const f = b || this.options.stacking;\n      if (f && (!0 === this.visible || !1 === a.options.chart.ignoreHiddenSeries)) {\n        var g = this.processedXData,\n          k = this.processedYData,\n          h = [],\n          l = k.length,\n          m = this.options,\n          p = m.threshold,\n          r = q(m.startFromThreshold && p, 0);\n        m = m.stack;\n        b = b ? `${this.type},${f}` : this.stackKey;\n        var t = \"-\" + b,\n          v = this.negStacks;\n        a = \"group\" === f ? a.yAxis[0] : this.yAxis;\n        var u = a.stacking.stacks,\n          x = a.stacking.oldStacks,\n          E,\n          G;\n        a.stacking.stacksTouched += 1;\n        for (G = 0; G < l; G++) {\n          var F = g[G];\n          var B = k[G];\n          var y = this.getStackIndicator(y, F, this.index);\n          var C = y.key;\n          var z = (E = v && B < (r ? 0 : p)) ? t : b;\n          u[z] || (u[z] = {});\n          u[z][F] || (x[z] && x[z][F] ? (u[z][F] = x[z][F], u[z][F].total = null) : u[z][F] = new L(a, a.options.stackLabels, !!E, F, m));\n          z = u[z][F];\n          null !== B ? (z.points[C] = z.points[this.index] = [q(z.cumulative, r)], w(z.cumulative) || (z.base = C), z.touched = a.stacking.stacksTouched, 0 < y.index && !1 === this.singleStacks && (z.points[C][0] = z.points[this.index + \",\" + F + \",0\"][0])) : z.points[C] = z.points[this.index] = null;\n          \"percent\" === f ? (E = E ? b : t, v && u[E] && u[E][F] ? (E = u[E][F], z.total = E.total = Math.max(E.total, z.total) + Math.abs(B) || 0) : z.total = e(z.total + (Math.abs(B) || 0))) : \"group\" === f ? (d(B) && (B = B[0]), null !== B && (z.total = (z.total || 0) + 1)) : z.total = e(z.total + (B || 0));\n          z.cumulative = \"group\" === f ? (z.total || 1) - 1 : e(q(z.cumulative, r) + (B || 0));\n          null !== B && (z.points[C].push(z.cumulative), h[G] = z.cumulative, z.hasValidPoints = !0);\n        }\n        \"percent\" === f && (a.stacking.usePercentage = !0);\n        \"group\" !== f && (this.stackedYData = h);\n        a.stacking.oldStacks = {};\n      }\n    }\n    const {\n        getDeferredAnimation: m\n      } = a,\n      {\n        series: {\n          prototype: h\n        }\n      } = I,\n      {\n        addEvent: g,\n        correctFloat: e,\n        defined: w,\n        destroyObjectProperties: E,\n        fireEvent: F,\n        isArray: d,\n        isNumber: k,\n        objectEach: r,\n        pick: q\n      } = C;\n    class G {\n      constructor(b) {\n        this.oldStacks = {};\n        this.stacks = {};\n        this.stacksTouched = 0;\n        this.axis = b;\n      }\n      buildStacks() {\n        const b = this.axis,\n          a = b.series,\n          d = b.options.reversedStacks,\n          e = a.length;\n        let g, k;\n        this.usePercentage = !1;\n        for (k = e; k--;) g = a[d ? k : e - k - 1], g.setStackedPoints(), g.setGroupedPoints();\n        for (k = 0; k < e; k++) a[k].modifyStacks();\n        F(b, \"afterBuildStacks\");\n      }\n      cleanStacks() {\n        let b;\n        this.oldStacks && (b = this.stacks = this.oldStacks);\n        r(b, function (b) {\n          r(b, function (b) {\n            b.cumulative = b.total;\n          });\n        });\n      }\n      resetStacks() {\n        r(this.stacks, b => {\n          r(b, (a, d) => {\n            k(a.touched) && a.touched < this.stacksTouched ? (a.destroy(), delete b[d]) : (a.total = null, a.cumulative = null);\n          });\n        });\n      }\n      renderStackTotals() {\n        var b = this.axis;\n        const a = b.chart,\n          d = a.renderer,\n          e = this.stacks;\n        b = m(a, b.options.stackLabels && b.options.stackLabels.animation || !1);\n        const g = this.stackTotalGroup = this.stackTotalGroup || d.g(\"stack-labels\").attr({\n          zIndex: 6,\n          opacity: 0\n        }).add();\n        g.translate(a.plotLeft, a.plotTop);\n        r(e, function (b) {\n          r(b, function (b) {\n            b.render(g);\n          });\n        });\n        g.animate({\n          opacity: 1\n        }, b);\n      }\n    }\n    var b;\n    (function (b) {\n      const a = [];\n      b.compose = function (b, c, d) {\n        C.pushUnique(a, b) && (g(b, \"init\", B), g(b, \"destroy\", H));\n        C.pushUnique(a, c) && (c.prototype.getStacks = x);\n        C.pushUnique(a, d) && (b = d.prototype, b.getStackIndicator = u, b.modifyStacks = v, b.percentStacker = l, b.setGroupedPoints = p, b.setStackedPoints = t);\n      };\n    })(b || (b = {}));\n    return b;\n  });\n  M(a, \"Series/Line/LineSeries.js\", [a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n      defined: x,\n      merge: C\n    } = I;\n    class z extends a {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      drawGraph() {\n        const a = this,\n          x = this.options,\n          u = (this.gappedPath || this.getGraphPath).call(this),\n          v = this.chart.styledMode;\n        let l = [[\"graph\", \"highcharts-graph\"]];\n        v || l[0].push(x.lineColor || this.color || \"#cccccc\", x.dashStyle);\n        l = a.getZonesGraphs(l);\n        l.forEach(function (l, t) {\n          var m = l[0];\n          let h = a[m];\n          const g = h ? \"animate\" : \"attr\";\n          h ? (h.endX = a.preventGraphAnimation ? null : u.xMap, h.animate({\n            d: u\n          })) : u.length && (a[m] = h = a.chart.renderer.path(u).addClass(l[1]).attr({\n            zIndex: 1\n          }).add(a.group));\n          h && !v && (m = {\n            stroke: l[2],\n            \"stroke-width\": x.lineWidth || 0,\n            fill: a.fillGraph && a.color || \"none\"\n          }, l[3] ? m.dashstyle = l[3] : \"square\" !== x.linecap && (m[\"stroke-linecap\"] = m[\"stroke-linejoin\"] = \"round\"), h[g](m).shadow(2 > t && x.shadow));\n          h && (h.startX = u.xMap, h.isArea = u.isArea);\n        });\n      }\n      getGraphPath(a, B, u) {\n        const v = this,\n          l = v.options,\n          p = [],\n          t = [];\n        let m,\n          h = l.step;\n        a = a || v.points;\n        const g = a.reversed;\n        g && a.reverse();\n        (h = {\n          right: 1,\n          center: 2\n        }[h] || h && 3) && g && (h = 4 - h);\n        a = this.getValidPoints(a, !1, !(l.connectNulls && !B && !u));\n        a.forEach(function (e, g) {\n          const w = e.plotX,\n            F = e.plotY,\n            d = a[g - 1],\n            k = e.isNull || \"number\" !== typeof F;\n          (e.leftCliff || d && d.rightCliff) && !u && (m = !0);\n          k && !x(B) && 0 < g ? m = !l.connectNulls : k && !B ? m = !0 : (0 === g || m ? g = [[\"M\", e.plotX, e.plotY]] : v.getPointSpline ? g = [v.getPointSpline(a, e, g)] : h ? (g = 1 === h ? [[\"L\", d.plotX, F]] : 2 === h ? [[\"L\", (d.plotX + w) / 2, d.plotY], [\"L\", (d.plotX + w) / 2, F]] : [[\"L\", w, d.plotY]], g.push([\"L\", w, F])) : g = [[\"L\", w, F]], t.push(e.x), h && (t.push(e.x), 2 === h && t.push(e.x)), p.push.apply(p, g), m = !1);\n        });\n        p.xMap = t;\n        return v.graphPath = p;\n      }\n      getZonesGraphs(a) {\n        this.zones.forEach(function (x, u) {\n          u = [\"zone-graph-\" + u, \"highcharts-graph highcharts-zone-graph-\" + u + \" \" + (x.className || \"\")];\n          this.chart.styledMode || u.push(x.color || this.color, x.dashStyle || this.options.dashStyle);\n          a.push(u);\n        }, this);\n        return a;\n      }\n    }\n    z.defaultOptions = C(a.defaultOptions, {\n      legendSymbol: \"lineMarker\"\n    });\n    y.registerSeriesType(\"line\", z);\n    \"\";\n    return z;\n  });\n  M(a, \"Series/Area/AreaSeries.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        seriesTypes: {\n          line: x\n        }\n      } = y,\n      {\n        extend: C,\n        merge: z,\n        objectEach: H,\n        pick: B\n      } = I;\n    class u extends x {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      drawGraph() {\n        this.areaPath = [];\n        super.drawGraph.apply(this);\n        const a = this,\n          l = this.areaPath,\n          p = this.options,\n          t = [[\"area\", \"highcharts-area\", this.color, p.fillColor]];\n        this.zones.forEach(function (l, h) {\n          t.push([\"zone-area-\" + h, \"highcharts-area highcharts-zone-area-\" + h + \" \" + l.className, l.color || a.color, l.fillColor || p.fillColor]);\n        });\n        t.forEach(function (m) {\n          const h = m[0],\n            g = {};\n          let e = a[h];\n          const t = e ? \"animate\" : \"attr\";\n          e ? (e.endX = a.preventGraphAnimation ? null : l.xMap, e.animate({\n            d: l\n          })) : (g.zIndex = 0, e = a[h] = a.chart.renderer.path(l).addClass(m[1]).add(a.group), e.isArea = !0);\n          a.chart.styledMode || (m[3] ? g.fill = m[3] : (g.fill = m[2], g[\"fill-opacity\"] = B(p.fillOpacity, .75)));\n          e[t](g);\n          e.startX = l.xMap;\n          e.shiftUnit = p.step ? 2 : 1;\n        });\n      }\n      getGraphPath(a) {\n        var l = x.prototype.getGraphPath,\n          p = this.options;\n        const t = p.stacking,\n          m = this.yAxis,\n          h = [],\n          g = [],\n          e = this.index,\n          w = m.stacking.stacks[this.stackKey],\n          v = p.threshold,\n          u = Math.round(m.getThreshold(p.threshold));\n        p = B(p.connectNulls, \"percent\" === t);\n        var d = function (d, b, f) {\n          var c = a[d];\n          d = t && w[c.x].points[e];\n          const n = c[f + \"Null\"] || 0;\n          f = c[f + \"Cliff\"] || 0;\n          let l, q;\n          c = !0;\n          f || n ? (l = (n ? d[0] : d[1]) + f, q = d[0] + f, c = !!n) : !t && a[b] && a[b].isNull && (l = q = v);\n          \"undefined\" !== typeof l && (g.push({\n            plotX: k,\n            plotY: null === l ? u : m.getThreshold(l),\n            isNull: c,\n            isCliff: !0\n          }), h.push({\n            plotX: k,\n            plotY: null === q ? u : m.getThreshold(q),\n            doCurve: !1\n          }));\n        };\n        let k;\n        a = a || this.points;\n        t && (a = this.getStackPoints(a));\n        for (let e = 0, b = a.length; e < b; ++e) {\n          t || (a[e].leftCliff = a[e].rightCliff = a[e].leftNull = a[e].rightNull = void 0);\n          var r = a[e].isNull;\n          k = B(a[e].rectPlotX, a[e].plotX);\n          var q = t ? B(a[e].yBottom, u) : u;\n          if (!r || p) p || d(e, e - 1, \"left\"), r && !t && p || (g.push(a[e]), h.push({\n            x: e,\n            plotX: k,\n            plotY: q\n          })), p || d(e, e + 1, \"right\");\n        }\n        d = l.call(this, g, !0, !0);\n        h.reversed = !0;\n        r = l.call(this, h, !0, !0);\n        (q = r[0]) && \"M\" === q[0] && (r[0] = [\"L\", q[1], q[2]]);\n        r = d.concat(r);\n        r.length && r.push([\"Z\"]);\n        l = l.call(this, g, !1, p);\n        r.xMap = d.xMap;\n        this.areaPath = r;\n        return l;\n      }\n      getStackPoints(a) {\n        const l = this,\n          p = [],\n          t = [],\n          m = this.xAxis,\n          h = this.yAxis,\n          g = h.stacking.stacks[this.stackKey],\n          e = {},\n          w = h.series,\n          v = w.length,\n          u = h.options.reversedStacks ? 1 : -1,\n          d = w.indexOf(l);\n        a = a || this.points;\n        if (this.options.stacking) {\n          for (let d = 0; d < a.length; d++) a[d].leftNull = a[d].rightNull = void 0, e[a[d].x] = a[d];\n          H(g, function (a, d) {\n            null !== a.total && t.push(d);\n          });\n          t.sort(function (a, d) {\n            return a - d;\n          });\n          const k = w.map(a => a.visible);\n          t.forEach(function (a, q) {\n            let r = 0,\n              b,\n              f;\n            if (e[a] && !e[a].isNull) p.push(e[a]), [-1, 1].forEach(function (c) {\n              const h = 1 === c ? \"rightNull\" : \"leftNull\",\n                m = g[t[q + c]];\n              let p = 0;\n              if (m) {\n                let c = d;\n                for (; 0 <= c && c < v;) {\n                  const d = w[c].index;\n                  b = m.points[d];\n                  b || (d === l.index ? e[a][h] = !0 : k[c] && (f = g[a].points[d]) && (p -= f[1] - f[0]));\n                  c += u;\n                }\n              }\n              e[a][1 === c ? \"rightCliff\" : \"leftCliff\"] = p;\n            });else {\n              let c = d;\n              for (; 0 <= c && c < v;) {\n                if (b = g[a].points[w[c].index]) {\n                  r = b[1];\n                  break;\n                }\n                c += u;\n              }\n              r = B(r, 0);\n              r = h.translate(r, 0, 1, 0, 1);\n              p.push({\n                isNull: !0,\n                plotX: m.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: r,\n                yBottom: r\n              });\n            }\n          });\n        }\n        return p;\n      }\n    }\n    u.defaultOptions = z(x.defaultOptions, {\n      threshold: 0,\n      legendSymbol: \"rectangle\"\n    });\n    C(u.prototype, {\n      singleStacks: !1\n    });\n    y.registerSeriesType(\"area\", u);\n    \"\";\n    return u;\n  });\n  M(a, \"Series/Spline/SplineSeries.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    const {\n        line: x\n      } = a.seriesTypes,\n      {\n        merge: L,\n        pick: C\n      } = y;\n    class z extends x {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      getPointSpline(a, x, u) {\n        const v = x.plotX || 0,\n          l = x.plotY || 0,\n          p = a[u - 1];\n        u = a[u + 1];\n        let t, m;\n        let h;\n        if (p && !p.isNull && !1 !== p.doCurve && !x.isCliff && u && !u.isNull && !1 !== u.doCurve && !x.isCliff) {\n          a = p.plotY || 0;\n          var g = u.plotX || 0;\n          u = u.plotY || 0;\n          let e = 0;\n          t = (1.5 * v + (p.plotX || 0)) / 2.5;\n          m = (1.5 * l + a) / 2.5;\n          g = (1.5 * v + g) / 2.5;\n          h = (1.5 * l + u) / 2.5;\n          g !== t && (e = (h - m) * (g - v) / (g - t) + l - h);\n          m += e;\n          h += e;\n          m > a && m > l ? (m = Math.max(a, l), h = 2 * l - m) : m < a && m < l && (m = Math.min(a, l), h = 2 * l - m);\n          h > u && h > l ? (h = Math.max(u, l), m = 2 * l - h) : h < u && h < l && (h = Math.min(u, l), m = 2 * l - h);\n          x.rightContX = g;\n          x.rightContY = h;\n        }\n        x = [\"C\", C(p.rightContX, p.plotX, 0), C(p.rightContY, p.plotY, 0), C(t, v, 0), C(m, l, 0), v, l];\n        p.rightContX = p.rightContY = void 0;\n        return x;\n      }\n    }\n    z.defaultOptions = L(x.defaultOptions);\n    a.registerSeriesType(\"spline\", z);\n    \"\";\n    return z;\n  });\n  M(a, \"Series/AreaSpline/AreaSplineSeries.js\", [a[\"Series/Spline/SplineSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        area: x,\n        area: {\n          prototype: C\n        }\n      } = y.seriesTypes,\n      {\n        extend: z,\n        merge: H\n      } = I;\n    class B extends a {\n      constructor() {\n        super(...arguments);\n        this.options = this.points = this.data = void 0;\n      }\n    }\n    B.defaultOptions = H(a.defaultOptions, x.defaultOptions);\n    z(B.prototype, {\n      getGraphPath: C.getGraphPath,\n      getStackPoints: C.getStackPoints,\n      drawGraph: C.drawGraph\n    });\n    y.registerSeriesType(\"areaspline\", B);\n    \"\";\n    return B;\n  });\n  M(a, \"Series/Column/ColumnSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      borderRadius: 3,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    };\n  });\n  M(a, \"Series/Column/ColumnSeries.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Color/Color.js\"], a[\"Series/Column/ColumnSeriesDefaults.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z, H) {\n    const {\n        animObject: x\n      } = a,\n      {\n        parse: u\n      } = y,\n      {\n        hasTouch: v,\n        noop: l\n      } = L,\n      {\n        clamp: p,\n        defined: t,\n        extend: m,\n        fireEvent: h,\n        isArray: g,\n        isNumber: e,\n        merge: w,\n        pick: E,\n        objectEach: F\n      } = H;\n    class d extends C {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.group = this.data = this.borderWidth = void 0;\n      }\n      animate(a) {\n        const d = this,\n          e = this.yAxis,\n          g = e.pos,\n          b = d.options,\n          f = this.chart.inverted,\n          c = {},\n          k = f ? \"translateX\" : \"translateY\";\n        let h;\n        a ? (c.scaleY = .001, a = p(e.toPixels(b.threshold), g, g + e.len), f ? c.translateX = a - e.len : c.translateY = a, d.clipBox && d.setClip(), d.group.attr(c)) : (h = Number(d.group.attr(k)), d.group.animate({\n          scaleY: 1\n        }, m(x(d.options.animation), {\n          step: function (b, a) {\n            d.group && (c[k] = h + a.pos * (g - h), d.group.attr(c));\n          }\n        })));\n      }\n      init(a, d) {\n        super.init.apply(this, arguments);\n        const e = this;\n        a = e.chart;\n        a.hasRendered && a.series.forEach(function (a) {\n          a.type === e.type && (a.isDirty = !0);\n        });\n      }\n      getColumnMetrics() {\n        const a = this;\n        var d = a.options;\n        const e = a.xAxis,\n          g = a.yAxis;\n        var b = e.options.reversedStacks;\n        b = e.reversed && !b || !e.reversed && b;\n        const f = {};\n        let c,\n          h = 0;\n        !1 === d.grouping ? h = 1 : a.chart.series.forEach(function (b) {\n          const d = b.yAxis,\n            e = b.options;\n          let k;\n          b.type !== a.type || !b.visible && a.chart.options.chart.ignoreHiddenSeries || g.len !== d.len || g.pos !== d.pos || (e.stacking && \"group\" !== e.stacking ? (c = b.stackKey, \"undefined\" === typeof f[c] && (f[c] = h++), k = f[c]) : !1 !== e.grouping && (k = h++), b.columnIndex = k);\n        });\n        const l = Math.min(Math.abs(e.transA) * (e.ordinal && e.ordinal.slope || d.pointRange || e.closestPointRange || e.tickInterval || 1), e.len),\n          m = l * d.groupPadding,\n          p = (l - 2 * m) / (h || 1);\n        d = Math.min(d.maxPointWidth || e.len, E(d.pointWidth, p * (1 - 2 * d.pointPadding)));\n        a.columnMetrics = {\n          width: d,\n          offset: (p - d) / 2 + (m + ((a.columnIndex || 0) + (b ? 1 : 0)) * p - l / 2) * (b ? -1 : 1),\n          paddedWidth: p,\n          columnCount: h\n        };\n        return a.columnMetrics;\n      }\n      crispCol(a, d, e, g) {\n        var b = this.borderWidth,\n          f = -(b % 2 ? .5 : 0);\n        b = b % 2 ? .5 : 1;\n        this.options.crisp && (e = Math.round(a + e) + f, a = Math.round(a) + f, e -= a);\n        g = Math.round(d + g) + b;\n        f = .5 >= Math.abs(d) && .5 < g;\n        d = Math.round(d) + b;\n        g -= d;\n        f && g && (--d, g += 1);\n        return {\n          x: a,\n          y: d,\n          width: e,\n          height: g\n        };\n      }\n      adjustForMissingColumns(a, d, e, h) {\n        const b = this.options.stacking;\n        if (!e.isNull && 1 < h.columnCount) {\n          const f = this.yAxis.options.reversedStacks;\n          let c = 0,\n            k = f ? 0 : -h.columnCount;\n          F(this.yAxis.stacking && this.yAxis.stacking.stacks, a => {\n            if (\"number\" === typeof e.x) {\n              const d = a[e.x.toString()];\n              d && (a = d.points[this.index], b ? (a && (c = k), d.hasValidPoints && (f ? k++ : k--)) : g(a) && (a = Object.keys(d.points).filter(b => !b.match(\",\") && d.points[b] && 1 < d.points[b].length).map(parseFloat).sort((b, a) => a - b), c = a.indexOf(this.index), k = a.length));\n            }\n          });\n          a = (e.plotX || 0) + ((k - 1) * h.paddedWidth + d) / 2 - d - c * h.paddedWidth;\n        }\n        return a;\n      }\n      translate() {\n        const a = this,\n          d = a.chart,\n          g = a.options;\n        var l = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        l = a.borderWidth = E(g.borderWidth, l ? 0 : 1);\n        const b = a.xAxis,\n          f = a.yAxis,\n          c = g.threshold,\n          n = E(g.minPointLength, 5),\n          m = a.getColumnMetrics(),\n          w = m.width,\n          v = a.pointXOffset = m.offset,\n          u = a.dataMin,\n          x = a.dataMax;\n        let F = a.barW = Math.max(w, 1 + 2 * l),\n          y = a.translatedThreshold = f.getThreshold(c);\n        d.inverted && (y -= .5);\n        g.pointPadding && (F = Math.ceil(F));\n        C.prototype.translate.apply(a);\n        a.points.forEach(function (k) {\n          const h = E(k.yBottom, y);\n          var l = 999 + Math.abs(h),\n            q = k.plotX || 0;\n          l = p(k.plotY, -l, f.len + l);\n          let r = Math.min(l, h),\n            D = Math.max(l, h) - r,\n            z = w,\n            B = q + v,\n            G = F;\n          n && Math.abs(D) < n && (D = n, q = !f.reversed && !k.negative || f.reversed && k.negative, e(c) && e(x) && k.y === c && x <= c && (f.min || 0) < c && (u !== x || (f.max || 0) <= c) && (q = !q, k.negative = !k.negative), r = Math.abs(r - y) > n ? h - n : y - (q ? n : 0));\n          t(k.options.pointWidth) && (z = G = Math.ceil(k.options.pointWidth), B -= Math.round((z - w) / 2));\n          g.centerInCategory && (B = a.adjustForMissingColumns(B, z, k, m));\n          k.barX = B;\n          k.pointWidth = z;\n          k.tooltipPos = d.inverted ? [p(f.len + f.pos - d.plotLeft - l, f.pos - d.plotLeft, f.len + f.pos - d.plotLeft), b.len + b.pos - d.plotTop - B - G / 2, D] : [b.left - d.plotLeft + B + G / 2, p(l + f.pos - d.plotTop, f.pos - d.plotTop, f.len + f.pos - d.plotTop), D];\n          k.shapeType = a.pointClass.prototype.shapeType || \"roundedRect\";\n          k.shapeArgs = a.crispCol(B, k.isNull ? y : r, G, k.isNull ? 0 : D);\n        });\n        h(this, \"afterColumnTranslate\");\n      }\n      drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      }\n      pointAttribs(a, d) {\n        const e = this.options;\n        var g = this.pointAttrToOptions || {},\n          b = g.stroke || \"borderColor\";\n        const f = g[\"stroke-width\"] || \"borderWidth\";\n        let c,\n          k = a && a.color || this.color,\n          h = a && a[b] || e[b] || k;\n        g = a && a.options.dashStyle || e.dashStyle;\n        let l = a && a[f] || e[f] || this[f] || 0,\n          m = E(a && a.opacity, e.opacity, 1);\n        a && this.zones.length && (c = a.getZone(), k = a.options.color || c && (c.color || a.nonZonedColor) || this.color, c && (h = c.borderColor || h, g = c.dashStyle || g, l = c.borderWidth || l));\n        d && a && (a = w(e.states[d], a.options.states && a.options.states[d] || {}), d = a.brightness, k = a.color || \"undefined\" !== typeof d && u(k).brighten(a.brightness).get() || k, h = a[b] || h, l = a[f] || l, g = a.dashStyle || g, m = E(a.opacity, m));\n        b = {\n          fill: k,\n          stroke: h,\n          \"stroke-width\": l,\n          opacity: m\n        };\n        g && (b.dashstyle = g);\n        return b;\n      }\n      drawPoints(a = this.points) {\n        const d = this,\n          g = this.chart,\n          k = d.options,\n          b = g.renderer,\n          f = k.animationLimit || 250;\n        let c;\n        a.forEach(function (a) {\n          let h = a.graphic,\n            l = !!h,\n            n = h && g.pointCount < f ? \"animate\" : \"attr\";\n          if (e(a.plotY) && null !== a.y) {\n            c = a.shapeArgs;\n            h && a.hasNewShapeType() && (h = h.destroy());\n            d.enabledDataSorting && (a.startXPos = d.xAxis.reversed ? -(c ? c.width || 0 : 0) : d.xAxis.width);\n            h || (a.graphic = h = b[a.shapeType](c).add(a.group || d.group)) && d.enabledDataSorting && g.hasRendered && g.pointCount < f && (h.attr({\n              x: a.startXPos\n            }), l = !0, n = \"animate\");\n            if (h && l) h[n](w(c));\n            g.styledMode || h[n](d.pointAttribs(a, a.selected && \"select\")).shadow(!1 !== a.allowShadow && k.shadow);\n            h && (h.addClass(a.getClassName(), !0), h.attr({\n              visibility: a.visible ? \"inherit\" : \"hidden\"\n            }));\n          } else h && (a.graphic = h.destroy());\n        });\n      }\n      drawTracker(a = this.points) {\n        const d = this,\n          e = d.chart,\n          k = e.pointer,\n          b = function (a) {\n            const b = k.getPointFromEvent(a);\n            \"undefined\" !== typeof b && d.options.enableMouseTracking && (k.isDirectTouch = !0, b.onMouseOver(a));\n          };\n        let f;\n        a.forEach(function (a) {\n          f = g(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          f.forEach(function (b) {\n            b.div ? b.div.point = a : b.element.point = a;\n          });\n        });\n        d._hasTracking || (d.trackerGroups.forEach(function (a) {\n          if (d[a]) {\n            d[a].addClass(\"highcharts-tracker\").on(\"mouseover\", b).on(\"mouseout\", function (a) {\n              k.onTrackerMouseOut(a);\n            });\n            if (v) d[a].on(\"touchstart\", b);\n            !e.styledMode && d.options.cursor && d[a].css({\n              cursor: d.options.cursor\n            });\n          }\n        }), d._hasTracking = !0);\n        h(this, \"afterDrawTracker\");\n      }\n      remove() {\n        const a = this,\n          d = a.chart;\n        d.hasRendered && d.series.forEach(function (d) {\n          d.type === a.type && (d.isDirty = !0);\n        });\n        C.prototype.remove.apply(a, arguments);\n      }\n    }\n    d.defaultOptions = w(C.defaultOptions, I);\n    m(d.prototype, {\n      cropShoulder: 0,\n      directTouch: !0,\n      getSymbol: l,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    z.registerSeriesType(\"column\", d);\n    \"\";\n    return d;\n  });\n  M(a, \"Core/Series/DataLabel.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Templating.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        getDeferredAnimation: x\n      } = a,\n      {\n        format: C\n      } = y,\n      {\n        defined: z,\n        extend: H,\n        fireEvent: B,\n        isArray: u,\n        isString: v,\n        merge: l,\n        objectEach: p,\n        pick: t,\n        splat: m\n      } = I;\n    var h;\n    (function (a) {\n      function e(a, d, c, e, g) {\n        const b = this.chart;\n        var f = this.isCartesian && b.inverted;\n        const k = this.enabledDataSorting;\n        var h = a.plotX,\n          l = a.plotY;\n        const n = c.rotation;\n        var m = c.align;\n        l = z(h) && z(l) && b.isInsidePlot(h, Math.round(l), {\n          inverted: f,\n          paneCoordinates: !0,\n          series: this\n        });\n        let p = \"justify\" === t(c.overflow, k ? \"none\" : \"justify\");\n        f = this.visible && !1 !== a.visible && z(h) && (a.series.forceDL || k && !p || l || t(c.inside, !!this.options.stacking) && e && b.isInsidePlot(h, f ? e.x + 1 : e.y + e.height - 1, {\n          inverted: f,\n          paneCoordinates: !0,\n          series: this\n        }));\n        h = a.pos();\n        if (f && h) {\n          n && d.attr({\n            align: m\n          });\n          m = d.getBBox(!0);\n          var q = [0, 0];\n          var r = b.renderer.fontMetrics(d).b;\n          e = H({\n            x: h[0],\n            y: Math.round(h[1]),\n            width: 0,\n            height: 0\n          }, e);\n          H(c, {\n            width: m.width,\n            height: m.height\n          });\n          n ? (p = !1, q = b.renderer.rotCorr(r, n), r = {\n            x: e.x + (c.x || 0) + e.width / 2 + q.x,\n            y: e.y + (c.y || 0) + {\n              top: 0,\n              middle: .5,\n              bottom: 1\n            }[c.verticalAlign] * e.height\n          }, q = [m.x - Number(d.attr(\"x\")), m.y - Number(d.attr(\"y\"))], k && this.xAxis && !p && this.setDataLabelStartPos(a, d, g, l, r), d[g ? \"attr\" : \"animate\"](r)) : (k && this.xAxis && !p && this.setDataLabelStartPos(a, d, g, l, e), d.align(c, void 0, e), r = d.alignAttr);\n          if (p && 0 <= e.height) this.justifyDataLabel(d, c, r, m, e, g);else if (t(c.crop, !0)) {\n            let {\n              x: a,\n              y: c\n            } = r;\n            a += q[0];\n            c += q[1];\n            f = b.isInsidePlot(a, c, {\n              paneCoordinates: !0,\n              series: this\n            }) && b.isInsidePlot(a + m.width, c + m.height, {\n              paneCoordinates: !0,\n              series: this\n            });\n          }\n          if (c.shape && !n) d[g ? \"attr\" : \"animate\"]({\n            anchorX: h[0],\n            anchorY: h[1]\n          });\n        }\n        g && k && (d.placed = !1);\n        f || k && !p ? d.show() : (d.hide(), d.placed = !1);\n      }\n      function g(a, d) {\n        var b = d.filter;\n        return b ? (d = b.operator, a = a[b.property], b = b.value, \">\" === d && a > b || \"<\" === d && a < b || \">=\" === d && a >= b || \"<=\" === d && a <= b || \"==\" === d && a == b || \"===\" === d && a === b ? !0 : !1) : !0;\n      }\n      function h() {\n        return this.plotGroup(\"dataLabelsGroup\", \"data-labels\", this.hasRendered ? \"inherit\" : \"hidden\", this.options.dataLabels.zIndex || 6);\n      }\n      function F(a) {\n        const b = this.hasRendered || 0,\n          c = this.initDataLabelsGroup().attr({\n            opacity: +b\n          });\n        !b && c && (this.visible && c.show(), this.options.animation ? c.animate({\n          opacity: 1\n        }, a) : c.attr({\n          opacity: 1\n        }));\n        return c;\n      }\n      function d(a = this.points) {\n        var b, c;\n        const d = this,\n          e = d.chart,\n          k = d.options,\n          h = e.renderer,\n          {\n            backgroundColor: l,\n            plotBackgroundColor: q\n          } = e.options.chart,\n          w = e.options.plotOptions,\n          E = h.getContrast(v(q) && q || v(l) && l || \"#000000\");\n        let F = k.dataLabels,\n          A,\n          y;\n        var G = m(F)[0];\n        const H = G.animation;\n        G = G.defer ? x(e, H, d) : {\n          defer: 0,\n          duration: 0\n        };\n        F = r(r(null === (b = null === w || void 0 === w ? void 0 : w.series) || void 0 === b ? void 0 : b.dataLabels, null === (c = null === w || void 0 === w ? void 0 : w[d.type]) || void 0 === c ? void 0 : c.dataLabels), F);\n        B(this, \"drawDataLabels\");\n        if (u(F) || F.enabled || d._hasPointLabels) y = this.initDataLabels(G), a.forEach(a => {\n          var b;\n          const c = a.dataLabels || [];\n          A = m(r(F, a.dlOptions || (null === (b = a.options) || void 0 === b ? void 0 : b.dataLabels)));\n          A.forEach((b, f) => {\n            var l,\n              m = b.enabled && (!a.isNull || a.dataLabelOnNull) && g(a, b);\n            const n = a.connectors ? a.connectors[f] : a.connector,\n              q = b.style || {};\n            let r = {},\n              w = c[f],\n              u = !w;\n            const x = t(b.distance, a.labelDistance);\n            if (m) {\n              var A = t(b[a.formatPrefix + \"Format\"], b.format);\n              var F = a.getLabelConfig();\n              F = z(A) ? C(A, F, e) : (b[a.formatPrefix + \"Formatter\"] || b.formatter).call(F, b);\n              A = b.rotation;\n              e.styledMode || (q.color = t(b.color, q.color, v(d.color) ? d.color : void 0, \"#000000\"), \"contrast\" === q.color ? (a.contrastColor = h.getContrast(a.color || d.color), q.color = !z(x) && b.inside || 0 > (x || 0) || k.stacking ? a.contrastColor : E) : delete a.contrastColor, k.cursor && (q.cursor = k.cursor));\n              r = {\n                r: b.borderRadius || 0,\n                rotation: A,\n                padding: b.padding,\n                zIndex: 1\n              };\n              if (!e.styledMode) {\n                const {\n                  backgroundColor: c,\n                  borderColor: d\n                } = b;\n                r.fill = \"auto\" === c ? a.color : c;\n                r.stroke = \"auto\" === d ? a.color : d;\n                r[\"stroke-width\"] = b.borderWidth;\n              }\n              p(r, (a, b) => {\n                \"undefined\" === typeof a && delete r[b];\n              });\n            }\n            !w || m && z(F) && !!w.div === !!b.useHTML && (w.rotation && b.rotation || w.rotation === b.rotation) || (w = void 0, u = !0, n && a.connector && (a.connector = a.connector.destroy(), a.connectors && (1 === a.connectors.length ? delete a.connectors : delete a.connectors[f])));\n            m && z(F) && (w ? r.text = F : (w = A ? h.text(F, 0, 0, b.useHTML).addClass(\"highcharts-data-label\") : h.label(F, 0, 0, b.shape, void 0, void 0, b.useHTML, void 0, \"data-label\")) && w.addClass(\" highcharts-data-label-color-\" + a.colorIndex + \" \" + (b.className || \"\") + (b.useHTML ? \" highcharts-tracker\" : \"\")), w && (w.options = b, w.attr(r), e.styledMode || w.css(q).shadow(b.shadow), (m = b[a.formatPrefix + \"TextPath\"] || b.textPath) && !b.useHTML && (w.setTextPath((null === (l = a.getDataLabelPath) || void 0 === l ? void 0 : l.call(a, w)) || a.graphic, m), a.dataLabelPath && !m.enabled && (a.dataLabelPath = a.dataLabelPath.destroy())), w.added || w.add(y), d.alignDataLabel(a, w, b, void 0, u), w.isActive = !0, c[f] && c[f] !== w && c[f].destroy(), c[f] = w));\n          });\n          for (b = c.length; b--;) c[b].isActive ? c[b].isActive = !1 : (c[b].destroy(), c.splice(b, 1));\n          a.dataLabel = c[0];\n          a.dataLabels = c;\n        });\n        B(this, \"afterDrawDataLabels\");\n      }\n      function k(a, d, c, e, g, k) {\n        const b = this.chart,\n          f = d.align,\n          h = d.verticalAlign,\n          l = a.box ? 0 : a.padding || 0;\n        let {\n            x: m = 0,\n            y: n = 0\n          } = d,\n          p,\n          q;\n        p = (c.x || 0) + l;\n        0 > p && (\"right\" === f && 0 <= m ? (d.align = \"left\", d.inside = !0) : m -= p, q = !0);\n        p = (c.x || 0) + e.width - l;\n        p > b.plotWidth && (\"left\" === f && 0 >= m ? (d.align = \"right\", d.inside = !0) : m += b.plotWidth - p, q = !0);\n        p = c.y + l;\n        0 > p && (\"bottom\" === h && 0 <= n ? (d.verticalAlign = \"top\", d.inside = !0) : n -= p, q = !0);\n        p = (c.y || 0) + e.height - l;\n        p > b.plotHeight && (\"top\" === h && 0 >= n ? (d.verticalAlign = \"bottom\", d.inside = !0) : n += b.plotHeight - p, q = !0);\n        q && (d.x = m, d.y = n, a.placed = !k, a.align(d, void 0, g));\n        return q;\n      }\n      function r(a, d) {\n        let b = [],\n          f;\n        if (u(a) && !u(d)) b = a.map(function (a) {\n          return l(a, d);\n        });else if (u(d) && !u(a)) b = d.map(function (b) {\n          return l(a, b);\n        });else if (!u(a) && !u(d)) b = l(a, d);else if (u(a) && u(d)) for (f = Math.max(a.length, d.length); f--;) b[f] = l(a[f], d[f]);\n        return b;\n      }\n      function q(a, d, c, e, g) {\n        const b = this.chart,\n          f = b.inverted,\n          k = this.xAxis,\n          h = k.reversed,\n          l = f ? d.height / 2 : d.width / 2;\n        a = (a = a.pointWidth) ? a / 2 : 0;\n        d.startXPos = f ? g.x : h ? -l - a : k.width - l + a;\n        d.startYPos = f ? h ? this.yAxis.height - l + a : -l - a : g.y;\n        e ? \"hidden\" === d.visibility && (d.show(), d.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : d.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, d.hide);\n        b.hasRendered && (c && d.attr({\n          x: d.startXPos,\n          y: d.startYPos\n        }), d.placed = !0);\n      }\n      const y = [];\n      a.compose = function (a) {\n        I.pushUnique(y, a) && (a = a.prototype, a.initDataLabelsGroup = h, a.initDataLabels = F, a.alignDataLabel = e, a.drawDataLabels = d, a.justifyDataLabel = k, a.setDataLabelStartPos = q);\n      };\n    })(h || (h = {}));\n    \"\";\n    return h;\n  });\n  M(a, \"Series/Column/ColumnDataLabel.js\", [a[\"Core/Series/DataLabel.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        series: x\n      } = y,\n      {\n        merge: C,\n        pick: z\n      } = I;\n    var H;\n    (function (y) {\n      function u(a, p, t, m, h) {\n        let g = this.chart.inverted;\n        var e = a.series;\n        let l = (e.xAxis ? e.xAxis.len : this.chart.plotSizeX) || 0;\n        e = (e.yAxis ? e.yAxis.len : this.chart.plotSizeY) || 0;\n        var v = a.dlBox || a.shapeArgs;\n        let u = z(a.below, a.plotY > z(this.translatedThreshold, e)),\n          d = z(t.inside, !!this.options.stacking);\n        v && (m = C(v), 0 > m.y && (m.height += m.y, m.y = 0), v = m.y + m.height - e, 0 < v && v < m.height && (m.height -= v), g && (m = {\n          x: e - m.y - m.height,\n          y: l - m.x - m.width,\n          width: m.height,\n          height: m.width\n        }), d || (g ? (m.x += u ? 0 : m.width, m.width = 0) : (m.y += u ? m.height : 0, m.height = 0)));\n        t.align = z(t.align, !g || d ? \"center\" : u ? \"right\" : \"left\");\n        t.verticalAlign = z(t.verticalAlign, g || d ? \"middle\" : u ? \"top\" : \"bottom\");\n        x.prototype.alignDataLabel.call(this, a, p, t, m, h);\n        t.inside && a.contrastColor && p.css({\n          color: a.contrastColor\n        });\n      }\n      const v = [];\n      y.compose = function (l) {\n        a.compose(x);\n        I.pushUnique(v, l) && (l.prototype.alignDataLabel = u);\n      };\n    })(H || (H = {}));\n    return H;\n  });\n  M(a, \"Series/Bar/BarSeries.js\", [a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n      extend: x,\n      merge: C\n    } = I;\n    class z extends a {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n    }\n    z.defaultOptions = C(a.defaultOptions, {});\n    x(z.prototype, {\n      inverted: !0\n    });\n    y.registerSeriesType(\"bar\", z);\n    \"\";\n    return z;\n  });\n  M(a, \"Series/Scatter/ScatterSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 0.8em\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    };\n  });\n  M(a, \"Series/Scatter/ScatterSeries.js\", [a[\"Series/Scatter/ScatterSeriesDefaults.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        column: x,\n        line: C\n      } = y.seriesTypes,\n      {\n        addEvent: z,\n        extend: H,\n        merge: B\n      } = I;\n    class u extends C {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.data = void 0;\n      }\n      applyJitter() {\n        const a = this,\n          l = this.options.jitter,\n          p = this.points.length;\n        l && this.points.forEach(function (t, m) {\n          [\"x\", \"y\"].forEach(function (h, g) {\n            let e = \"plot\" + h.toUpperCase(),\n              w,\n              v;\n            if (l[h] && !t.isNull) {\n              var u = a[h + \"Axis\"];\n              v = l[h] * u.transA;\n              u && !u.isLog && (w = Math.max(0, t[e] - v), u = Math.min(u.len, t[e] + v), g = 1E4 * Math.sin(m + g * p), g -= Math.floor(g), t[e] = w + (u - w) * g, \"x\" === h && (t.clientX = t.plotX));\n            }\n          });\n        });\n      }\n      drawGraph() {\n        this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());\n      }\n    }\n    u.defaultOptions = B(C.defaultOptions, a);\n    H(u.prototype, {\n      drawTracker: x.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1\n    });\n    z(u, \"afterTranslate\", function () {\n      this.applyJitter();\n    });\n    y.registerSeriesType(\"scatter\", u);\n    return u;\n  });\n  M(a, \"Series/CenteredUtilities.js\", [a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        deg2rad: x\n      } = a,\n      {\n        fireEvent: C,\n        isNumber: z,\n        pick: H,\n        relativeLength: B\n      } = I;\n    var u;\n    (function (a) {\n      a.getCenter = function () {\n        var a = this.options,\n          p = this.chart;\n        const t = 2 * (a.slicedOffset || 0),\n          m = p.plotWidth - 2 * t,\n          h = p.plotHeight - 2 * t;\n        var g = a.center;\n        const e = Math.min(m, h),\n          w = a.thickness;\n        var v = a.size;\n        let u = a.innerSize || 0;\n        \"string\" === typeof v && (v = parseFloat(v));\n        \"string\" === typeof u && (u = parseFloat(u));\n        a = [H(g[0], \"50%\"), H(g[1], \"50%\"), H(v && 0 > v ? void 0 : a.size, \"100%\"), H(u && 0 > u ? void 0 : a.innerSize || 0, \"0%\")];\n        !p.angular || this instanceof y || (a[3] = 0);\n        for (g = 0; 4 > g; ++g) v = a[g], p = 2 > g || 2 === g && /%$/.test(v), a[g] = B(v, [m, h, e, a[2]][g]) + (p ? t : 0);\n        a[3] > a[2] && (a[3] = a[2]);\n        z(w) && 2 * w < a[2] && 0 < w && (a[3] = a[2] - 2 * w);\n        C(this, \"afterGetCenter\", {\n          positions: a\n        });\n        return a;\n      };\n      a.getStartAndEndRadians = function (a, p) {\n        a = z(a) ? a : 0;\n        p = z(p) && p > a && 360 > p - a ? p : a + 360;\n        return {\n          start: x * (a + -90),\n          end: x * (p + -90)\n        };\n      };\n    })(u || (u = {}));\n    \"\";\n    return u;\n  });\n  M(a, \"Series/Pie/PiePoint.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, y, I) {\n    const {\n        setAnimation: x\n      } = a,\n      {\n        addEvent: C,\n        defined: z,\n        extend: H,\n        isNumber: B,\n        pick: u,\n        relativeLength: v\n      } = I;\n    class l extends y {\n      constructor() {\n        super(...arguments);\n        this.series = this.options = this.labelDistance = void 0;\n      }\n      getConnectorPath() {\n        const a = this.labelPosition,\n          l = this.series.options.dataLabels,\n          m = this.connectorShapes;\n        let h = l.connectorShape;\n        m[h] && (h = m[h]);\n        return h.call(this, {\n          x: a.computed.x,\n          y: a.computed.y,\n          alignment: a.alignment\n        }, a.connectorPosition, l);\n      }\n      getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      }\n      haloPath(a) {\n        const l = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(l.x, l.y, l.r + a, l.r + a, {\n          innerR: l.r - 1,\n          start: l.start,\n          end: l.end,\n          borderRadius: l.borderRadius\n        });\n      }\n      init() {\n        super.init.apply(this, arguments);\n        this.name = u(this.name, \"Slice\");\n        const a = a => {\n          this.slice(\"select\" === a.type);\n        };\n        C(this, \"select\", a);\n        C(this, \"unselect\", a);\n        return this;\n      }\n      isValid() {\n        return B(this.y) && 0 <= this.y;\n      }\n      setVisible(a, l) {\n        const m = this.series,\n          h = m.chart,\n          g = m.options.ignoreHiddenPoint;\n        l = u(l, g);\n        a !== this.visible && (this.visible = this.options.visible = a = \"undefined\" === typeof a ? !this.visible : a, m.options.data[m.data.indexOf(this)] = this.options, [\"graphic\", \"dataLabel\", \"connector\"].forEach(e => {\n          if (this[e]) this[e][a ? \"show\" : \"hide\"](a);\n        }), this.legendItem && h.legend.colorizeItem(this, a), a || \"hover\" !== this.state || this.setState(\"\"), g && (m.isDirty = !0), l && h.redraw());\n      }\n      slice(a, l, m) {\n        const h = this.series;\n        x(m, h.chart);\n        u(l, !0);\n        this.sliced = this.options.sliced = z(a) ? a : !this.sliced;\n        h.options.data[h.data.indexOf(this)] = this.options;\n        this.graphic && this.graphic.animate(this.getTranslate());\n      }\n    }\n    H(l.prototype, {\n      connectorShapes: {\n        fixedOffset: function (a, l, m) {\n          const h = l.breakAt;\n          l = l.touchingSliceAt;\n          return [[\"M\", a.x, a.y], m.softConnector ? [\"C\", a.x + (\"left\" === a.alignment ? -5 : 5), a.y, 2 * h.x - l.x, 2 * h.y - l.y, h.x, h.y] : [\"L\", h.x, h.y], [\"L\", l.x, l.y]];\n        },\n        straight: function (a, l) {\n          l = l.touchingSliceAt;\n          return [[\"M\", a.x, a.y], [\"L\", l.x, l.y]];\n        },\n        crookedLine: function (a, l, m) {\n          const {\n            breakAt: h,\n            touchingSliceAt: g\n          } = l;\n          ({\n            series: l\n          } = this);\n          const [e, p, t] = l.center,\n            u = t / 2,\n            d = l.chart.plotWidth,\n            k = l.chart.plotLeft;\n          l = \"left\" === a.alignment;\n          const {\n            x: r,\n            y: q\n          } = a;\n          m.crookDistance ? (a = v(m.crookDistance, 1), a = l ? e + u + (d + k - e - u) * (1 - a) : k + (e - u) * a) : a = e + (p - q) * Math.tan((this.angle || 0) - Math.PI / 2);\n          m = [[\"M\", r, q]];\n          (l ? a <= r && a >= h.x : a >= r && a <= h.x) && m.push([\"L\", a, q]);\n          m.push([\"L\", h.x, h.y], [\"L\", g.x, g.y]);\n          return m;\n        }\n      }\n    });\n    return l;\n  });\n  M(a, \"Series/Pie/PieSeriesDefaults.js\", [], function () {\n    \"\";\n\n    return {\n      borderRadius: 3,\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        connectorShape: \"crookedLine\",\n        crookDistance: void 0,\n        distance: 30,\n        enabled: !0,\n        formatter: function () {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    };\n  });\n  M(a, \"Series/Pie/PieSeries.js\", [a[\"Series/CenteredUtilities.js\"], a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Globals.js\"], a[\"Series/Pie/PiePoint.js\"], a[\"Series/Pie/PieSeriesDefaults.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/Symbols.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z, H, B, u) {\n    const {\n      getStartAndEndRadians: v\n    } = a;\n    ({\n      noop: I\n    } = I);\n    const {\n      clamp: l,\n      extend: p,\n      fireEvent: t,\n      merge: m,\n      pick: h,\n      relativeLength: g\n    } = u;\n    class e extends z {\n      constructor() {\n        super(...arguments);\n        this.points = this.options = this.maxLabelDistance = this.data = this.center = void 0;\n      }\n      animate(a) {\n        const e = this,\n          g = e.points,\n          d = e.startAngleRad;\n        a || g.forEach(function (a) {\n          const g = a.graphic,\n            k = a.shapeArgs;\n          g && k && (g.attr({\n            r: h(a.startR, e.center && e.center[3] / 2),\n            start: d,\n            end: d\n          }), g.animate({\n            r: k.r,\n            start: k.start,\n            end: k.end\n          }, e.options.animation));\n        });\n      }\n      drawEmpty() {\n        const a = this.startAngleRad,\n          e = this.endAngleRad,\n          g = this.options;\n        let d, k;\n        0 === this.total && this.center ? (d = this.center[0], k = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(d, k, this.center[1] / 2, 0, a, e).addClass(\"highcharts-empty-series\").add(this.group)), this.graph.attr({\n          d: B.arc(d, k, this.center[2] / 2, 0, {\n            start: a,\n            end: e,\n            innerR: this.center[3] / 2\n          })\n        }), this.chart.styledMode || this.graph.attr({\n          \"stroke-width\": g.borderWidth,\n          fill: g.fillColor || \"none\",\n          stroke: g.color || \"#cccccc\"\n        })) : this.graph && (this.graph = this.graph.destroy());\n      }\n      drawPoints() {\n        const a = this.chart.renderer;\n        this.points.forEach(function (e) {\n          e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy());\n          e.graphic || (e.graphic = a[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);\n        });\n      }\n      generatePoints() {\n        super.generatePoints();\n        this.updateTotals();\n      }\n      getX(a, e, g) {\n        const d = this.center,\n          k = this.radii ? this.radii[g.index] || 0 : d[2] / 2;\n        a = Math.asin(l((a - d[1]) / (k + g.labelDistance), -1, 1));\n        return d[0] + (e ? -1 : 1) * Math.cos(a) * (k + g.labelDistance) + (0 < g.labelDistance ? (e ? -1 : 1) * this.options.dataLabels.padding : 0);\n      }\n      hasData() {\n        return !!this.processedXData.length;\n      }\n      redrawPoints() {\n        const a = this,\n          e = a.chart;\n        let g, d, k, h;\n        this.drawEmpty();\n        a.group && !e.styledMode && a.group.shadow(a.options.shadow);\n        a.points.forEach(function (l) {\n          const q = {};\n          d = l.graphic;\n          !l.isNull && d ? (h = l.shapeArgs, g = l.getTranslate(), e.styledMode || (k = a.pointAttribs(l, l.selected && \"select\")), l.delayedRendering ? (d.setRadialReference(a.center).attr(h).attr(g), e.styledMode || d.attr(k).attr({\n            \"stroke-linejoin\": \"round\"\n          }), l.delayedRendering = !1) : (d.setRadialReference(a.center), e.styledMode || m(!0, q, k), m(!0, q, h, g), d.animate(q)), d.attr({\n            visibility: l.visible ? \"inherit\" : \"hidden\"\n          }), d.addClass(l.getClassName(), !0)) : d && (l.graphic = d.destroy());\n        });\n      }\n      sortByAngle(a, e) {\n        a.sort(function (a, d) {\n          return \"undefined\" !== typeof a.angle && (d.angle - a.angle) * e;\n        });\n      }\n      translate(a) {\n        t(this, \"translate\");\n        this.generatePoints();\n        var e = this.options;\n        const l = e.slicedOffset,\n          d = l + (e.borderWidth || 0);\n        var k = v(e.startAngle, e.endAngle);\n        const m = this.startAngleRad = k.start;\n        k = (this.endAngleRad = k.end) - m;\n        const q = this.points,\n          p = e.dataLabels.distance;\n        e = e.ignoreHiddenPoint;\n        const b = q.length;\n        let f,\n          c,\n          n,\n          w = 0;\n        a || (this.center = a = this.getCenter());\n        for (c = 0; c < b; c++) {\n          n = q[c];\n          var u = m + w * k;\n          !n.isValid() || e && !n.visible || (w += n.percentage / 100);\n          var x = m + w * k;\n          var y = {\n            x: a[0],\n            y: a[1],\n            r: a[2] / 2,\n            innerR: a[3] / 2,\n            start: Math.round(1E3 * u) / 1E3,\n            end: Math.round(1E3 * x) / 1E3\n          };\n          n.shapeType = \"arc\";\n          n.shapeArgs = y;\n          n.labelDistance = h(n.options.dataLabels && n.options.dataLabels.distance, p);\n          n.labelDistance = g(n.labelDistance, y.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, n.labelDistance);\n          x = (x + u) / 2;\n          x > 1.5 * Math.PI ? x -= 2 * Math.PI : x < -Math.PI / 2 && (x += 2 * Math.PI);\n          n.slicedTranslation = {\n            translateX: Math.round(Math.cos(x) * l),\n            translateY: Math.round(Math.sin(x) * l)\n          };\n          y = Math.cos(x) * a[2] / 2;\n          f = Math.sin(x) * a[2] / 2;\n          n.tooltipPos = [a[0] + .7 * y, a[1] + .7 * f];\n          n.half = x < -Math.PI / 2 || x > Math.PI / 2 ? 1 : 0;\n          n.angle = x;\n          u = Math.min(d, n.labelDistance / 5);\n          n.labelPosition = {\n            natural: {\n              x: a[0] + y + Math.cos(x) * n.labelDistance,\n              y: a[1] + f + Math.sin(x) * n.labelDistance\n            },\n            computed: {},\n            alignment: 0 > n.labelDistance ? \"center\" : n.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: a[0] + y + Math.cos(x) * u,\n                y: a[1] + f + Math.sin(x) * u\n              },\n              touchingSliceAt: {\n                x: a[0] + y,\n                y: a[1] + f\n              }\n            }\n          };\n        }\n        t(this, \"afterTranslate\");\n      }\n      updateTotals() {\n        const a = this.points,\n          e = a.length,\n          g = this.options.ignoreHiddenPoint;\n        let d,\n          k,\n          h = 0;\n        for (d = 0; d < e; d++) k = a[d], !k.isValid() || g && !k.visible || (h += k.y);\n        this.total = h;\n        for (d = 0; d < e; d++) k = a[d], k.percentage = 0 < h && (k.visible || !g) ? k.y / h * 100 : 0, k.total = h;\n      }\n    }\n    e.defaultOptions = m(z.defaultOptions, C);\n    p(e.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawTracker: y.prototype.drawTracker,\n      getCenter: a.getCenter,\n      getSymbol: I,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: y.prototype.pointAttribs,\n      pointClass: L,\n      requireSorting: !1,\n      searchPoint: I,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    H.registerSeriesType(\"pie\", e);\n    return e;\n  });\n  M(a, \"Series/Pie/PieDataLabel.js\", [a[\"Core/Series/DataLabel.js\"], a[\"Core/Globals.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C) {\n    const {\n        noop: x\n      } = y,\n      {\n        distribute: H\n      } = I,\n      {\n        series: B\n      } = L,\n      {\n        arrayMax: u,\n        clamp: v,\n        defined: l,\n        merge: p,\n        pick: t,\n        relativeLength: m\n      } = C;\n    var h;\n    (function (g) {\n      function e() {\n        const a = this,\n          d = a.data,\n          e = a.chart,\n          g = a.options.dataLabels || {},\n          b = g.connectorPadding,\n          f = e.plotWidth,\n          c = e.plotHeight,\n          h = e.plotLeft,\n          m = Math.round(e.chartWidth / 3),\n          w = a.center,\n          v = w[2] / 2,\n          x = w[1],\n          y = [[], []],\n          z = [0, 0, 0, 0],\n          F = a.dataLabelPositioners;\n        let C, A, E, I, L, M, J, N, O, S, W, U;\n        a.visible && (g.enabled || a._hasPointLabels) && (d.forEach(function (a) {\n          a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n            width: \"auto\"\n          }).css({\n            width: \"auto\",\n            textOverflow: \"clip\"\n          }), a.dataLabel.shortened = !1);\n        }), B.prototype.drawDataLabels.apply(a), d.forEach(function (a) {\n          a.dataLabel && (a.visible ? (y[a.half].push(a), a.dataLabel._pos = null, !l(g.style.width) && !l(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > m && (a.dataLabel.css({\n            width: Math.round(.7 * m) + \"px\"\n          }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n        }), y.forEach((d, k) => {\n          const m = d.length,\n            n = [];\n          let q,\n            p = 0;\n          if (m) {\n            a.sortByAngle(d, k - .5);\n            if (0 < a.maxLabelDistance) {\n              var r = Math.max(0, x - v - a.maxLabelDistance);\n              q = Math.min(x + v + a.maxLabelDistance, e.plotHeight);\n              d.forEach(function (a) {\n                0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, x - v - a.labelDistance), a.bottom = Math.min(x + v + a.labelDistance, e.plotHeight), p = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n                  target: a.labelPosition.natural.y - a.top + p / 2,\n                  size: p,\n                  rank: a.y\n                }, n.push(a.distributeBox));\n              });\n              r = q + p - r;\n              H(n, r, r / 5);\n            }\n            for (W = 0; W < m; W++) {\n              C = d[W];\n              M = C.labelPosition;\n              I = C.dataLabel;\n              S = !1 === C.visible ? \"hidden\" : \"inherit\";\n              O = r = M.natural.y;\n              n && l(C.distributeBox) && (\"undefined\" === typeof C.distributeBox.pos ? S = \"hidden\" : (J = C.distributeBox.size, O = F.radialDistributionY(C)));\n              delete C.positionIndex;\n              if (g.justify) N = F.justify(C, v, w);else switch (g.alignTo) {\n                case \"connectors\":\n                  N = F.alignToConnectors(d, k, f, h);\n                  break;\n                case \"plotEdges\":\n                  N = F.alignToPlotEdges(I, k, f, h);\n                  break;\n                default:\n                  N = F.radialDistributionX(a, C, O, r);\n              }\n              I._attr = {\n                visibility: S,\n                align: M.alignment\n              };\n              U = C.options.dataLabels || {};\n              I._pos = {\n                x: N + t(U.x, g.x) + ({\n                  left: b,\n                  right: -b\n                }[M.alignment] || 0),\n                y: O + t(U.y, g.y) - I.getBBox().height / 2\n              };\n              M && (M.computed.x = N, M.computed.y = O);\n              t(g.crop, !0) && (L = I.getBBox().width, r = null, N - L < b && 1 === k ? (r = Math.round(L - N + b), z[3] = Math.max(r, z[3])) : N + L > f - b && 0 === k && (r = Math.round(N + L - f + b), z[1] = Math.max(r, z[1])), 0 > O - J / 2 ? z[0] = Math.max(Math.round(-O + J / 2), z[0]) : O + J / 2 > c && (z[2] = Math.max(Math.round(O + J / 2 - c), z[2])), I.sideOverflow = r);\n            }\n          }\n        }), 0 === u(z) || this.verifyDataLabelOverflow(z)) && (this.placeDataLabels(), this.points.forEach(function (b) {\n          U = p(g, b.options.dataLabels);\n          if (A = t(U.connectorWidth, 1)) {\n            let c;\n            E = b.connector;\n            if ((I = b.dataLabel) && I._pos && b.visible && 0 < b.labelDistance) {\n              S = I._attr.visibility;\n              if (c = !E) b.connector = E = e.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + b.colorIndex + (b.className ? \" \" + b.className : \"\")).add(a.dataLabelsGroup), e.styledMode || E.attr({\n                \"stroke-width\": A,\n                stroke: U.connectorColor || b.color || \"#666666\"\n              });\n              E[c ? \"attr\" : \"animate\"]({\n                d: b.getConnectorPath()\n              });\n              E.attr(\"visibility\", S);\n            } else E && (b.connector = E.destroy());\n          }\n        }));\n      }\n      function h() {\n        this.points.forEach(function (a) {\n          let d = a.dataLabel,\n            e;\n          d && a.visible && ((e = d._pos) ? (d.sideOverflow && (d._attr.width = Math.max(d.getBBox().width - d.sideOverflow, 0), d.css({\n            width: d._attr.width + \"px\",\n            textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n          }), d.shortened = !0), d.attr(d._attr), d[d.moved ? \"animate\" : \"attr\"](e), d.moved = !0) : d && d.attr({\n            y: -9999\n          }));\n          delete a.distributeBox;\n        }, this);\n      }\n      function y(a) {\n        let d = this.center,\n          e = this.options,\n          g = e.center,\n          b = e.minSize || 80,\n          f,\n          c = null !== e.size;\n        c || (null !== g[0] ? f = Math.max(d[2] - Math.max(a[1], a[3]), b) : (f = Math.max(d[2] - a[1] - a[3], b), d[0] += (a[3] - a[1]) / 2), null !== g[1] ? f = v(f, b, d[2] - Math.max(a[0], a[2])) : (f = v(f, b, d[2] - a[0] - a[2]), d[1] += (a[0] - a[2]) / 2), f < d[2] ? (d[2] = f, d[3] = Math.min(e.thickness ? Math.max(0, f - 2 * e.thickness) : Math.max(0, m(e.innerSize || 0, f)), f), this.translate(d), this.drawDataLabels && this.drawDataLabels()) : c = !0);\n        return c;\n      }\n      const z = [],\n        d = {\n          radialDistributionY: function (a) {\n            return a.top + a.distributeBox.pos;\n          },\n          radialDistributionX: function (a, d, e, g) {\n            return a.getX(e < d.top + 2 || e > d.bottom - 2 ? g : e, d.half, d);\n          },\n          justify: function (a, d, e) {\n            return e[0] + (a.half ? -1 : 1) * (d + a.labelDistance);\n          },\n          alignToPlotEdges: function (a, d, e, g) {\n            a = a.getBBox().width;\n            return d ? a + g : e - a - g;\n          },\n          alignToConnectors: function (a, d, e, g) {\n            let b = 0,\n              f;\n            a.forEach(function (a) {\n              f = a.dataLabel.getBBox().width;\n              f > b && (b = f);\n            });\n            return d ? b + g : e - b - g;\n          }\n        };\n      g.compose = function (g) {\n        a.compose(B);\n        C.pushUnique(z, g) && (g = g.prototype, g.dataLabelPositioners = d, g.alignDataLabel = x, g.drawDataLabels = e, g.placeDataLabels = h, g.verifyDataLabelOverflow = y);\n      };\n    })(h || (h = {}));\n    return h;\n  });\n  M(a, \"Extensions/OverlappingDataLabels.js\", [a[\"Core/Chart/Chart.js\"], a[\"Core/Utilities.js\"]], function (a, y) {\n    function x(a, l) {\n      let p,\n        t = !1;\n      a && (p = a.newOpacity, a.oldOpacity !== p && (a.alignAttr && a.placed ? (a[p ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), t = !0, a.alignAttr.opacity = p, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, function () {\n        l.styledMode || a.css({\n          pointerEvents: p ? \"auto\" : \"none\"\n        });\n      }), C(l, \"afterHideOverlappingLabel\")) : a.attr({\n        opacity: p\n      })), a.isOld = !0);\n      return t;\n    }\n    const {\n      addEvent: L,\n      fireEvent: C,\n      isArray: z,\n      isNumber: H,\n      objectEach: B,\n      pick: u\n    } = y;\n    L(a, \"render\", function () {\n      let a = this,\n        l = [];\n      (this.labelCollectors || []).forEach(function (a) {\n        l = l.concat(a());\n      });\n      (this.yAxis || []).forEach(function (a) {\n        a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && B(a.stacking.stacks, function (a) {\n          B(a, function (a) {\n            a.label && l.push(a.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (p) {\n        var t = p.options.dataLabels;\n        p.visible && (!1 !== t.enabled || p._hasPointLabels) && (t = m => m.forEach(h => {\n          h.visible && (z(h.dataLabels) ? h.dataLabels : h.dataLabel ? [h.dataLabel] : []).forEach(function (g) {\n            const e = g.options;\n            g.labelrank = u(e.labelrank, h.labelrank, h.shapeArgs && h.shapeArgs.height);\n            e.allowOverlap ? (g.oldOpacity = g.opacity, g.newOpacity = 1, x(g, a)) : l.push(g);\n          });\n        }), t(p.nodes || []), t(p.points));\n      });\n      this.hideOverlappingLabels(l);\n    });\n    a.prototype.hideOverlappingLabels = function (a) {\n      let l = this,\n        p = a.length,\n        t = l.renderer;\n      var m;\n      let h;\n      let g,\n        e,\n        w,\n        u = !1;\n      var v = function (a) {\n        let d, e;\n        var g;\n        let h = a.box ? 0 : a.padding || 0,\n          b = g = 0,\n          f,\n          c;\n        if (a && (!a.alignAttr || a.placed)) return d = a.alignAttr || {\n          x: a.attr(\"x\"),\n          y: a.attr(\"y\")\n        }, e = a.parentGroup, a.width || (g = a.getBBox(), a.width = g.width, a.height = g.height, g = t.fontMetrics(a.element).h), f = a.width - 2 * h, (c = {\n          left: \"0\",\n          center: \"0.5\",\n          right: \"1\"\n        }[a.alignValue]) ? b = +c * f : H(a.x) && Math.round(a.x) !== a.translateX && (b = a.x - a.translateX), {\n          x: d.x + (e.translateX || 0) + h - (b || 0),\n          y: d.y + (e.translateY || 0) + h - g,\n          width: a.width - 2 * h,\n          height: a.height - 2 * h\n        };\n      };\n      for (h = 0; h < p; h++) if (m = a[h]) m.oldOpacity = m.opacity, m.newOpacity = 1, m.absoluteBox = v(m);\n      a.sort(function (a, e) {\n        return (e.labelrank || 0) - (a.labelrank || 0);\n      });\n      for (h = 0; h < p; h++) for (e = (v = a[h]) && v.absoluteBox, m = h + 1; m < p; ++m) w = (g = a[m]) && g.absoluteBox, !e || !w || v === g || 0 === v.newOpacity || 0 === g.newOpacity || \"hidden\" === v.visibility || \"hidden\" === g.visibility || w.x >= e.x + e.width || w.x + w.width <= e.x || w.y >= e.y + e.height || w.y + w.height <= e.y || ((v.labelrank < g.labelrank ? v : g).newOpacity = 0);\n      a.forEach(function (a) {\n        x(a, l) && (u = !0);\n      });\n      u && C(l, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  M(a, \"Extensions/BorderRadius.js\", [a[\"Core/Defaults.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, y, I, L, C, z) {\n    const {\n      defaultOptions: x\n    } = a;\n    ({\n      seriesTypes: a\n    } = I);\n    const {\n        addEvent: B,\n        extend: u,\n        isObject: v,\n        merge: l,\n        relativeLength: p\n      } = z,\n      t = {\n        radius: 0,\n        scope: \"stack\",\n        where: void 0\n      },\n      m = (a, g) => {\n        v(a) || (a = {\n          radius: a || 0\n        });\n        return l(t, g, a);\n      };\n    if (-1 === L.symbolCustomAttribs.indexOf(\"borderRadius\")) {\n      L.symbolCustomAttribs.push(\"borderRadius\", \"brBoxHeight\", \"brBoxY\");\n      const h = C.prototype.symbols.arc;\n      C.prototype.symbols.arc = function (a, g, l, m, d = {}) {\n        a = h(a, g, l, m, d);\n        const {\n          innerR: e = 0,\n          r = l,\n          start: q = 0,\n          end: t = 0\n        } = d;\n        if (d.open || !d.borderRadius) return a;\n        l = t - q;\n        g = Math.sin(l / 2);\n        d = Math.max(Math.min(p(d.borderRadius || 0, r - e), (r - e) / 2, r * g / (1 + g)), 0);\n        l = Math.min(d, l / Math.PI * 2 * e);\n        for (g = a.length - 1; g--;) {\n          {\n            let e = void 0,\n              h = void 0,\n              k = void 0;\n            m = a;\n            var b = g,\n              f = 1 < g ? l : d,\n              c = m[b],\n              n = m[b + 1];\n            \"Z\" === n[0] && (n = m[0]);\n            \"M\" !== c[0] && \"L\" !== c[0] || \"A\" !== n[0] ? \"A\" !== c[0] || \"M\" !== n[0] && \"L\" !== n[0] || (k = n, h = c) : (k = c, h = n, e = !0);\n            if (k && h && h.params) {\n              c = h[1];\n              var w = h[5];\n              n = h.params;\n              const {\n                start: a,\n                end: d,\n                cx: g,\n                cy: l\n              } = n;\n              var u = w ? c - f : c + f;\n              const p = u ? Math.asin(f / u) : 0;\n              w = w ? p : -p;\n              u *= Math.cos(p);\n              e ? (n.start = a + w, k[1] = g + u * Math.cos(a), k[2] = l + u * Math.sin(a), m.splice(b + 1, 0, [\"A\", f, f, 0, 0, 1, g + c * Math.cos(n.start), l + c * Math.sin(n.start)])) : (n.end = d - w, h[6] = g + c * Math.cos(n.end), h[7] = l + c * Math.sin(n.end), m.splice(b + 1, 0, [\"A\", f, f, 0, 0, 1, g + u * Math.cos(d), l + u * Math.sin(d)]));\n              h[4] = Math.abs(n.end - n.start) < Math.PI ? 0 : 1;\n            }\n          }\n        }\n        return a;\n      };\n      const g = C.prototype.symbols.roundedRect;\n      C.prototype.symbols.roundedRect = function (a, h, l, m, d = {}) {\n        const e = g(a, h, l, m, d),\n          {\n            r: p = 0,\n            brBoxHeight: q = m,\n            brBoxY: t = h\n          } = d;\n        var b = h - t,\n          f = t + q - (h + m);\n        d = -.1 < b - p ? 0 : p;\n        const c = -.1 < f - p ? 0 : p;\n        var n = Math.max(d && b, 0);\n        const u = Math.max(c && f, 0);\n        f = [a + d, h];\n        b = [a + l - d, h];\n        const w = [a + l, h + d],\n          v = [a + l, h + m - c],\n          x = [a + l - c, h + m],\n          y = [a + c, h + m],\n          z = [a, h + m - c],\n          B = [a, h + d];\n        if (n) {\n          const a = Math.sqrt(Math.pow(d, 2) - Math.pow(d - n, 2));\n          f[0] -= a;\n          b[0] += a;\n          w[1] = B[1] = h + d - n;\n        }\n        m < d - n && (n = Math.sqrt(Math.pow(d, 2) - Math.pow(d - n - m, 2)), w[0] = v[0] = a + l - d + n, x[0] = Math.min(w[0], x[0]), y[0] = Math.max(v[0], y[0]), z[0] = B[0] = a + d - n, w[1] = B[1] = h + m);\n        u && (n = Math.sqrt(Math.pow(c, 2) - Math.pow(c - u, 2)), x[0] += n, y[0] -= n, v[1] = z[1] = h + m - c + u);\n        m < c - u && (m = Math.sqrt(Math.pow(c, 2) - Math.pow(c - u - m, 2)), w[0] = v[0] = a + l - c + m, b[0] = Math.min(w[0], b[0]), f[0] = Math.max(v[0], f[0]), z[0] = B[0] = a + c - m, v[1] = z[1] = h);\n        e.length = 0;\n        e.push([\"M\", ...f], [\"L\", ...b], [\"A\", d, d, 0, 0, 1, ...w], [\"L\", ...v], [\"A\", c, c, 0, 0, 1, ...x], [\"L\", ...y], [\"A\", c, c, 0, 0, 1, ...z], [\"L\", ...B], [\"A\", d, d, 0, 0, 1, ...f], [\"Z\"]);\n        return e;\n      };\n      B(a.pie, \"afterTranslate\", function () {\n        const a = m(this.options.borderRadius);\n        for (const e of this.points) {\n          const g = e.shapeArgs;\n          g && (g.borderRadius = p(a.radius, (g.r || 0) - (g.innerR || 0)));\n        }\n      });\n      B(y, \"afterColumnTranslate\", function () {\n        var a, g;\n        if (this.options.borderRadius && (!this.chart.is3d || !this.chart.is3d())) {\n          const {\n              options: e,\n              yAxis: r\n            } = this,\n            q = \"percent\" === e.stacking;\n          var h = null === (g = null === (a = x.plotOptions) || void 0 === a ? void 0 : a[this.type]) || void 0 === g ? void 0 : g.borderRadius;\n          a = m(e.borderRadius, v(h) ? h : {});\n          g = r.options.reversed;\n          for (const k of this.points) if (({\n            shapeArgs: h\n          } = k), \"roundedRect\" === k.shapeType && h) {\n            const {\n              width: b = 0,\n              height: f = 0,\n              y: c = 0\n            } = h;\n            var l = c,\n              d = f;\n            \"stack\" === a.scope && k.stackTotal && (l = r.translate(q ? 100 : k.stackTotal, !1, !0, !1, !0), d = r.translate(e.threshold || 0, !1, !0, !1, !0), d = this.crispCol(0, Math.min(l, d), 0, Math.abs(l - d)), l = d.y, d = d.height);\n            const m = -1 === (k.negative ? -1 : 1) * (g ? -1 : 1);\n            let t = a.where;\n            !t && this.is(\"waterfall\") && Math.abs((k.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (t = \"all\");\n            t || (t = \"end\");\n            const v = Math.min(p(a.radius, b), b / 2, \"all\" === t ? f / 2 : Infinity) || 0;\n            \"end\" === t && (m && (l -= v), d += v);\n            u(h, {\n              brBoxHeight: d,\n              brBoxY: l,\n              r: v\n            });\n          }\n        }\n      }, {\n        order: 9\n      });\n    }\n    y = {\n      optionsToObject: m\n    };\n    \"\";\n    return y;\n  });\n  M(a, \"Core/Responsive.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    const {\n      diffObjects: x,\n      extend: I,\n      find: L,\n      merge: C,\n      pick: z,\n      uniqueKey: H\n    } = a;\n    var B;\n    (function (u) {\n      function v(a, l) {\n        const h = a.condition;\n        (h.callback || function () {\n          return this.chartWidth <= z(h.maxWidth, Number.MAX_VALUE) && this.chartHeight <= z(h.maxHeight, Number.MAX_VALUE) && this.chartWidth >= z(h.minWidth, 0) && this.chartHeight >= z(h.minHeight, 0);\n        }).call(this) && l.push(a._id);\n      }\n      function l(a, l) {\n        const h = this.options.responsive;\n        var g = this.currentResponsive;\n        let e = [];\n        !l && h && h.rules && h.rules.forEach(a => {\n          \"undefined\" === typeof a._id && (a._id = H());\n          this.matchResponsiveRule(a, e);\n        }, this);\n        l = C(...e.map(a => L((h || {}).rules || [], e => e._id === a)).map(a => a && a.chartOptions));\n        l.isResponsiveOptions = !0;\n        e = e.toString() || void 0;\n        e !== (g && g.ruleIds) && (g && this.update(g.undoOptions, a, !0), e ? (g = x(l, this.options, !0, this.collectionsWithUpdate), g.isResponsiveOptions = !0, this.currentResponsive = {\n          ruleIds: e,\n          mergedOptions: l,\n          undoOptions: g\n        }, this.update(l, a, !0)) : this.currentResponsive = void 0);\n      }\n      const p = [];\n      u.compose = function (t) {\n        a.pushUnique(p, t) && I(t.prototype, {\n          matchResponsiveRule: v,\n          setResponsive: l\n        });\n        return t;\n      };\n    })(B || (B = {}));\n    \"\";\n    \"\";\n    return B;\n  });\n  M(a, \"masters/highcharts.src.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"], a[\"Core/Defaults.js\"], a[\"Core/Animation/Fx.js\"], a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Renderer/HTML/AST.js\"], a[\"Core/Templating.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Renderer/HTML/HTMLElement.js\"], a[\"Core/Renderer/HTML/HTMLRenderer.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Axis/DateTimeAxis.js\"], a[\"Core/Axis/LogarithmicAxis.js\"], a[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Tooltip.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Pointer.js\"], a[\"Core/Legend/Legend.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Axis/Stacking/StackingAxis.js\"], a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Series/Column/ColumnSeries.js\"], a[\"Series/Column/ColumnDataLabel.js\"], a[\"Series/Pie/PieSeries.js\"], a[\"Series/Pie/PieDataLabel.js\"], a[\"Core/Series/DataLabel.js\"], a[\"Core/Responsive.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Time.js\"]], function (a, y, I, L, C, z, H, B, u, v, l, p, t, m, h, g, e, w, E, F, d, k, r, q, G, b, f, c, n, M, D, K, U, T) {\n    a.animate = C.animate;\n    a.animObject = C.animObject;\n    a.getDeferredAnimation = C.getDeferredAnimation;\n    a.setAnimation = C.setAnimation;\n    a.stop = C.stop;\n    a.timers = L.timers;\n    a.AST = z;\n    a.Axis = t;\n    a.Chart = k;\n    a.chart = k.chart;\n    a.Fx = L;\n    a.Legend = d;\n    a.PlotLineOrBand = g;\n    a.Point = E;\n    a.Pointer = F;\n    a.Series = G;\n    a.StackItem = q;\n    a.SVGElement = u;\n    a.SVGRenderer = v;\n    a.Templating = H;\n    a.Tick = e;\n    a.Time = T;\n    a.Tooltip = w;\n    a.Color = U;\n    a.color = U.parse;\n    p.compose(v);\n    l.compose(u);\n    F.compose(k);\n    d.compose(k);\n    a.defaultOptions = I.defaultOptions;\n    a.getOptions = I.getOptions;\n    a.time = I.defaultTime;\n    a.setOptions = I.setOptions;\n    a.dateFormat = H.dateFormat;\n    a.format = H.format;\n    a.numberFormat = H.numberFormat;\n    a.addEvent = y.addEvent;\n    a.arrayMax = y.arrayMax;\n    a.arrayMin = y.arrayMin;\n    a.attr = y.attr;\n    a.clearTimeout = y.clearTimeout;\n    a.correctFloat = y.correctFloat;\n    a.createElement = y.createElement;\n    a.css = y.css;\n    a.defined = y.defined;\n    a.destroyObjectProperties = y.destroyObjectProperties;\n    a.discardElement = y.discardElement;\n    a.distribute = B.distribute;\n    a.erase = y.erase;\n    a.error = y.error;\n    a.extend = y.extend;\n    a.extendClass = y.extendClass;\n    a.find = y.find;\n    a.fireEvent = y.fireEvent;\n    a.getMagnitude = y.getMagnitude;\n    a.getStyle = y.getStyle;\n    a.inArray = y.inArray;\n    a.isArray = y.isArray;\n    a.isClass = y.isClass;\n    a.isDOMElement = y.isDOMElement;\n    a.isFunction = y.isFunction;\n    a.isNumber = y.isNumber;\n    a.isObject = y.isObject;\n    a.isString = y.isString;\n    a.keys = y.keys;\n    a.merge = y.merge;\n    a.normalizeTickInterval = y.normalizeTickInterval;\n    a.objectEach = y.objectEach;\n    a.offset = y.offset;\n    a.pad = y.pad;\n    a.pick = y.pick;\n    a.pInt = y.pInt;\n    a.relativeLength = y.relativeLength;\n    a.removeEvent = y.removeEvent;\n    a.seriesType = b.seriesType;\n    a.splat = y.splat;\n    a.stableSort = y.stableSort;\n    a.syncTimeout = y.syncTimeout;\n    a.timeUnits = y.timeUnits;\n    a.uniqueKey = y.uniqueKey;\n    a.useSerialIds = y.useSerialIds;\n    a.wrap = y.wrap;\n    c.compose(f);\n    D.compose(G);\n    m.compose(t);\n    h.compose(t);\n    M.compose(n);\n    g.compose(t);\n    K.compose(k);\n    r.compose(t, k, G);\n    w.compose(F);\n    return a;\n  });\n  a[\"masters/highcharts.src.js\"]._modules = a;\n  return a[\"masters/highcharts.src.js\"];\n});\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/highcharts/highcharts.js?");

/***/ }),

/***/ "./src/api/index.js":
/*!**************************!*\
  !*** ./src/api/index.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nvar api = {\n  get: function () {\n    var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, options) {\n      var res, data;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(url, options);\n          case 2:\n            res = _context.sent;\n            _context.next = 5;\n            return res.json();\n          case 5:\n            data = _context.sent;\n            return _context.abrupt(\"return\", data);\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    function get(_x, _x2) {\n      return _get.apply(this, arguments);\n    }\n    return get;\n  }(),\n  post: function () {\n    var _post = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url, body) {\n      var options, res, data;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            options = {\n              headers: {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json'\n              },\n              method: \"POST\",\n              body: JSON.stringify(body)\n            };\n            _context2.next = 3;\n            return fetch(url, options);\n          case 3:\n            res = _context2.sent;\n            _context2.next = 6;\n            return res.json();\n          case 6:\n            data = _context2.sent;\n            return _context2.abrupt(\"return\", data);\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    function post(_x3, _x4) {\n      return _post.apply(this, arguments);\n    }\n    return post;\n  }()\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (api);\n\n//# sourceURL=webpack://my-webpack-project/./src/api/index.js?");

/***/ }),

/***/ "./src/environments/environment.js":
/*!*****************************************!*\
  !*** ./src/environments/environment.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   environment: () => (/* binding */ environment)\n/* harmony export */ });\nvar environment = {\n  apiBackend: {\n    report: 'https://cdp-reporting.admicro.vn/api/v1/report/public/get-by-id/{REPORT_ID}',\n    chart: 'https://cdp-reporting.admicro.vn/api/v1/chart/public/query-data-by-condition/{CHART_ID}'\n  },\n  typeColor: [{\n    value: '',\n    color: \"\",\n    typeButton: \"button\"\n  }, {\n    value: '#3386C9',\n    color: \"#3386C9\",\n    typeButton: \"button\"\n  }, {\n    value: '#88BF4D',\n    color: \"#88BF4D\",\n    typeButton: \"button\"\n  }, {\n    value: '#A989C5',\n    color: \"#A989C5\",\n    typeButton: \"button\"\n  }, {\n    value: '#EF8C8C',\n    color: \"#EF8C8C\",\n    typeButton: \"button\"\n  }, {\n    value: '#F9D45C',\n    color: \"#F9D45C\",\n    typeButton: \"button\"\n  }, {\n    value: '#F2A86F',\n    color: \"#F2A86F\",\n    typeButton: \"button\"\n  }, {\n    value: '#98D9D9',\n    color: \"#98D9D9\",\n    typeButton: \"button\"\n  }, {\n    value: '#7172AD',\n    color: \"#7172AD\",\n    typeButton: \"button\"\n  }, {\n    value: '#51528D',\n    color: \"#51528D\",\n    typeButton: \"button\"\n  }, {\n    value: '#69C8C8',\n    color: \"#69C8C8\",\n    typeButton: \"button\"\n  }, {\n    value: '#ED9935',\n    color: \"#ED9935\",\n    typeButton: \"button\"\n  }, {\n    value: '#F7C41F',\n    color: \"#F7C41F\",\n    typeButton: \"button\"\n  }, {\n    value: '#E75454',\n    color: \"#E75454\",\n    typeButton: \"button\"\n  }, {\n    value: '#C7EAEA',\n    color: \"#C7EAEA\",\n    typeButton: \"button\"\n  }, {\n    value: '#689636',\n    color: \"#689636\",\n    typeButton: \"button\"\n  }, {\n    value: '#F767A9',\n    color: \"#F767A9\",\n    typeButton: \"button\"\n  }]\n};\n\n//# sourceURL=webpack://my-webpack-project/./src/environments/environment.js?");

/***/ }),

/***/ "./src/errors/ApiNotFoundError.js":
/*!****************************************!*\
  !*** ./src/errors/ApiNotFoundError.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar ApiNotFoundError = /*#__PURE__*/function (_Error) {\n  _inherits(ApiNotFoundError, _Error);\n  var _super = _createSuper(ApiNotFoundError);\n  function ApiNotFoundError(message) {\n    var _this;\n    _classCallCheck(this, ApiNotFoundError);\n    _this = _super.call(this, message);\n    _this.name = \"API not found error\";\n    return _this;\n  }\n  return _createClass(ApiNotFoundError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ApiNotFoundError);\n\n//# sourceURL=webpack://my-webpack-project/./src/errors/ApiNotFoundError.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_highcharts_pie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/highcharts/pie */ \"./src/modules/highcharts/pie.js\");\n/* harmony import */ var _modules_highcharts_bar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/highcharts/bar */ \"./src/modules/highcharts/bar.js\");\n/* harmony import */ var _modules_report_report__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/report/report */ \"./src/modules/report/report.js\");\n/* harmony import */ var _modules_tables_table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/tables/table */ \"./src/modules/tables/table.js\");\n/* harmony import */ var _modules_grid_stack_grid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/grid-stack/grid */ \"./src/modules/grid-stack/grid.js\");\n\n\n\n\n\n__webpack_require__.g.reportDashBoard = _modules_report_report__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n__webpack_require__.g.grid = _modules_grid_stack_grid__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n__webpack_require__.g.ChartPie = _modules_highcharts_pie__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n__webpack_require__.g.ChartBar = _modules_highcharts_bar__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n__webpack_require__.g.ChartTable = _modules_tables_table__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n\n//# sourceURL=webpack://my-webpack-project/./src/index.js?");

/***/ }),

/***/ "./src/modules/grid-stack/grid.js":
/*!****************************************!*\
  !*** ./src/modules/grid-stack/grid.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var gridstack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gridstack */ \"./node_modules/gridstack/dist/gridstack.js\");\n\nvar grid = {\n  init: function init() {\n    gridstack__WEBPACK_IMPORTED_MODULE_0__.GridStack.init({\n      animate: true,\n      placeholderClass: \"grid-stack-placeholder\",\n      placeholderText: \"\",\n      \"float\": false,\n      staticGrid: true,\n      column: 12,\n      alwaysShowResizeHandle: false,\n      cellHeight: 80\n    });\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (grid);\n\n//# sourceURL=webpack://my-webpack-project/./src/modules/grid-stack/grid.js?");

/***/ }),

/***/ "./src/modules/highcharts/bar.js":
/*!***************************************!*\
  !*** ./src/modules/highcharts/bar.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../api */ \"./src/api/index.js\");\n/* harmony import */ var _errors_ApiNotFoundError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/ApiNotFoundError */ \"./src/errors/ApiNotFoundError.js\");\n/* harmony import */ var highcharts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! highcharts */ \"./node_modules/highcharts/highcharts.js\");\n/* harmony import */ var highcharts__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(highcharts__WEBPACK_IMPORTED_MODULE_2__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\nvar ChartBar = {\n  init: function init() {\n    return {\n      apiUrl: '',\n      chartOptions: {\n        title: {\n          text: 'Alo 123123123',\n          align: 'right'\n        },\n        tooltip: {\n          valueSuffix: ' (1000 MT)'\n        }\n      }\n    };\n  },\n  drawAt: function () {\n    var _drawAt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(whichChart, elementId) {\n      var apiUrl, chartOptions, data;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            apiUrl = whichChart.apiUrl, chartOptions = whichChart.chartOptions;\n            _context.prev = 1;\n            if (apiUrl) {\n              _context.next = 4;\n              break;\n            }\n            throw new _errors_ApiNotFoundError__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Bar chart api url không được để trống');\n          case 4:\n            _context.next = 6;\n            return _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(apiUrl);\n          case 6:\n            data = _context.sent;\n            console.log('data', data);\n            console.log('elementId', elementId);\n            // @ts-ignore\n            highcharts__WEBPACK_IMPORTED_MODULE_2___default().chart(elementId, _objectSpread({\n              chart: {\n                type: 'column'\n              },\n              subtitle: {\n                text: 'Source: <a target=\"_blank\" ' + 'href=\"https://www.indexmundi.com/agriculture/?commodity=corn\">indexmundi</a>',\n                align: 'left'\n              },\n              xAxis: {\n                categories: ['USA', 'China', 'Brazil', 'EU', 'India', 'Russia'],\n                crosshair: true,\n                accessibility: {\n                  description: 'Countries'\n                }\n              },\n              yAxis: {\n                min: 0,\n                title: {\n                  text: '1000 metric tons (MT)'\n                }\n              },\n              plotOptions: {\n                column: {\n                  pointPadding: 0.2,\n                  borderWidth: 0\n                }\n              },\n              series: data\n            }, chartOptions));\n            _context.next = 15;\n            break;\n          case 12:\n            _context.prev = 12;\n            _context.t0 = _context[\"catch\"](1);\n            console.error(_context.t0);\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[1, 12]]);\n    }));\n    function drawAt(_x, _x2) {\n      return _drawAt.apply(this, arguments);\n    }\n    return drawAt;\n  }()\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChartBar);\n\n//# sourceURL=webpack://my-webpack-project/./src/modules/highcharts/bar.js?");

/***/ }),

/***/ "./src/modules/highcharts/pie.js":
/*!***************************************!*\
  !*** ./src/modules/highcharts/pie.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../api */ \"./src/api/index.js\");\n/* harmony import */ var _errors_ApiNotFoundError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/ApiNotFoundError */ \"./src/errors/ApiNotFoundError.js\");\n/* harmony import */ var highcharts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! highcharts */ \"./node_modules/highcharts/highcharts.js\");\n/* harmony import */ var highcharts__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(highcharts__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _environments_environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../environments/environment */ \"./src/environments/environment.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\nvar dataResult = {\n  data: [],\n  schema: []\n};\nvar chartConfig = {\n  xAxisData: [],\n  yAxisData: [],\n  legendData: [],\n  valueData: [],\n  pieData: [],\n  colorChartPie: [],\n  showDataLabel: false,\n  showLegend: true,\n  configLegendPie: [],\n  optionLegend: 'bottom',\n  goalLineData: {\n    enabled: false,\n    value: 0\n  }\n};\nvar chartOptions = {\n  chart: {\n    plotBackgroundColor: null,\n    plotBorderWidth: null,\n    plotShadow: false,\n    type: 'pie',\n    events: {}\n  },\n  title: {\n    text: '',\n    align: 'center',\n    verticalAlign: 'middle',\n    y: 0\n  },\n  credits: {\n    enabled: false\n  },\n  tooltip: {},\n  accessibility: {\n    point: {\n      valueSuffix: '%'\n    }\n  },\n  plotOptions: {\n    series: {},\n    pie: {\n      allowPointSelect: true,\n      cursor: 'pointer',\n      dataLabels: {\n        enabled: false,\n        formatter: function formatter() {}\n      },\n      showInLegend: false\n    },\n    startAngle: -90,\n    endAngle: -180,\n    center: [50, 50],\n    size: '100%'\n  },\n  legend: {\n    enabled: true,\n    itemMarginBottom: 7,\n    layout: 'horizontal',\n    align: 'center',\n    verticalAlign: 'bottom'\n  },\n  series: [],\n  exporting: {\n    enabled: false // hide button\n  }\n};\n\nvar defaultColor = _environments_environment__WEBPACK_IMPORTED_MODULE_3__.environment.typeColor;\nvar apiUrl = _environments_environment__WEBPACK_IMPORTED_MODULE_3__.environment.apiBackend.chart;\nvar ChartPie = {\n  init: function init() {\n    return {\n      chartId: '',\n      apiUrl: ''\n    };\n  },\n  //actions\n  drawAt: function () {\n    var _drawAt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(chartId) {\n      var body, data;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            apiUrl = apiUrl.replace('{CHART_ID}', chartId);\n            body = {\n              filters: []\n            };\n            _context.prev = 2;\n            _context.next = 5;\n            return _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(apiUrl, body);\n          case 5:\n            data = _context.sent;\n            if ((data === null || data === void 0 ? void 0 : data.status) === 1) {\n              ChartPie.handleData(data.chart, chartId);\n            }\n            _context.next = 12;\n            break;\n          case 9:\n            _context.prev = 9;\n            _context.t0 = _context[\"catch\"](2);\n            console.error(_context.t0);\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[2, 9]]);\n    }));\n    function drawAt(_x) {\n      return _drawAt.apply(this, arguments);\n    }\n    return drawAt;\n  }(),\n  handleData: function handleData(result, chartId) {\n    var _result$data, _result$schema, _result$config, _result$config$chart, _result$config2, _result$config3, _result$config4, _result$config$chart$, _result$config5, _result$config$chart$2, _result$config6, _result$config$chart$3, _result$config7;\n    dataResult.data = (_result$data = result === null || result === void 0 ? void 0 : result.data) !== null && _result$data !== void 0 ? _result$data : [];\n    dataResult.schema = (_result$schema = result === null || result === void 0 ? void 0 : result.schema) !== null && _result$schema !== void 0 ? _result$schema : [];\n    chartConfig.legendData = result === null || result === void 0 || (_result$config = result.config) === null || _result$config === void 0 || (_result$config = _result$config.chart) === null || _result$config === void 0 ? void 0 : _result$config.legendData;\n    chartConfig.optionLegend = result === null || result === void 0 || (_result$config$chart = result.config.chart) === null || _result$config$chart === void 0 ? void 0 : _result$config$chart.optionLegend;\n    chartConfig.valueData = result === null || result === void 0 || (_result$config2 = result.config) === null || _result$config2 === void 0 || (_result$config2 = _result$config2.chart) === null || _result$config2 === void 0 ? void 0 : _result$config2.valueData;\n    chartConfig.showLegend = result === null || result === void 0 || (_result$config3 = result.config) === null || _result$config3 === void 0 || (_result$config3 = _result$config3.chart) === null || _result$config3 === void 0 ? void 0 : _result$config3.showLegend;\n    chartConfig.showDataLabel = result === null || result === void 0 || (_result$config4 = result.config) === null || _result$config4 === void 0 || (_result$config4 = _result$config4.chart) === null || _result$config4 === void 0 ? void 0 : _result$config4.showDataLabel;\n    chartConfig.pieData = (_result$config$chart$ = result === null || result === void 0 || (_result$config5 = result.config) === null || _result$config5 === void 0 || (_result$config5 = _result$config5.chart) === null || _result$config5 === void 0 ? void 0 : _result$config5.pieData) !== null && _result$config$chart$ !== void 0 ? _result$config$chart$ : [];\n    chartConfig.colorChartPie = (_result$config$chart$2 = result === null || result === void 0 || (_result$config6 = result.config) === null || _result$config6 === void 0 || (_result$config6 = _result$config6.chart) === null || _result$config6 === void 0 ? void 0 : _result$config6.colorChartPie) !== null && _result$config$chart$2 !== void 0 ? _result$config$chart$2 : [];\n    chartConfig.configLegendPie = (_result$config$chart$3 = result === null || result === void 0 || (_result$config7 = result.config) === null || _result$config7 === void 0 || (_result$config7 = _result$config7.chart) === null || _result$config7 === void 0 ? void 0 : _result$config7.configLegendPie) !== null && _result$config$chart$3 !== void 0 ? _result$config$chart$3 : [];\n    var data = dataResult.data;\n    var schema = dataResult.schema;\n    var xAxisData = chartConfig.legendData ? chartConfig.legendData[0] : null;\n    var yAxisData = chartConfig.valueData ? chartConfig.valueData : null;\n    var xSchema = schema ? schema.find(function (e) {\n      return xAxisData && (xAxisData === null || xAxisData === void 0 ? void 0 : xAxisData.fieldAlias) === (e === null || e === void 0 ? void 0 : e.field_alias);\n    }) : null;\n    var dataField = null;\n    if (xAxisData == null || yAxisData == null || xSchema == null) {\n      return;\n    }\n    chartOptions.legend.layout = (chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.optionLegend) !== 'bottom' && typeof (chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.optionLegend) !== 'undefined' ? 'vertical' : 'horizontal';\n    chartOptions.legend.align = (chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.optionLegend) !== 'bottom' && typeof (chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.optionLegend) !== 'undefined' ? chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.optionLegend : 'center';\n    chartOptions.legend.verticalAlign = (chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.optionLegend) !== 'bottom' && typeof (chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.optionLegend) !== 'undefined' ? 'middle' : 'bottom';\n    chartOptions.legend.enabled = chartConfig.showLegend;\n    chartOptions.plotOptions.pie.showInLegend = chartConfig.showLegend;\n    chartOptions.plotOptions.pie.dataLabels.enabled = chartConfig.showDataLabel;\n    chartOptions.series = [];\n    data.sort(function (a, b) {\n      if (chartConfig.configLegendPie) {\n        var nameA = chartConfig.configLegendPie.find(function (legend) {\n          return legend.name === a[schema[0].field_alias];\n        });\n        var nameB = chartConfig.configLegendPie.find(function (legend) {\n          return legend.name === b[schema[0].field_alias];\n        });\n        if (nameA && nameB) {\n          return chartConfig.configLegendPie.indexOf(nameA) - chartConfig.configLegendPie.indexOf(nameB);\n        }\n        return 0;\n      }\n    });\n    dataField = data;\n    if (chartConfig.configLegendPie) {\n      data.forEach(function (value, index) {\n        var _chartConfig$configLe;\n        if (!((_chartConfig$configLe = chartConfig.configLegendPie[index]) !== null && _chartConfig$configLe !== void 0 && _chartConfig$configLe.color) && chartConfig.configLegendPie[index]) {\n          var colorIndex = Number(index) % (defaultColor.length - 1); // Lấy vị trí của màu tương ứng\n          var color = defaultColor[colorIndex + 1]; // Lấy mã màu từ mảng colors\n          if (Number(index) > defaultColor.length - 2) {\n            chartConfig.configLegendPie[index].color = randomColor(defaultColor);\n          } else {\n            chartConfig.configLegendPie[index].color = color.value;\n          }\n        }\n      });\n    }\n    var mergedArray = data.map(function (item, index) {\n      if (!data[index].color) {\n        var colorIndex = Number(index) % (defaultColor.length - 1); // Lấy vị trí của màu tương ứng\n        var color = defaultColor[colorIndex + 1]; // Lấy mã màu từ mảng colors\n        if (Number(index) > defaultColor.length - 2) {\n          data[index].color = randomColor(defaultColor);\n        } else {\n          data[index].color = color.value;\n        }\n      }\n      var name = item[schema[0].field_alias];\n      var configItem = chartConfig.configLegendPie ? chartConfig.configLegendPie.find(function (config) {\n        return config.name === name;\n      }) : null;\n      return _objectSpread(_objectSpread({}, item), {}, {\n        name: configItem ? configItem.name : null,\n        color: configItem ? configItem.color : item.color,\n        customLabel: configItem ? configItem.customLabel : null\n      });\n    });\n    dataField = mergedArray;\n\n    // tslint:disable-next-line:one-variable-per-declaration\n    var yAxis = yAxisData[0],\n      // tslint:disable-next-line:prefer-const\n      ySchema = schema.find(function (item) {\n        return item.field_alias === yAxis.fieldAlias;\n      });\n    var seriesData = {\n      // name: getFieldName(yAxis),\n      colorByPoint: true,\n      data: [],\n      color: undefined,\n      type: 'pie',\n      innerSize: '50%'\n    };\n    // tslint:disable-next-line:forin\n    for (var z in data) {\n      if (!data[z].color) {\n        var colorIndex = Number(z) % (defaultColor.length - 1); // Lấy vị trí của màu tương ứng\n        var color = defaultColor[colorIndex + 1]; // Lấy mã màu từ mảng colors\n        if (Number(z) > defaultColor.length - 2) {\n          data[z].color = randomColor(defaultColor);\n        } else {\n          data[z].color = color.value;\n        }\n      }\n      if (typeof dataField !== 'undefined') {\n        var _dataField$z, _dataField$z2, _dataField$z3, _data$z, _dataField$z$name;\n        seriesData.data.push({\n          y: dataField[z][ySchema === null || ySchema === void 0 ? void 0 : ySchema.field_alias],\n          // tslint:disable-next-line:max-line-length\n          name: (_dataField$z = dataField[z]) !== null && _dataField$z !== void 0 && _dataField$z.customLabel ? (_dataField$z2 = dataField[z]) === null || _dataField$z2 === void 0 ? void 0 : _dataField$z2.customLabel : data[z][xSchema === null || xSchema === void 0 ? void 0 : xSchema.field_alias],\n          color: dataField[z] ? (_dataField$z3 = dataField[z]) === null || _dataField$z3 === void 0 ? void 0 : _dataField$z3.color : (_data$z = data[z]) === null || _data$z === void 0 ? void 0 : _data$z.color,\n          // color: chartConfig.configLegendPie[z] ? chartConfig.configLegendPie[z]?.color : null,\n          schema: xSchema !== null && xSchema !== void 0 ? xSchema : null,\n          originalName: (_dataField$z$name = dataField[z].name) !== null && _dataField$z$name !== void 0 ? _dataField$z$name : ''\n        });\n      } else {\n        var _data$z2, _data$z3, _data$z$name;\n        seriesData.data.push({\n          y: data[z][ySchema === null || ySchema === void 0 ? void 0 : ySchema.field_alias],\n          name: data[z][xSchema === null || xSchema === void 0 ? void 0 : xSchema.field_alias],\n          color: (_data$z2 = data[z]) !== null && _data$z2 !== void 0 && _data$z2.color ? (_data$z3 = data[z]) === null || _data$z3 === void 0 ? void 0 : _data$z3.color : 'red',\n          schema: xSchema !== null && xSchema !== void 0 ? xSchema : null,\n          originalName: (_data$z$name = data[z].name) !== null && _data$z$name !== void 0 ? _data$z$name : ''\n        });\n      }\n    }\n    chartOptions.series.push(seriesData);\n    ChartPie.createChart(chartId);\n  },\n  createChart: function createChart(chartId) {\n    highcharts__WEBPACK_IMPORTED_MODULE_2___default().chart(\"chart-item-\".concat(chartId), chartOptions);\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChartPie);\n\n//# sourceURL=webpack://my-webpack-project/./src/modules/highcharts/pie.js?");

/***/ }),

/***/ "./src/modules/report/report.js":
/*!**************************************!*\
  !*** ./src/modules/report/report.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../api */ \"./src/api/index.js\");\n/* harmony import */ var _errors_ApiNotFoundError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/ApiNotFoundError */ \"./src/errors/ApiNotFoundError.js\");\n/* harmony import */ var gridstack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gridstack */ \"./node_modules/gridstack/dist/gridstack.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\nvar reportDashBoard = {\n  init: function init() {\n    return {\n      apiUrl: ''\n    };\n  },\n  getReportDetail: function () {\n    var _getReportDetail = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url) {\n      var data, _data$report;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(url);\n          case 3:\n            data = _context.sent;\n            if (!((data === null || data === void 0 ? void 0 : data.status) === 1)) {\n              _context.next = 6;\n              break;\n            }\n            return _context.abrupt(\"return\", (_data$report = data === null || data === void 0 ? void 0 : data.report) !== null && _data$report !== void 0 ? _data$report : null);\n          case 6:\n            _context.next = 11;\n            break;\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](0);\n            console.error(_context.t0);\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[0, 8]]);\n    }));\n    function getReportDetail(_x) {\n      return _getReportDetail.apply(this, arguments);\n    }\n    return getReportDetail;\n  }()\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reportDashBoard);\n\n//# sourceURL=webpack://my-webpack-project/./src/modules/report/report.js?");

/***/ }),

/***/ "./src/modules/tables/table.js":
/*!*************************************!*\
  !*** ./src/modules/tables/table.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../api */ \"./src/api/index.js\");\n/* harmony import */ var _errors_ApiNotFoundError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/ApiNotFoundError */ \"./src/errors/ApiNotFoundError.js\");\n/* harmony import */ var _environments_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../environments/environment */ \"./src/environments/environment.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n// let apiUrl = environment.apiBackend.chart;\n\nvar ChartTable = {\n  init: function init() {\n    return {};\n  },\n  drawAt: function () {\n    var _drawAt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(chartId) {\n      var apiUrl, body, data, schema, dataValue, table, headerRow, domTable;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            apiUrl = 'https://cdp-reporting.admicro.vn/api/v1/chart/public/query-data-by-condition/{CHART_ID}';\n            apiUrl = apiUrl.replace('{CHART_ID}', chartId);\n            body = {\n              filters: []\n            };\n            _context.prev = 3;\n            if (apiUrl) {\n              _context.next = 6;\n              break;\n            }\n            throw new _errors_ApiNotFoundError__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Bar chart api url không được để trống');\n          case 6:\n            _context.next = 8;\n            return _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(apiUrl, body);\n          case 8:\n            data = _context.sent;\n            schema = data.chart.schema;\n            dataValue = data.chart.data;\n            if ((data === null || data === void 0 ? void 0 : data.status) === 1) {\n              table = document.createElement(\"table\");\n              headerRow = document.createElement(\"tr\");\n              table.appendChild(headerRow);\n              schema.forEach(function (item) {\n                var headerCell1 = document.createElement(\"th\");\n                var span = document.createElement(\"span\");\n                span.textContent = item.field_mapping;\n                headerCell1.appendChild(span);\n                headerRow.appendChild(headerCell1);\n              });\n              dataValue.forEach(function (item) {\n                var dataRow = document.createElement(\"tr\");\n                schema.forEach(function (itemSchema) {\n                  var _item$itemSchema$fiel;\n                  var dataCell = document.createElement(\"td\");\n                  var span = document.createElement(\"span\");\n                  span.textContent = (_item$itemSchema$fiel = item[itemSchema.field_alias]) !== null && _item$itemSchema$fiel !== void 0 ? _item$itemSchema$fiel : null;\n                  dataCell.appendChild(span);\n                  dataRow.appendChild(dataCell);\n                });\n                table.appendChild(dataRow);\n              });\n              domTable = document.getElementById(\"chart-item-\".concat(chartId));\n              domTable.appendChild(table);\n            }\n            _context.next = 17;\n            break;\n          case 14:\n            _context.prev = 14;\n            _context.t0 = _context[\"catch\"](3);\n            console.error(_context.t0);\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[3, 14]]);\n    }));\n    function drawAt(_x) {\n      return _drawAt.apply(this, arguments);\n    }\n    return drawAt;\n  }()\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChartTable);\n\n//# sourceURL=webpack://my-webpack-project/./src/modules/tables/table.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;